package main

import (
	"bytes"
	"fmt"
	"io"
	"path"
	"strings"

	"github.com/alecthomas/chroma"
	"github.com/alecthomas/chroma/formatters/html"
	"github.com/alecthomas/chroma/lexers"
	"github.com/alecthomas/chroma/styles"
	"github.com/gomarkdown/markdown"
	"github.com/gomarkdown/markdown/ast"
	mdhtml "github.com/gomarkdown/markdown/html"
	"github.com/gomarkdown/markdown/parser"
	"github.com/kjk/u"
	"github.com/microcosm-cc/bluemonday"
)

var (
	htmlFormatter  *html.Formatter
	highlightStyle *chroma.Style
)

// HeadingInfo describes # heading in markdown text
type HeadingInfo struct {
	Text string
	ID   string
}

func init() {
	htmlFormatter = html.New(html.WithClasses(), html.TabWidth(2))
	u.PanicIf(htmlFormatter == nil, "couldn't create html formatter")
	styleName := "monokailight"
	highlightStyle = styles.Get(styleName)
	u.PanicIf(highlightStyle == nil, "didn't find style '%s'", styleName)
}

// based on https://github.com/alecthomas/chroma/blob/master/quick/quick.go
func htmlHighlight(w io.Writer, source, lang string) error {
	l := lexers.Get(lang)
	if l == nil {
		l = lexers.Analyse(source)
	}
	if l == nil {
		l = lexers.Fallback
	}
	l = chroma.Coalesce(l)

	it, err := l.Tokenise(nil, source)
	if err != nil {
		return err
	}
	return htmlFormatter.Format(w, highlightStyle, it)
}

var didPrint = false

func printKnownURLS(a []string) {
	if didPrint {
		return
	}
	didPrint = true
	fmt.Printf("%d known urls\n", len(a))
	for _, s := range a {
		fmt.Printf("%s\n", s)
	}
}

// turn partial url like "20381" into a full url like "20381-installing"
func fixupURL(uri string, knownURLS []string) string {
	// skip uris that are not article/chapter uris
	if strings.Contains(uri, "/") {
		return uri
	}
	for _, known := range knownURLS {
		if uri == known {
			return uri
		}
		if strings.HasPrefix(known, uri) {
			//fmt.Printf("fixupURL: %s => %s\n", uri, known)
			return known
		}
	}
	fmt.Printf("fixupURL: didn't fix up: %s\n", uri)
	//printKnownURLS(knownURLS)
	return uri
}

// CodeBlockInfo represents parsed lang line in
// markdown code block:
// ${lang}|githbu|${uri}|playground|${uri}
// every part is optional
type CodeBlockInfo struct {
	Lang          string
	GitHubURI     string
	PlaygroundURI string
}

func parseCodeBlockInfo(s string) *CodeBlockInfo {
	var res CodeBlockInfo
	s = strings.TrimSpace(s)
	if len(s) == 0 {
		return &res
	}
	parts := strings.Split(s, "|")
	res.Lang = parts[0]
	parts = parts[1:]
	// now we have pairs of values: (github, uri), (playground, uri)
	u.PanicIf(len(parts)%2 != 0)
	if len(parts) == 0 {
		return &res
	}
	n := len(parts) / 2
	for i := 0; i < n; i++ {
		key := parts[i*2]
		val := parts[i*2+1]
		switch key {
		case "github":
			res.GitHubURI = val
		case "playground":
			res.PlaygroundURI = val
		default:
			err := fmt.Errorf("invalid lang line '%s'", s)
			u.PanicIfErr(err)
		}
	}
	return &res
}

// gross hack. we need change html generated by chroma
func fixupHTMLCodeBlock(htmlCode string, info *CodeBlockInfo) string {
	classLang := ""
	if info.Lang != "" {
		classLang = " lang-" + info.Lang
	}

	if info.GitHubURI == "" && info.PlaygroundURI == "" {
		html := fmt.Sprintf(`
<div class="code-box%s">
	<div>
		%s
	</div>
</div>`, classLang, htmlCode)
		return html
	}

	playgroundPart := ""
	if info.PlaygroundURI != "" {
		playgroundPart = fmt.Sprintf(`
<div class="code-box-playground">
	<a href="%s" target="_blank">try online</a>
</div>
`, info.PlaygroundURI)
	}

	gitHubPart := ""
	if info.GitHubURI != "" {
		// gitHubLoc is sth. like github.com/essentialbooks/books/books/go/main.go
		fileName := path.Base(info.GitHubURI)
		gitHubPart = fmt.Sprintf(`
<div class="code-box-github">
	<a href="%s" target="_blank">%s</a>
</div>`, info.GitHubURI, fileName)
	}

	html := fmt.Sprintf(`
<div class="code-box%s">
	<div>
	%s
	</div>
	<div class="code-box-nav">
		%s
		%s
	</div>
</div>`, classLang, htmlCode, playgroundPart, gitHubPart)
	return html
}

// knownUrls is a list of chapter/article urls in the form "20381-installing"
func makeRenderHookCodeBlock(defaultLang string, knownUrls []string) mdhtml.RenderNodeFunc {
	return func(w io.Writer, node ast.Node, entering bool) (ast.WalkStatus, bool) {

		if codeBlock, ok := node.(*ast.CodeBlock); ok {
			info := parseCodeBlockInfo(string(codeBlock.Info))
			//fmt.Printf("lang: %s, gitHub: %s\n", info.Lang, info.GitHubURI)
			//fmt.Printf("\n----\n%s\n----\n", string(codeBlock.Literal))
			var tmp bytes.Buffer
			if info.Lang == "" {
				info.Lang = defaultLang
			}
			htmlHighlight(&tmp, string(codeBlock.Literal), info.Lang)
			d := tmp.Bytes()
			s := fixupHTMLCodeBlock(string(d), info)
			io.WriteString(w, s)
			return ast.GoToNext, true
		} else if link, ok := node.(*ast.Link); ok {
			// fix up the url if it's a prefix of known url and let original code to render it
			dest := string(link.Destination)
			link.Destination = []byte(fixupURL(dest, knownUrls))
			return ast.GoToNext, false
		} else {
			return ast.GoToNext, false
		}
	}
}

func markdownToUnsafeHTML(md []byte, defaultLang string, knownUrls []string) []byte {
	extensions := parser.NoIntraEmphasis |
		parser.Tables |
		parser.FencedCode |
		parser.Autolink |
		parser.Strikethrough |
		parser.SpaceHeadings |
		parser.NoEmptyLineBeforeBlock |
		parser.AutoHeadingIDs
	parser := parser.NewWithExtensions(extensions)

	htmlFlags := mdhtml.Smartypants |
		mdhtml.SmartypantsFractions |
		mdhtml.SmartypantsDashes |
		mdhtml.SmartypantsLatexDashes
	htmlOpts := mdhtml.RendererOptions{
		Flags:          htmlFlags,
		RenderNodeHook: makeRenderHookCodeBlock(defaultLang, knownUrls),
	}
	renderer := mdhtml.NewRenderer(htmlOpts)
	return markdown.ToHTML(md, parser, renderer)
}

func sanitizeHTML(d []byte) []byte {
	policy := bluemonday.UGCPolicy()
	policy.AllowStyling()
	policy.RequireNoFollowOnFullyQualifiedLinks(false)
	policy.RequireNoFollowOnLinks(false)
	policy.AllowAttrs("target").OnElements("a")
	return policy.SanitizeBytes(d)
}

// TODO: passing fixupURL() function would be better than knownUrls
func markdownToHTML(d []byte, defaultLang string, knownUrls []string) string {
	unsafe := markdownToUnsafeHTML(d, defaultLang, knownUrls)
	return string(sanitizeHTML(unsafe))
}

func getNodeTextRecur(node ast.Node) string {
	if text, ok := node.(*ast.Text); ok {
		return string(text.Literal)
	}
	if code, ok := node.(*ast.Code); ok {
		return string(code.Literal)
	}
	s := ""
	for _, child := range node.GetChildren() {
		s += getNodeTextRecur(child)
	}
	return s
}

func parseHeadingsFromMarkdown(d []byte) []HeadingInfo {
	var res []HeadingInfo
	extensions := parser.NoIntraEmphasis |
		parser.Tables |
		parser.FencedCode |
		parser.Autolink |
		parser.Strikethrough |
		parser.SpaceHeadings |
		parser.NoEmptyLineBeforeBlock |
		parser.AutoHeadingIDs
	parser := parser.NewWithExtensions(extensions)
	astRoot := markdown.Parse(d, parser)
	walkFunc := func(node ast.Node, entering bool) ast.WalkStatus {
		if !entering {
			return ast.GoToNext
		}
		heading, ok := node.(*ast.Heading)
		if !ok {
			return ast.GoToNext
		}
		s := getNodeTextRecur(heading)
		s = strings.TrimSpace(s)
		if len(s) > 0 {
			h := HeadingInfo{
				Text: s,
				ID:   heading.HeadingID,
			}
			res = append(res, h)
		}
		return ast.GoToNext
	}
	ast.WalkFunc(astRoot, walkFunc)
	return res
}
