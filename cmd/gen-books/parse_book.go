package main

import (
	"fmt"
	"html/template"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/kjk/programming-books/pkg/common"
	"github.com/kjk/programming-books/pkg/kvstore"
	"github.com/kjk/u"
)

// Article represents a part of a chapter
type Article struct {
	// stable, globally unique (across all bookd) id
	// either imported Id from Stack Overflow or auto-generated by us
	// allows stable urls and being able to cross-reference articles
	ID           string
	No           int      // TODO: can I get rid of this?
	Chapter      *Chapter // reference to containing chapter
	Title        string   // used in book_index.tmpl.html
	FileNameBase string   // base for both filename and url, format: a-${ID}-${Title}
	BodyMarkdown string
	// TODO: we should convert all HTML content to markdown
	BodyHTML template.HTML

	// for generating toc of a chapter, all articles that belong to the same
	// chapter as this article
	Siblings  []Article
	IsCurrent bool // only used when part of Siblings

	sourceFilePath string // path of the file from which we've read the article
}

// Book retuns book this article belongs to
func (a *Article) Book() *Book {
	return a.Chapter.Book
}

// GitHubText returns text we display in GitHub box
func (a *Article) GitHubText() string {
	return "Edit on GitHub"
}

// GitHubURL returns url to GitHub repo
func (a *Article) GitHubURL() string {
	uri := a.Chapter.GitHubURL() + "/" + filepath.Base(a.sourceFilePath)
	uri = strings.Replace(uri, "/tree/", "/blob/", -1)
	return uri
}

// GitHubEditURL returns url to editing this article on GitHub
// TODO: verify it's the right noe
func (a *Article) GitHubEditURL() string {
	uri := a.Chapter.GitHubURL() + "/" + filepath.Base(a.sourceFilePath)
	uri = strings.Replace(uri, "/edit/tree/", "/blob/", -1)
	return uri
}

// URL returns url of .html file with this article
func (a *Article) URL() string {
	chap := a.Chapter
	book := chap.Book
	return fmt.Sprintf("/essential/%s/%s", book.FileNameBase, a.FileNameBase)
}

func (a *Article) destFilePath() string {
	return filepath.Join(destEssentialDir, a.Book().FileNameBase, a.FileNameBase+".html")
}

// Chapter represents a book chapter
type Chapter struct {
	// stable, globally unique (across all bookd) id
	// either imported Id from Stack Overflow or auto-generated by us
	// allows stable urls and being able to cross-reference articles
	ID         string
	Book       *Book
	ChapterDir string
	// full path to index.md file
	indexFilePath string
	indexDoc      kvstore.Doc // content of index.md file
	Title         string      // extracted from IndexKV, used in book_index.tmpl.html
	FileNameBase  string      // format: ch-${ID}-${Title}, used for URL and .html file name
	Articles      []*Article
	No            int // TODO: can I get rid of this?

	// used when generating list of chapters at the bottom of each chapter page
	// indicates the chapter we're in right now
	IsCurrent bool
}

// GitHubText returns text we display in GitHub box
func (c *Chapter) GitHubText() string {
	return "Edit on GitHub"
}

// GitHubURL returns url to GitHub repo
func (c *Chapter) GitHubURL() string {
	return c.Book.GitHubURL() + "/" + c.ChapterDir
}

// GitHubEditURL returns url to edit index.md document
func (c *Chapter) GitHubEditURL() string {
	// TODO: fix it
	return "/"
	//return c.Book.GitHubURL() + "/" + c.ChapterDir
}

// VersionsHTML returns html version of versions
func (c *Chapter) VersionsHTML() template.HTML {
	s, err := c.indexDoc.GetValue("VersionsHtml")
	if err != nil {
		s = ""
	}
	return template.HTML(s)
}

// URL is used in book_index.tmpl.html
func (c *Chapter) URL() string {
	return fmt.Sprintf("/essential/%s/%s", c.Book.FileNameBase, c.FileNameBase)
}

func (c *Chapter) destFilePath() string {
	return filepath.Join(destEssentialDir, c.Book.FileNameBase, c.FileNameBase+".html")
}

// TODO: get rid of IntroductionHTML, SyntaxHTML etc., convert to just Body in markdown format

// IntroductionHTML retruns html version of Introduction:
func (c *Chapter) IntroductionHTML() template.HTML {
	s, err := c.indexDoc.GetValue("Introduction")
	if err != nil {
		return template.HTML("")
	}
	html := markdownToHTML([]byte(s), "")
	return template.HTML(html)
}

// SyntaxHTML retruns html version of Syntax:
func (c *Chapter) SyntaxHTML() template.HTML {
	s, err := c.indexDoc.GetValue("Syntax")
	if err != nil {
		return template.HTML("")
	}
	html := markdownToHTML([]byte(s), "")
	return template.HTML(html)
}

// RemarksHTML retruns html version of Remarks:
func (c *Chapter) RemarksHTML() template.HTML {
	s, err := c.indexDoc.GetValue("Remarks")
	if err != nil {
		return template.HTML("")
	}
	html := markdownToHTML([]byte(s), "")
	return template.HTML(html)
}

// ContributorsHTML retruns html version of Contributors:
func (c *Chapter) ContributorsHTML() template.HTML {
	s, err := c.indexDoc.GetValue("Contributors")
	if err != nil {
		return template.HTML("")
	}
	html := markdownToHTML([]byte(s), "")
	return template.HTML(html)
}

// Book represents a book
type Book struct {
	Title          string // used in index.tmpl.html
	titleSafe      string
	TitleLong      string // used in book_index.tmpl.html
	FileNameBase   string
	Chapters       []*Chapter
	sourceDir      string // dir where source markdown files are
	destDir        string // dif where destitation html files are
	SoContributors []int

	cachedArticlesCount int
	defaultLang         string // default programming language for programming examples
}

// GitHubText returns text we show in GitHub link
func (b *Book) GitHubText() string {
	return "Edit on GitHub"
}

// GitHubURL returns link to GitHub for this book
func (b *Book) GitHubURL() string {
	return gitHubBaseURL + "/tree/master/books/" + filepath.Base(b.destDir)
}

// URL returns url of the book, used in index.tmpl.html
func (b *Book) URL() string {
	return fmt.Sprintf("/essential/%s/", b.titleSafe)
}

// ArticlesCount returns total number of articles
func (b *Book) ArticlesCount() int {
	if b.cachedArticlesCount != 0 {
		return b.cachedArticlesCount
	}
	n := 0
	for _, ch := range b.Chapters {
		n += len(ch.Articles)
	}
	b.cachedArticlesCount = n
	return n
}

// ChaptersCount returns number of chapters
func (b *Book) ChaptersCount() int {
	return len(b.Chapters)
}

var (
	defTitle = "No Title"
)

func dumpKV(doc kvstore.Doc) {
	for _, kv := range doc {
		fmt.Printf("K: %s\nV: %s\n", kv.Key, common.ShortenString(kv.Value))
	}
}

func parseArticle(path string) (*Article, error) {
	doc, err := kvstore.ParseKVFile(path)
	if err != nil {
		fmt.Printf("Error parsing KV file: '%s'\n", path)
		return nil, err
	}
	article := &Article{
		sourceFilePath: path,
	}
	article.ID, err = doc.GetValue("Id")
	if err != nil {
		return nil, fmt.Errorf("parseArticle('%s'), err: '%s'", path, err)
	}
	if strings.Contains(article.ID, " ") {
		return nil, fmt.Errorf("parseArticle('%s'), res.ID = '%s' has space in it", path, article.ID)
	}
	article.Title = doc.GetValueSilent("Title", defTitle)
	if article.Title == defTitle {
		fmt.Printf("parseArticle: no title for %s\n", path)
	}
	titleSafe := common.MakeURLSafe(article.Title)
	article.FileNameBase = fmt.Sprintf("a-%s-%s", article.ID, titleSafe)
	article.BodyMarkdown, err = doc.GetValue("Body")
	if err == nil {
		return article, nil
	}
	s, err := doc.GetValue("BodyHtml")
	article.BodyHTML = template.HTML(s)
	if err == nil {
		return article, nil
	}
	// on parsing error, dump the doc
	dumpKV(doc)
	return nil, fmt.Errorf("parseArticle('%s'), err: '%s'", path, err)
}

func buildArticleSiblings(articles []*Article) {
	// build a template
	var siblings []Article
	for i, article := range articles {
		sibling := *article // making a copy, we can't touch the original
		sibling.No = i + 1
		siblings = append(siblings, sibling)
	}
	// for each article, copy a template and set IsCurrent
	for i, article := range articles {
		copy := append([]Article(nil), siblings...)
		copy[i].IsCurrent = true
		article.Siblings = copy
	}
}

func parseChapter(chapter *Chapter) error {
	dir := filepath.Join(chapter.Book.sourceDir, chapter.ChapterDir)
	path := filepath.Join(dir, "index.md")
	doc, err := kvstore.ParseKVFile(path)
	if err != nil {
		return err
	}
	chapter.indexFilePath = path
	chapter.indexDoc = doc
	chapter.Title, err = doc.GetValue("Title")
	if err != nil {
		return fmt.Errorf("parseChapter('%s'), missing Title, err: '%s'", path, err)
	}
	chapter.ID, err = doc.GetValue("Id")
	if err != nil {
		return fmt.Errorf("parseChapter('%s'), missing Id, err: '%s'", path, err)
	}

	if strings.Contains(chapter.ID, " ") {
		return fmt.Errorf("parseChapter('%s'), chapter.ID = '%s' has space in it", path, chapter.ID)
	}

	titleSafe := common.MakeURLSafe(chapter.Title)
	chapter.FileNameBase = fmt.Sprintf("ch-%s-%s", chapter.ID, titleSafe)
	fileInfos, err := ioutil.ReadDir(dir)
	var articles []*Article
	for _, fi := range fileInfos {
		if fi.IsDir() || !fi.Mode().IsRegular() {
			continue
		}
		name := fi.Name()
		if strings.ToLower(filepath.Ext(name)) != ".md" {
			continue
		}

		// some files are not meant to be processed here
		switch strings.ToLower(name) {
		case "index.md":
			continue
		}
		path = filepath.Join(dir, name)
		article, err := parseArticle(path)
		if err != nil {
			return err
		}
		article.Chapter = chapter
		article.No = len(articles) + 1
		articles = append(articles, article)
	}
	buildArticleSiblings(articles)
	chapter.Articles = articles
	return nil
}

func soContributorURL(userID int) string {
	return fmt.Sprintf("https://stackoverflow.com/users/%d/", userID)
}

func loadSoContributorsMust(book *Book, path string) {
	lines, err := common.ReadFileAsLines(path)
	u.PanicIfErr(err)
	var ids []int
	for _, line := range lines {
		id, err := strconv.Atoi(line)
		u.PanicIfErr(err)
		ids = append(ids, id)
	}
	book.SoContributors = ids
}

// TODO: add github contributors
func genContributorsMarkdown(soUserIDs []int) string {
	if len(soUserIDs) == 0 {
		return ""
	}
	lines := []string{
		"Contributors from Stack Overflow:",
	}
	for _, userID := range soUserIDs {
		s := fmt.Sprintf("* [%d](%s)", userID, soContributorURL(userID))
		lines = append(lines, s)
	}
	return strings.Join(lines, "\n")
}

func genContributorsChapter(book *Book) *Chapter {
	md := genContributorsMarkdown(book.SoContributors)
	var doc kvstore.Doc
	kv := kvstore.KeyValue{
		Key:   "Contributors",
		Value: md,
	}
	doc = append(doc, kv)
	ch := &Chapter{
		Book:         book,
		indexDoc:     doc,
		Title:        "Contributors",
		FileNameBase: "ch-contributors",
		No:           999,
	}
	return ch
}

// make sure chapter/article ids within the book are unique, so that we can generate stable urls
func ensureUniqueIds(book *Book) {
	chapterIds := make(map[string]*Chapter)
	articleIds := make(map[string]*Article)
	for _, c := range book.Chapters {
		if chap, ok := chapterIds[c.ID]; ok {
			fmt.Printf("Duplicate chapter id '%s' in:\n", c.ID)
			fmt.Printf("Chapter '%s', file: '%s'\n", c.Title, c.indexFilePath)
			fmt.Printf("Chapter '%s', file: '%s'\n", chap.Title, chap.indexFilePath)
			os.Exit(1)
		}
		chapterIds[c.ID] = c
		for _, a := range c.Articles {
			if a2, ok := articleIds[a.ID]; ok {
				fmt.Printf("Duplicate article id: '%s', in:\n", a.ID)
				fmt.Printf("Article '%s', file: '%s'\n", a.Title, a.sourceFilePath)
				fmt.Printf("Article '%s', file: '%s'\n", a2.Title, a2.sourceFilePath)
				os.Exit(1)
			}
			articleIds[a.ID] = a
		}
	}
}

func parseBook(bookName string) (*Book, error) {
	bookNameSafe := common.MakeURLSafe(bookName)
	srcDir := filepath.Join("books", bookNameSafe)
	book := &Book{
		Title:        bookName,
		titleSafe:    bookNameSafe,
		TitleLong:    fmt.Sprintf("Essential %s", bookName),
		FileNameBase: bookNameSafe,
		sourceDir:    srcDir,
		destDir:      filepath.Join(destEssentialDir, bookNameSafe),
	}
	fileInfos, err := ioutil.ReadDir(srcDir)
	if err != nil {
		return nil, err
	}
	var chapters []*Chapter
	for _, fi := range fileInfos {
		if fi.IsDir() {
			ch := &Chapter{
				Book:       book,
				ChapterDir: fi.Name(),
			}
			err = parseChapter(ch)
			if err != nil {
				return nil, err
			}
			chapters = append(chapters, ch)
			ch.No = len(chapters)
			continue
		}
		name := strings.ToLower(fi.Name())
		// some files should be ignored
		if name == "toc.txt" {
			continue
		}
		if name == "so_contributors.txt" {
			path := filepath.Join(srcDir, fi.Name())
			loadSoContributorsMust(book, path)
			continue
		}
		return nil, fmt.Errorf("Unexpected file at top-level: '%s'", fi.Name())
	}

	ensureUniqueIds(book)

	ch := genContributorsChapter(book)
	ch.No = len(chapters) + 1
	chapters = append(chapters, ch)
	book.Chapters = chapters
	fmt.Printf("Book '%s' %d chapters, %d articles\n", bookName, len(chapters), book.ArticlesCount())
	return book, nil
}
