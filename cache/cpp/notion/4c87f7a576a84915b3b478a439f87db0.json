{
  "ID": "4c87f7a5-76a8-4915-b3b4-78a439f87db0",
  "Root": {
    "alive": true,
    "content": [
      "970e95ec-1ffd-4abe-b442-559187a01bbf",
      "25dd0420-1879-453e-a802-0b780f5fa464",
      "a1fff17a-da98-408b-a304-92e459c84af3",
      "15cd7533-05a4-467f-b405-13ae1834d094",
      "e6dd4a73-b4e1-42d3-95cb-2349702d9634"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1550522324593,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "4c87f7a5-76a8-4915-b3b4-78a439f87db0",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1550709600000,
    "parent_id": "96325b08-db02-4f4f-a7a3-7510a746dbe2",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          " RAII Resource Acquisition Is Initialization"
        ]
      ]
    },
    "type": "page",
    "version": 7,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522324592,
        "id": "970e95ec-1ffd-4abe-b442-559187a01bbf",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522324592,
        "parent_id": "4c87f7a5-76a8-4915-b3b4-78a439f87db0",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Remarks"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Remarks"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522324593,
        "id": "25dd0420-1879-453e-a802-0b780f5fa464",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522324593,
        "parent_id": "4c87f7a5-76a8-4915-b3b4-78a439f87db0",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "RAII stands for "
            ],
            [
              "R",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              "esource "
            ],
            [
              "A",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              "cquisition "
            ],
            [
              "I",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              "s "
            ],
            [
              "I",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              "nitialization. Also occasionally referred to as SBRM (Scope-Based Resource Management) or RRID (Resource Release Is Destruction), RAII is an idiom used to tie resources to object lifetime. In C++, the destructor for an object always runs when an object goes out of scope - we can take advantage of that to tie resource cleanup into object destruction."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "RAII stands for "
          },
          {
            "Text": "R",
            "AttrFlags": 1
          },
          {
            "Text": "esource "
          },
          {
            "Text": "A",
            "AttrFlags": 1
          },
          {
            "Text": "cquisition "
          },
          {
            "Text": "I",
            "AttrFlags": 1
          },
          {
            "Text": "s "
          },
          {
            "Text": "I",
            "AttrFlags": 1
          },
          {
            "Text": "nitialization. Also occasionally referred to as SBRM (Scope-Based Resource Management) or RRID (Resource Release Is Destruction), RAII is an idiom used to tie resources to object lifetime. In C++, the destructor for an object always runs when an object goes out of scope - we can take advantage of that to tie resource cleanup into object destruction."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522324593,
        "id": "a1fff17a-da98-408b-a304-92e459c84af3",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522324593,
        "parent_id": "4c87f7a5-76a8-4915-b3b4-78a439f87db0",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Any time you need to acquire some resource (e.g. a lock, a file handle, an allocated buffer) that you will eventually need to release, you should consider using an object to handle that resource management for you. Stack unwinding will happen regardless of exception or early scope exit, so the resource handler object will clean up the resource for you without you having to carefully consider all possible current and future code paths."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Any time you need to acquire some resource (e.g. a lock, a file handle, an allocated buffer) that you will eventually need to release, you should consider using an object to handle that resource management for you. Stack unwinding will happen regardless of exception or early scope exit, so the resource handler object will clean up the resource for you without you having to carefully consider all possible current and future code paths."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522324593,
        "id": "15cd7533-05a4-467f-b405-13ae1834d094",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522324593,
        "parent_id": "4c87f7a5-76a8-4915-b3b4-78a439f87db0",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "It’s worth noting that RAII doesn’t completely free the developer of thinking about the lifetime of resources. One case is, obviously, a crash or exit() call, which will prevent destructors from being called. Since the OS will clean up process-local resources like memory after a process ends, this is not a problem in most cases. However with system resources (i.e. named pipes, lock files, shared memory) you still need facilities to deal with the case where a process didn’t clean up after itself, i.e. on startup test if the lock file is there, if it is, verify the process with the pid actually exists, then act accordingly."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "It’s worth noting that RAII doesn’t completely free the developer of thinking about the lifetime of resources. One case is, obviously, a crash or exit() call, which will prevent destructors from being called. Since the OS will clean up process-local resources like memory after a process ends, this is not a problem in most cases. However with system resources (i.e. named pipes, lock files, shared memory) you still need facilities to deal with the case where a process didn’t clean up after itself, i.e. on startup test if the lock file is there, if it is, verify the process with the pid actually exists, then act accordingly."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522324593,
        "id": "e6dd4a73-b4e1-42d3-95cb-2349702d9634",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522324593,
        "parent_id": "4c87f7a5-76a8-4915-b3b4-78a439f87db0",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Another situation is when a unix process calls a function from the exec-family, i.e. after a fork-exec to create a new process. Here, the child process will have a full copy of the parents memory (including the RAII objects) but once exec was called, none of the destructors will be called in that process. On the other hand, if a process is forked and neither of the processes call exec, all resources are cleaned up in both processes. This is correct only for all resources that were actually duplicated in the fork, but with system resources, both processes will only have a reference to the resource (i.e. the path to a lock file) and will both try to release it individually, potentially causing the other process to fail."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Another situation is when a unix process calls a function from the exec-family, i.e. after a fork-exec to create a new process. Here, the child process will have a full copy of the parents memory (including the RAII objects) but once exec was called, none of the destructors will be called in that process. On the other hand, if a process is forked and neither of the processes call exec, all resources are cleaned up in both processes. This is correct only for all resources that were actually duplicated in the fork, but with system resources, both processes will only have a reference to the resource (i.e. the path to a lock file) and will both try to release it individually, potentially causing the other process to fail."
          }
        ]
      }
    ],
    "title": " RAII Resource Acquisition Is Initialization",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}