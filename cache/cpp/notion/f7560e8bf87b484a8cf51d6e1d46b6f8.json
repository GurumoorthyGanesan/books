{
  "ID": "f7560e8b-f87b-484a-8cf5-1d6e1d46b6f8",
  "Root": {
    "alive": true,
    "content": [
      "b40d33ee-ca20-4355-8cd5-46b3ecf8f2ae",
      "7dd745b5-6394-4b51-a18c-28ed8c821acb",
      "418f119f-cbb8-4349-9f19-8bc2d6de7e2a",
      "d1712c7c-c2e9-4939-9a84-2bf872f7024d",
      "cafd9607-1f8b-46bf-bb53-0c934a821ed8",
      "e4e088c2-0f5f-4c58-9881-4397036110dd",
      "93b3dd92-60d4-4727-b80a-bf061fe33920",
      "7018413b-4782-4ad2-9b96-f44c48f6e9ed",
      "f32b48cf-98ea-418f-b0d7-78f54d8d594f",
      "ed302da3-2499-4376-be91-e6b53880d586",
      "5ef7eae8-ea76-443f-9c74-1bfedb4c93f3",
      "1603b01d-ad16-4aeb-9179-e4c0328d42d0"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1550523041462,
    "id": "f7560e8b-f87b-484a-8cf5-1d6e1d46b6f8",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1551687145783,
    "parent_id": "5dbd715a-2e96-4062-9cda-4e181e63af5e",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Erasing down to a Regular type with manual vtable"
        ]
      ]
    },
    "type": "page",
    "version": 3,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523041455,
        "id": "b40d33ee-ca20-4355-8cd5-46b3ecf8f2ae",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550523041455,
        "parent_id": "f7560e8b-f87b-484a-8cf5-1d6e1d46b6f8",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "C++ thrives on what is known as a Regular type (or at least Pseudo-Regular)."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "C++ thrives on what is known as a Regular type (or at least Pseudo-Regular)."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523041457,
        "id": "7dd745b5-6394-4b51-a18c-28ed8c821acb",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550523041457,
        "parent_id": "f7560e8b-f87b-484a-8cf5-1d6e1d46b6f8",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "A Regular type is a type that can be constructed and assigned-to and assigned-from via copy or move, can be destroyed, and can be compared equal-to. It can also be constructed from no arguments. Finally, it also has support for a few other operations that are highly useful in various "
            ],
            [
              "std",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " algorithms and containers."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "A Regular type is a type that can be constructed and assigned-to and assigned-from via copy or move, can be destroyed, and can be compared equal-to. It can also be constructed from no arguments. Finally, it also has support for a few other operations that are highly useful in various "
          },
          {
            "Text": "std",
            "AttrFlags": 2
          },
          {
            "Text": " algorithms and containers."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523041460,
        "id": "418f119f-cbb8-4349-9f19-8bc2d6de7e2a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550523041460,
        "parent_id": "f7560e8b-f87b-484a-8cf5-1d6e1d46b6f8",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "This is the root paper",
              [
                [
                  "a",
                  "http://www.stepanovpapers.com/DeSt98.pdf"
                ]
              ]
            ],
            [
              ", but in C++11 would want to add "
            ],
            [
              "std::hash",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " support."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "This is the root paper",
            "Link": "http://www.stepanovpapers.com/DeSt98.pdf"
          },
          {
            "Text": ", but in C++11 would want to add "
          },
          {
            "Text": "std::hash",
            "AttrFlags": 2
          },
          {
            "Text": " support."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523041460,
        "id": "d1712c7c-c2e9-4939-9a84-2bf872f7024d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550523041460,
        "parent_id": "f7560e8b-f87b-484a-8cf5-1d6e1d46b6f8",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "I will use the manual vtable approach to type erasure here."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "I will use the manual vtable approach to type erasure here."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523041460,
        "id": "cafd9607-1f8b-46bf-bb53-0c934a821ed8",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550523041460,
        "parent_id": "f7560e8b-f87b-484a-8cf5-1d6e1d46b6f8",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "using dtor_unique_ptr = std::unique_ptr\u003cvoid, void(*)(void*)\u003e;\ntemplate\u003cclass T, class...Args\u003e\ndtor_unique_ptr make_dtor_unique_ptr( Args\u0026\u0026... args ) {\n  return {new T(std::forward\u003cArgs\u003e(args)...), [](void* self){ delete static_cast\u003cT*\u003e(self); }};\n}\nstruct regular_vtable {\n  void(*copy_assign)(void* dest, void const* src); // T\u0026=(T const\u0026)\n  void(*move_assign)(void* dest, void* src); // T\u0026=(T\u0026\u0026)\n  bool(*equals)(void const* lhs, void const* rhs); // T const\u0026==T const\u0026\n  bool(*order)(void const* lhs, void const* rhs); // std::less\u003cT\u003e{}(T const\u0026, T const\u0026)\n  std::size_t(*hash)(void const* self); // std::hash\u003cT\u003e{}(T const\u0026)\n  std::type_info const\u0026(*type)(); // typeid(T)\n  dtor_unique_ptr(*clone)(void const* self); // T(T const\u0026)\n};\n\ntemplate\u003cclass T\u003e\nregular_vtable make_regular_vtable() noexcept {\n  return {\n    [](void* dest, void const* src){ *static_cast\u003cT*\u003e(dest) = *static_cast\u003cT const*\u003e(src); },\n    [](void* dest, void* src){ *static_cast\u003cT*\u003e(dest) = std::move(*static_cast\u003cT*\u003e(src)); },\n    [](void const* lhs, void const* rhs){ return *static_cast\u003cT const*\u003e(lhs) == *static_cast\u003cT const*\u003e(rhs); },\n    [](void const* lhs, void const* rhs) { return std::less\u003cT\u003e{}(*static_cast\u003cT const*\u003e(lhs),*static_cast\u003cT const*\u003e(rhs)); },\n    [](void const* self){ return std::hash\u003cT\u003e{}(*static_cast\u003cT const*\u003e(self)); },\n    []()-\u003edecltype(auto){ return typeid(T); },\n    [](void const* self){ return make_dtor_unique_ptr\u003cT\u003e(*static_cast\u003cT const*\u003e(self)); }\n  };\n}\ntemplate\u003cclass T\u003e\nregular_vtable const* get_regular_vtable() noexcept {\n  static const regular_vtable vtable=make_regular_vtable\u003cT\u003e();\n  return \u0026vtable;\n}\n\nstruct regular_type {\n  using self=regular_type;\n  regular_vtable const* vtable = 0;\n  dtor_unique_ptr ptr{nullptr, [](void*){}};\n  \n  bool empty() const { return !vtable; }\n\n  template\u003cclass T, class...Args\u003e\n  void emplace( Args\u0026\u0026... args ) {\n    ptr = make_dtor_unique_ptr\u003cT\u003e(std::forward\u003cArgs\u003e(args)...);\n    if (ptr)\n      vtable = get_regular_vtable\u003cT\u003e();\n    else\n      vtable = nullptr;\n  }\n  friend bool operator==(regular_type const\u0026 lhs, regular_type const\u0026 rhs) {\n    if (lhs.vtable != rhs.vtable) return false;\n    return lhs.vtable-\u003eequals( lhs.ptr.get(), rhs.ptr.get() );\n  }\n  bool before(regular_type const\u0026 rhs) const {\n    auto const\u0026 lhs = *this;\n    if (!lhs.vtable || !rhs.vtable)\n      return std::less\u003cregular_vtable const*\u003e{}(lhs.vtable,rhs.vtable);\n    if (lhs.vtable != rhs.vtable)\n      return lhs.vtable-\u003etype().before(rhs.vtable-\u003etype());\n    return lhs.vtable-\u003eorder( lhs.ptr.get(), rhs.ptr.get() );\n  }\n  // technically friend bool operator\u003c that calls before is also required\n\n  std::type_info const* type() const {\n    if (!vtable) return nullptr;\n    return \u0026vtable-\u003etype();\n  }\n  regular_type(regular_type\u0026\u0026 o):\n    vtable(o.vtable),\n    ptr(std::move(o.ptr))\n  {\n    o.vtable = nullptr;\n  }\n  friend void swap(regular_type\u0026 lhs, regular_type\u0026 rhs){\n    std::swap(lhs.ptr, rhs.ptr);\n    std::swap(lhs.vtable, rhs.vtable);\n  }\n  regular_type\u0026 operator=(regular_type\u0026\u0026 o) {\n    if (o.vtable == vtable) {\n      vtable-\u003emove_assign(ptr.get(), o.ptr.get());\n      return *this;\n    }\n    auto tmp = std::move(o);\n    swap(*this, tmp);\n    return *this;\n  }\n  regular_type(regular_type const\u0026 o):\n    vtable(o.vtable),\n    ptr(o.vtable?o.vtable-\u003eclone(o.ptr.get()):dtor_unique_ptr{nullptr, [](void*){}})\n  {\n    if (!ptr \u0026\u0026 vtable) vtable = nullptr;\n  }\n  regular_type\u0026 operator=(regular_type const\u0026 o) {\n    if (o.vtable == vtable) {\n      vtable-\u003ecopy_assign(ptr.get(), o.ptr.get());\n      return *this;\n    }\n    auto tmp = o;\n    swap(*this, tmp);\n    return *this;\n  }\n  std::size_t hash() const {\n    if (!vtable) return 0;\n    return vtable-\u003ehash(ptr.get());\n  }\n  template\u003cclass T,\n    std::enable_if_t\u003c !std::is_same\u003cstd::decay_t\u003cT\u003e, regular_type\u003e{}, int\u003e* =nullptr\n  \u003e\n  regular_type(T\u0026\u0026 t) {\n    emplace\u003cstd::decay_t\u003cT\u003e\u003e(std::forward\u003cT\u003e(t));\n  }\n};\nnamespace std {\n  template\u003c\u003e\n  struct hash\u003cregular_type\u003e {\n    std::size_t operator()( regular_type const\u0026 r )const {\n      return r.hash();\n    }\n  };\n  template\u003c\u003e\n  struct less\u003cregular_type\u003e {\n    bool operator()( regular_type const\u0026 lhs, regular_type const\u0026 rhs ) const {\n      return lhs.before(rhs);\n    }\n  };\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "using dtor_unique_ptr = std::unique_ptr\u003cvoid, void(*)(void*)\u003e;\ntemplate\u003cclass T, class...Args\u003e\ndtor_unique_ptr make_dtor_unique_ptr( Args\u0026\u0026... args ) {\n  return {new T(std::forward\u003cArgs\u003e(args)...), [](void* self){ delete static_cast\u003cT*\u003e(self); }};\n}\nstruct regular_vtable {\n  void(*copy_assign)(void* dest, void const* src); // T\u0026=(T const\u0026)\n  void(*move_assign)(void* dest, void* src); // T\u0026=(T\u0026\u0026)\n  bool(*equals)(void const* lhs, void const* rhs); // T const\u0026==T const\u0026\n  bool(*order)(void const* lhs, void const* rhs); // std::less\u003cT\u003e{}(T const\u0026, T const\u0026)\n  std::size_t(*hash)(void const* self); // std::hash\u003cT\u003e{}(T const\u0026)\n  std::type_info const\u0026(*type)(); // typeid(T)\n  dtor_unique_ptr(*clone)(void const* self); // T(T const\u0026)\n};\n\ntemplate\u003cclass T\u003e\nregular_vtable make_regular_vtable() noexcept {\n  return {\n    [](void* dest, void const* src){ *static_cast\u003cT*\u003e(dest) = *static_cast\u003cT const*\u003e(src); },\n    [](void* dest, void* src){ *static_cast\u003cT*\u003e(dest) = std::move(*static_cast\u003cT*\u003e(src)); },\n    [](void const* lhs, void const* rhs){ return *static_cast\u003cT const*\u003e(lhs) == *static_cast\u003cT const*\u003e(rhs); },\n    [](void const* lhs, void const* rhs) { return std::less\u003cT\u003e{}(*static_cast\u003cT const*\u003e(lhs),*static_cast\u003cT const*\u003e(rhs)); },\n    [](void const* self){ return std::hash\u003cT\u003e{}(*static_cast\u003cT const*\u003e(self)); },\n    []()-\u003edecltype(auto){ return typeid(T); },\n    [](void const* self){ return make_dtor_unique_ptr\u003cT\u003e(*static_cast\u003cT const*\u003e(self)); }\n  };\n}\ntemplate\u003cclass T\u003e\nregular_vtable const* get_regular_vtable() noexcept {\n  static const regular_vtable vtable=make_regular_vtable\u003cT\u003e();\n  return \u0026vtable;\n}\n\nstruct regular_type {\n  using self=regular_type;\n  regular_vtable const* vtable = 0;\n  dtor_unique_ptr ptr{nullptr, [](void*){}};\n  \n  bool empty() const { return !vtable; }\n\n  template\u003cclass T, class...Args\u003e\n  void emplace( Args\u0026\u0026... args ) {\n    ptr = make_dtor_unique_ptr\u003cT\u003e(std::forward\u003cArgs\u003e(args)...);\n    if (ptr)\n      vtable = get_regular_vtable\u003cT\u003e();\n    else\n      vtable = nullptr;\n  }\n  friend bool operator==(regular_type const\u0026 lhs, regular_type const\u0026 rhs) {\n    if (lhs.vtable != rhs.vtable) return false;\n    return lhs.vtable-\u003eequals( lhs.ptr.get(), rhs.ptr.get() );\n  }\n  bool before(regular_type const\u0026 rhs) const {\n    auto const\u0026 lhs = *this;\n    if (!lhs.vtable || !rhs.vtable)\n      return std::less\u003cregular_vtable const*\u003e{}(lhs.vtable,rhs.vtable);\n    if (lhs.vtable != rhs.vtable)\n      return lhs.vtable-\u003etype().before(rhs.vtable-\u003etype());\n    return lhs.vtable-\u003eorder( lhs.ptr.get(), rhs.ptr.get() );\n  }\n  // technically friend bool operator\u003c that calls before is also required\n\n  std::type_info const* type() const {\n    if (!vtable) return nullptr;\n    return \u0026vtable-\u003etype();\n  }\n  regular_type(regular_type\u0026\u0026 o):\n    vtable(o.vtable),\n    ptr(std::move(o.ptr))\n  {\n    o.vtable = nullptr;\n  }\n  friend void swap(regular_type\u0026 lhs, regular_type\u0026 rhs){\n    std::swap(lhs.ptr, rhs.ptr);\n    std::swap(lhs.vtable, rhs.vtable);\n  }\n  regular_type\u0026 operator=(regular_type\u0026\u0026 o) {\n    if (o.vtable == vtable) {\n      vtable-\u003emove_assign(ptr.get(), o.ptr.get());\n      return *this;\n    }\n    auto tmp = std::move(o);\n    swap(*this, tmp);\n    return *this;\n  }\n  regular_type(regular_type const\u0026 o):\n    vtable(o.vtable),\n    ptr(o.vtable?o.vtable-\u003eclone(o.ptr.get()):dtor_unique_ptr{nullptr, [](void*){}})\n  {\n    if (!ptr \u0026\u0026 vtable) vtable = nullptr;\n  }\n  regular_type\u0026 operator=(regular_type const\u0026 o) {\n    if (o.vtable == vtable) {\n      vtable-\u003ecopy_assign(ptr.get(), o.ptr.get());\n      return *this;\n    }\n    auto tmp = o;\n    swap(*this, tmp);\n    return *this;\n  }\n  std::size_t hash() const {\n    if (!vtable) return 0;\n    return vtable-\u003ehash(ptr.get());\n  }\n  template\u003cclass T,\n    std::enable_if_t\u003c !std::is_same\u003cstd::decay_t\u003cT\u003e, regular_type\u003e{}, int\u003e* =nullptr\n  \u003e\n  regular_type(T\u0026\u0026 t) {\n    emplace\u003cstd::decay_t\u003cT\u003e\u003e(std::forward\u003cT\u003e(t));\n  }\n};\nnamespace std {\n  template\u003c\u003e\n  struct hash\u003cregular_type\u003e {\n    std::size_t operator()( regular_type const\u0026 r )const {\n      return r.hash();\n    }\n  };\n  template\u003c\u003e\n  struct less\u003cregular_type\u003e {\n    bool operator()( regular_type const\u0026 lhs, regular_type const\u0026 rhs ) const {\n      return lhs.before(rhs);\n    }\n  };\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523041461,
        "id": "e4e088c2-0f5f-4c58-9881-4397036110dd",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550523041461,
        "parent_id": "f7560e8b-f87b-484a-8cf5-1d6e1d46b6f8",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "live example",
              [
                [
                  "a",
                  "http://coliru.stacked-crooked.com/a/28ef6be761012a81"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "live example",
            "Link": "http://coliru.stacked-crooked.com/a/28ef6be761012a81"
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523041461,
        "id": "93b3dd92-60d4-4727-b80a-bf061fe33920",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550523041461,
        "parent_id": "f7560e8b-f87b-484a-8cf5-1d6e1d46b6f8",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Such a regular type can be used as a key for a "
            ],
            [
              "std::map",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " or a "
            ],
            [
              "std::unordered_map",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " that accepts "
            ],
            [
              "anything regular",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " for a key, like:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Such a regular type can be used as a key for a "
          },
          {
            "Text": "std::map",
            "AttrFlags": 2
          },
          {
            "Text": " or a "
          },
          {
            "Text": "std::unordered_map",
            "AttrFlags": 2
          },
          {
            "Text": " that accepts "
          },
          {
            "Text": "anything regular",
            "AttrFlags": 4
          },
          {
            "Text": " for a key, like:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523041461,
        "id": "7018413b-4782-4ad2-9b96-f44c48f6e9ed",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550523041461,
        "parent_id": "f7560e8b-f87b-484a-8cf5-1d6e1d46b6f8",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "std::map\u003cregular_type, std::any\u003e"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "std::map\u003cregular_type, std::any\u003e",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523041461,
        "id": "f32b48cf-98ea-418f-b0d7-78f54d8d594f",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550523041461,
        "parent_id": "f7560e8b-f87b-484a-8cf5-1d6e1d46b6f8",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "would be basically a map from anothing regular, to anything copyable."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "would be basically a map from anothing regular, to anything copyable."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523041461,
        "id": "ed302da3-2499-4376-be91-e6b53880d586",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550523041461,
        "parent_id": "f7560e8b-f87b-484a-8cf5-1d6e1d46b6f8",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Unlike "
            ],
            [
              "any",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ", my "
            ],
            [
              "regular_type",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " does no small object optimization nor does it support getting the original data back. Getting the original type back isn’t hard."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Unlike "
          },
          {
            "Text": "any",
            "AttrFlags": 2
          },
          {
            "Text": ", my "
          },
          {
            "Text": "regular_type",
            "AttrFlags": 2
          },
          {
            "Text": " does no small object optimization nor does it support getting the original data back. Getting the original type back isn’t hard."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523041462,
        "id": "5ef7eae8-ea76-443f-9c74-1bfedb4c93f3",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550523041462,
        "parent_id": "f7560e8b-f87b-484a-8cf5-1d6e1d46b6f8",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Small object optimization requires that we store an aligned storage buffer within the "
            ],
            [
              "regular_type",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ", and carefully tweak the deleter of the "
            ],
            [
              "ptr",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " to only destroy the object and not delete it."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Small object optimization requires that we store an aligned storage buffer within the "
          },
          {
            "Text": "regular_type",
            "AttrFlags": 2
          },
          {
            "Text": ", and carefully tweak the deleter of the "
          },
          {
            "Text": "ptr",
            "AttrFlags": 2
          },
          {
            "Text": " to only destroy the object and not delete it."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523041462,
        "id": "1603b01d-ad16-4aeb-9179-e4c0328d42d0",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550523041462,
        "parent_id": "f7560e8b-f87b-484a-8cf5-1d6e1d46b6f8",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "I would start at "
            ],
            [
              "make_dtor_unique_ptr",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " and teach it how to sometimes store the data in a buffer, and then in the heap if no room in the buffer. That may be sufficient."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "I would start at "
          },
          {
            "Text": "make_dtor_unique_ptr",
            "AttrFlags": 2
          },
          {
            "Text": " and teach it how to sometimes store the data in a buffer, and then in the heap if no room in the buffer. That may be sufficient."
          }
        ]
      }
    ],
    "title": "Erasing down to a Regular type with manual vtable"
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}