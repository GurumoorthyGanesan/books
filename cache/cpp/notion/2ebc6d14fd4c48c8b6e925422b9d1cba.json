{
  "ID": "2ebc6d14-fd4c-48c8-b6e9-25422b9d1cba",
  "Root": {
    "alive": true,
    "content": [
      "0c7b1df0-dc5c-431a-9a03-6f83dc26f86a",
      "55c30354-2fb7-482b-8209-643a2e3778b8",
      "98f4f482-40bc-4688-8e47-9a8cfd17065e",
      "41899232-5022-4d90-977e-bb795b7f62f9",
      "15e1f3df-47c4-4745-a3d3-7ac1d91e75a5",
      "66f72487-2a13-4c31-90ac-8f1cecbba5f4",
      "33503590-e9eb-45e8-9a5c-f3297f863d18"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1550522317550,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "2ebc6d14-fd4c-48c8-b6e9-25422b9d1cba",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1550709540000,
    "parent_id": "eb50f34f-bfa8-4e16-9ad9-d114eb1d34d9",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Rule of Five"
        ]
      ]
    },
    "type": "page",
    "version": 10,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522317548,
        "id": "0c7b1df0-dc5c-431a-9a03-6f83dc26f86a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522317548,
        "parent_id": "2ebc6d14-fd4c-48c8-b6e9-25422b9d1cba",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "C++11 introduces two new special member functions: the move constructor and the move assignment operator. For all the same reasons that you want to follow the "
            ],
            [
              "Rule of Three",
              [
                [
                  "a",
                  "http://stackoverflow.com/documentation/c%2B%2B/1206/the-rule-of-three-five-and-zero/9867/rule-of-three#t=201607251426414241612"
                ]
              ]
            ],
            [
              " in C++03, you usually want to follow the Rule of Five in C++11: If a class requires ONE of five special member functions, and if move semantics are desired, then it most likely requires ALL FIVE of them."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "C++11 introduces two new special member functions: the move constructor and the move assignment operator. For all the same reasons that you want to follow the "
          },
          {
            "Text": "Rule of Three",
            "Link": "http://stackoverflow.com/documentation/c%2B%2B/1206/the-rule-of-three-five-and-zero/9867/rule-of-three#t=201607251426414241612"
          },
          {
            "Text": " in C++03, you usually want to follow the Rule of Five in C++11: If a class requires ONE of five special member functions, and if move semantics are desired, then it most likely requires ALL FIVE of them."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522317549,
        "id": "55c30354-2fb7-482b-8209-643a2e3778b8",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522317549,
        "parent_id": "2ebc6d14-fd4c-48c8-b6e9-25422b9d1cba",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Note, however, that failing to follow the Rule of Five is usually not considered an error, but a missed optimisation opportunity, as long as the Rule of Three is still followed. If no move constructor or move assignment operator is available when the compiler would normally use one, it will instead use copy semantics if possible, resulting in a less efficient operation due to unnecessary copy operations. If move semantics aren’t desired for a class, then it has no need to declare a move constructor or assignment operator."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Note, however, that failing to follow the Rule of Five is usually not considered an error, but a missed optimisation opportunity, as long as the Rule of Three is still followed. If no move constructor or move assignment operator is available when the compiler would normally use one, it will instead use copy semantics if possible, resulting in a less efficient operation due to unnecessary copy operations. If move semantics aren’t desired for a class, then it has no need to declare a move constructor or assignment operator."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522317549,
        "id": "98f4f482-40bc-4688-8e47-9a8cfd17065e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522317549,
        "parent_id": "2ebc6d14-fd4c-48c8-b6e9-25422b9d1cba",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Same example as for the Rule of Three:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Same example as for the Rule of Three:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522317550,
        "id": "41899232-5022-4d90-977e-bb795b7f62f9",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522317550,
        "parent_id": "2ebc6d14-fd4c-48c8-b6e9-25422b9d1cba",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "class Person\n{\n    char* name;\n    int age;\n\npublic:\n    // Destructor \n    ~Person() { delete [] name; }\n\n    // Implement Copy Semantics\n    Person(Person const\u0026 other)\n        : name(new char[std::strlen(other.name) + 1])\n        , age(other.age)\n    {\n        std::strcpy(name, other.name);\n    }\n    \n    Person \u0026operator=(Person const\u0026 other) \n    {\n        // Use copy and swap idiom to implement assignment.\n        Person copy(other);\n        swap(*this, copy);\n        return *this;\n    }\n\n    // Implement Move Semantics\n    // Note: It is usually best to mark move operators as noexcept\n    //       This allows certain optimizations in the standard library\n    //       when the class is used in a container.\n\n    Person(Person\u0026\u0026 that) noexcept\n        : name(nullptr)               // Set the state so we know it is undefined\n        , age(0)\n    {\n        swap(*this, that);\n    }\n\n    Person\u0026 operator=(Person\u0026\u0026 that) noexcept\n    {\n        swap(*this, that);\n        return *this;\n    }\n\n    friend void swap(Person\u0026 lhs, Person\u0026 rhs) noexcept\n    {\n        std::swap(lhs.name, rhs.name);\n        std::swap(lhs.age, rhs.age);\n    }\n};"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "class Person\n{\n    char* name;\n    int age;\n\npublic:\n    // Destructor \n    ~Person() { delete [] name; }\n\n    // Implement Copy Semantics\n    Person(Person const\u0026 other)\n        : name(new char[std::strlen(other.name) + 1])\n        , age(other.age)\n    {\n        std::strcpy(name, other.name);\n    }\n    \n    Person \u0026operator=(Person const\u0026 other) \n    {\n        // Use copy and swap idiom to implement assignment.\n        Person copy(other);\n        swap(*this, copy);\n        return *this;\n    }\n\n    // Implement Move Semantics\n    // Note: It is usually best to mark move operators as noexcept\n    //       This allows certain optimizations in the standard library\n    //       when the class is used in a container.\n\n    Person(Person\u0026\u0026 that) noexcept\n        : name(nullptr)               // Set the state so we know it is undefined\n        , age(0)\n    {\n        swap(*this, that);\n    }\n\n    Person\u0026 operator=(Person\u0026\u0026 that) noexcept\n    {\n        swap(*this, that);\n        return *this;\n    }\n\n    friend void swap(Person\u0026 lhs, Person\u0026 rhs) noexcept\n    {\n        std::swap(lhs.name, rhs.name);\n        std::swap(lhs.age, rhs.age);\n    }\n};",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522317550,
        "id": "15e1f3df-47c4-4745-a3d3-7ac1d91e75a5",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522317550,
        "parent_id": "2ebc6d14-fd4c-48c8-b6e9-25422b9d1cba",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Alternatively, both the copy and move assignment operator can be replaced with a single assignment operator, which takes an instance by value instead of reference or rvalue reference to facilitate using the copy-and-swap idiom."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Alternatively, both the copy and move assignment operator can be replaced with a single assignment operator, which takes an instance by value instead of reference or rvalue reference to facilitate using the copy-and-swap idiom."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522317550,
        "id": "66f72487-2a13-4c31-90ac-8f1cecbba5f4",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522317550,
        "parent_id": "2ebc6d14-fd4c-48c8-b6e9-25422b9d1cba",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "Person\u0026 operator=(Person copy)\n{\n    swap(*this, copy);\n    return *this;\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "Person\u0026 operator=(Person copy)\n{\n    swap(*this, copy);\n    return *this;\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522317550,
        "id": "33503590-e9eb-45e8-9a5c-f3297f863d18",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522317550,
        "parent_id": "2ebc6d14-fd4c-48c8-b6e9-25422b9d1cba",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Extending from the Rule of Three to the Rule of Five is important for performance reasons, but is not strictly necessary in most cases. Adding the copy constructor and assignment operator ensures that moving the type will not leak memory (move-constructing will simply fall back to copying in that case), but will be performing copies that the caller probably did not anticipate."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Extending from the Rule of Three to the Rule of Five is important for performance reasons, but is not strictly necessary in most cases. Adding the copy constructor and assignment operator ensures that moving the type will not leak memory (move-constructing will simply fall back to copying in that case), but will be performing copies that the caller probably did not anticipate."
          }
        ]
      }
    ],
    "title": "Rule of Five",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}