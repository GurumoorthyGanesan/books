{
  "ID": "68ade8cc-9bf3-4f50-953d-cf6e72a075d4",
  "Root": {
    "alive": true,
    "content": [
      "a605fe66-1920-48b2-963a-7722855cb8fc",
      "d2e62564-cbd8-4a21-ac79-13a8b3b45969",
      "533fd8cd-6681-48d4-b7e0-5858c6c4c02c",
      "9dbfbb0f-c92d-4325-8012-a806a1aae20d",
      "7989d950-5972-4efa-902e-318dcd497486",
      "a4d6c67c-0bd5-4fa8-98ab-71514082f170",
      "db03043a-8896-4651-a8e5-6aef7e390514",
      "72d590f6-b55b-4b38-b90b-90cfefec47bf",
      "3e7b4b18-09cd-443c-914d-edde0fc553db",
      "3c4b08d3-5f7d-42b0-86c6-626a2e1c29c3",
      "f63556b2-ec42-4635-a448-a0b01283d2d9",
      "3ad870ef-4509-44db-bdcc-348661766351"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1550522318495,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "68ade8cc-9bf3-4f50-953d-cf6e72a075d4",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1550709540000,
    "parent_id": "eb50f34f-bfa8-4e16-9ad9-d114eb1d34d9",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Rule of Three"
        ]
      ]
    },
    "type": "page",
    "version": 8,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522318487,
        "id": "a605fe66-1920-48b2-963a-7722855cb8fc",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522318487,
        "parent_id": "68ade8cc-9bf3-4f50-953d-cf6e72a075d4",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The Rule of Three states that if a type ever needs to have a user-defined copy constructor, copy assignment operator, or destructor, then it must have "
            ],
            [
              "all three",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The Rule of Three states that if a type ever needs to have a user-defined copy constructor, copy assignment operator, or destructor, then it must have "
          },
          {
            "Text": "all three",
            "AttrFlags": 4
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522318492,
        "id": "d2e62564-cbd8-4a21-ac79-13a8b3b45969",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522318492,
        "parent_id": "68ade8cc-9bf3-4f50-953d-cf6e72a075d4",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The reason for the rule is that a class which needs any of the three manages some resource (file handles, dynamically allocated memory, etc), and all three are needed to manage that resource consistently. The copy functions deal with how the resource gets copied between objects, and the destructor would destroy the resource, in accord with "
            ],
            [
              "RAII principles",
              [
                [
                  "a",
                  "http://stackoverflow.com/documentation/c%2B%2B/1320/raii-resource-acquisition-is-initialization#t=201607230301520057618"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The reason for the rule is that a class which needs any of the three manages some resource (file handles, dynamically allocated memory, etc), and all three are needed to manage that resource consistently. The copy functions deal with how the resource gets copied between objects, and the destructor would destroy the resource, in accord with "
          },
          {
            "Text": "RAII principles",
            "Link": "http://stackoverflow.com/documentation/c%2B%2B/1320/raii-resource-acquisition-is-initialization#t=201607230301520057618"
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522318492,
        "id": "533fd8cd-6681-48d4-b7e0-5858c6c4c02c",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522318492,
        "parent_id": "68ade8cc-9bf3-4f50-953d-cf6e72a075d4",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Consider a type that manages a string resource:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Consider a type that manages a string resource:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522318492,
        "id": "9dbfbb0f-c92d-4325-8012-a806a1aae20d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522318492,
        "parent_id": "68ade8cc-9bf3-4f50-953d-cf6e72a075d4",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "class Person\n{\n    char* name;\n    int age;\n\npublic:\n    Person(char const* new_name, int new_age)\n        : name(new char[std::strlen(new_name) + 1])\n        , age(new_age)\n    {\n       std::strcpy(name, new_name);\n    }\n\n    ~Person() {\n        delete [] name;\n    }\n};"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "class Person\n{\n    char* name;\n    int age;\n\npublic:\n    Person(char const* new_name, int new_age)\n        : name(new char[std::strlen(new_name) + 1])\n        , age(new_age)\n    {\n       std::strcpy(name, new_name);\n    }\n\n    ~Person() {\n        delete [] name;\n    }\n};",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522318493,
        "id": "7989d950-5972-4efa-902e-318dcd497486",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522318493,
        "parent_id": "68ade8cc-9bf3-4f50-953d-cf6e72a075d4",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Since "
            ],
            [
              "name",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " was allocated in the constructor, the destructor deallocates it to avoid leaking memory. But what happens if such an object is copied?"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Since "
          },
          {
            "Text": "name",
            "AttrFlags": 2
          },
          {
            "Text": " was allocated in the constructor, the destructor deallocates it to avoid leaking memory. But what happens if such an object is copied?"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522318493,
        "id": "a4d6c67c-0bd5-4fa8-98ab-71514082f170",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522318493,
        "parent_id": "68ade8cc-9bf3-4f50-953d-cf6e72a075d4",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "int main()\n{\n    Person p1(\"foo\", 11);\n    Person p2 = p1;\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "int main()\n{\n    Person p1(\"foo\", 11);\n    Person p2 = p1;\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522318493,
        "id": "db03043a-8896-4651-a8e5-6aef7e390514",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522318493,
        "parent_id": "68ade8cc-9bf3-4f50-953d-cf6e72a075d4",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "First, "
            ],
            [
              "p1",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " will be constructed. Then "
            ],
            [
              "p2",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " will be copied from "
            ],
            [
              "p1",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ". However, the C++-generated copy constructor will copy each component of the type as-is. Which means that "
            ],
            [
              "p1.name",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "p2.name",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " both point to the "
            ],
            [
              "same",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " string."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "First, "
          },
          {
            "Text": "p1",
            "AttrFlags": 2
          },
          {
            "Text": " will be constructed. Then "
          },
          {
            "Text": "p2",
            "AttrFlags": 2
          },
          {
            "Text": " will be copied from "
          },
          {
            "Text": "p1",
            "AttrFlags": 2
          },
          {
            "Text": ". However, the C++-generated copy constructor will copy each component of the type as-is. Which means that "
          },
          {
            "Text": "p1.name",
            "AttrFlags": 2
          },
          {
            "Text": " and "
          },
          {
            "Text": "p2.name",
            "AttrFlags": 2
          },
          {
            "Text": " both point to the "
          },
          {
            "Text": "same",
            "AttrFlags": 1
          },
          {
            "Text": " string."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522318493,
        "id": "72d590f6-b55b-4b38-b90b-90cfefec47bf",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522318493,
        "parent_id": "68ade8cc-9bf3-4f50-953d-cf6e72a075d4",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "When "
            ],
            [
              "main",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " ends, destructors will be called. First "
            ],
            [
              "p2",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "’s destructor will be called; it will delete the string. Then "
            ],
            [
              "p1",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "’s destructor will be called. However, the string is "
            ],
            [
              "already deleted",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Calling "
            ],
            [
              "delete",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " on memory that was already deleted yields undefined behavior."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "When "
          },
          {
            "Text": "main",
            "AttrFlags": 2
          },
          {
            "Text": " ends, destructors will be called. First "
          },
          {
            "Text": "p2",
            "AttrFlags": 2
          },
          {
            "Text": "’s destructor will be called; it will delete the string. Then "
          },
          {
            "Text": "p1",
            "AttrFlags": 2
          },
          {
            "Text": "’s destructor will be called. However, the string is "
          },
          {
            "Text": "already deleted",
            "AttrFlags": 4
          },
          {
            "Text": ". Calling "
          },
          {
            "Text": "delete",
            "AttrFlags": 2
          },
          {
            "Text": " on memory that was already deleted yields undefined behavior."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522318494,
        "id": "3e7b4b18-09cd-443c-914d-edde0fc553db",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522318494,
        "parent_id": "68ade8cc-9bf3-4f50-953d-cf6e72a075d4",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "To avoid this, it is necessary to provide a suitable copy constructor. One approach is to implement a reference counted system, where different "
            ],
            [
              "Person",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " instances share the same string data. Each time a copy is performed, the shared reference count is incremented. The destructor then decrements the reference count, only releasing the memory if the count is zero."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "To avoid this, it is necessary to provide a suitable copy constructor. One approach is to implement a reference counted system, where different "
          },
          {
            "Text": "Person",
            "AttrFlags": 2
          },
          {
            "Text": " instances share the same string data. Each time a copy is performed, the shared reference count is incremented. The destructor then decrements the reference count, only releasing the memory if the count is zero."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522318494,
        "id": "3c4b08d3-5f7d-42b0-86c6-626a2e1c29c3",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522318494,
        "parent_id": "68ade8cc-9bf3-4f50-953d-cf6e72a075d4",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Or we could implement "
            ],
            [
              "value semantics and deep copying behavior",
              [
                [
                  "a",
                  "http://stackoverflow.com/documentation/c%2B%2B/1955/value-and-reference-semantics#t=201607230312543894418"
                ]
              ]
            ],
            [
              ":"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Or we could implement "
          },
          {
            "Text": "value semantics and deep copying behavior",
            "Link": "http://stackoverflow.com/documentation/c%2B%2B/1955/value-and-reference-semantics#t=201607230312543894418"
          },
          {
            "Text": ":"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522318494,
        "id": "f63556b2-ec42-4635-a448-a0b01283d2d9",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522318494,
        "parent_id": "68ade8cc-9bf3-4f50-953d-cf6e72a075d4",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "Person(Person const\u0026 other)\n    : name(new char[std::strlen(other.name) + 1])\n    , age(other.age)\n{\n    std::strcpy(name, other.name);\n}\n\nPerson \u0026operator=(Person const\u0026 other) \n{\n    // Use copy and swap idiom to implement assignment\n    Person copy(other);\n    swap(copy);            //  assume swap() exchanges contents of *this and copy\n    return *this;\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "Person(Person const\u0026 other)\n    : name(new char[std::strlen(other.name) + 1])\n    , age(other.age)\n{\n    std::strcpy(name, other.name);\n}\n\nPerson \u0026operator=(Person const\u0026 other) \n{\n    // Use copy and swap idiom to implement assignment\n    Person copy(other);\n    swap(copy);            //  assume swap() exchanges contents of *this and copy\n    return *this;\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522318495,
        "id": "3ad870ef-4509-44db-bdcc-348661766351",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522318495,
        "parent_id": "68ade8cc-9bf3-4f50-953d-cf6e72a075d4",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Implementation of the copy assignment operator is complicated by the need to release an existing buffer. The copy and swap technique creates a temporary object which holds a new buffer. Swapping the contents of "
            ],
            [
              "*this",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "copy",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " gives ownership to "
            ],
            [
              "copy",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " of the original buffer. Destruction of "
            ],
            [
              "copy",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ", as the function returns, releases the buffer previously owned by "
            ],
            [
              "*this",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Implementation of the copy assignment operator is complicated by the need to release an existing buffer. The copy and swap technique creates a temporary object which holds a new buffer. Swapping the contents of "
          },
          {
            "Text": "*this",
            "AttrFlags": 2
          },
          {
            "Text": " and "
          },
          {
            "Text": "copy",
            "AttrFlags": 2
          },
          {
            "Text": " gives ownership to "
          },
          {
            "Text": "copy",
            "AttrFlags": 2
          },
          {
            "Text": " of the original buffer. Destruction of "
          },
          {
            "Text": "copy",
            "AttrFlags": 2
          },
          {
            "Text": ", as the function returns, releases the buffer previously owned by "
          },
          {
            "Text": "*this",
            "AttrFlags": 2
          },
          {
            "Text": "."
          }
        ]
      }
    ],
    "title": "Rule of Three",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 19
    }
  ],
  "Tables": null
}