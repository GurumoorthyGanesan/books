{
  "ID": "9fe055fc-ec91-4260-b1b7-c33c00b4c06a",
  "Root": {
    "alive": true,
    "content": [
      "8cc5c5c6-905e-4ef6-a081-b10255e69818",
      "ddca746c-e32a-46cc-8a94-772a42c155fa",
      "17f07d0f-ae1f-4401-adfa-231b40e4c5b0",
      "3926f9ee-6828-4d7c-aa66-f440f2024904"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1550524322497,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "9fe055fc-ec91-4260-b1b7-c33c00b4c06a",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1551688497090,
    "parent_id": "48c65d67-f77e-4b0b-b90a-83ab75bd68a9",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Hello TCP Client"
        ]
      ]
    },
    "type": "page",
    "version": 4,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550524322496,
        "id": "8cc5c5c6-905e-4ef6-a081-b10255e69818",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550524322496,
        "parent_id": "9fe055fc-ec91-4260-b1b7-c33c00b4c06a",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "This program is complimentary to Hello TCP Server program, you can run either of them to check the validity of each other. The program flow is quite common with Hello TCP server, so make sure to take a look at that too."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "This program is complimentary to Hello TCP Server program, you can run either of them to check the validity of each other. The program flow is quite common with Hello TCP server, so make sure to take a look at that too."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550524322496,
        "id": "ddca746c-e32a-46cc-8a94-772a42c155fa",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550524322496,
        "parent_id": "9fe055fc-ec91-4260-b1b7-c33c00b4c06a",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Here’s the code -"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Here’s the code -"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550524322496,
        "id": "17f07d0f-ae1f-4401-adfa-231b40e4c5b0",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550524322496,
        "parent_id": "9fe055fc-ec91-4260-b1b7-c33c00b4c06a",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "#include \u003ccstring\u003e\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\n#include \u003carpa/inet.h\u003e\n#include \u003cnetdb.h\u003e\n#include \u003csys/socket.h\u003e\n#include \u003csys/types.h\u003e\n#include \u003cunistd.h\u003e\n\n\nint main(int argc, char *argv[])\n{\n    // Now we're taking an ipaddress and a port number as arguments to our program\n    if (argc != 3) {\n        std::cerr \u003c\u003c \"Run program as 'program \u003cipaddress\u003e \u003cport\u003e'\\n\";\n        return -1;\n    }"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "#include \u003ccstring\u003e\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n\n#include \u003carpa/inet.h\u003e\n#include \u003cnetdb.h\u003e\n#include \u003csys/socket.h\u003e\n#include \u003csys/types.h\u003e\n#include \u003cunistd.h\u003e\n\n\nint main(int argc, char *argv[])\n{\n    // Now we're taking an ipaddress and a port number as arguments to our program\n    if (argc != 3) {\n        std::cerr \u003c\u003c \"Run program as 'program \u003cipaddress\u003e \u003cport\u003e'\\n\";\n        return -1;\n    }",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550524322497,
        "id": "3926f9ee-6828-4d7c-aa66-f440f2024904",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550524322497,
        "parent_id": "9fe055fc-ec91-4260-b1b7-c33c00b4c06a",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "auto \u0026ipAddress = argv[1];\nauto \u0026portNum   = argv[2];\n\naddrinfo hints, *p;\nmemset(\u0026hints, 0, sizeof(hints));\nhints.ai_family   = AF_UNSPEC;\nhints.ai_socktype = SOCK_STREAM;\nhints.ai_flags    = AI_PASSIVE;\n\nint gAddRes = getaddrinfo(ipAddress, portNum, \u0026hints, \u0026p);\nif (gAddRes != 0) {\n    std::cerr \u003c\u003c gai_strerror(gAddRes) \u003c\u003c \"\\n\";\n    return -2;\n}\n\nif (p == NULL) {\n    std::cerr \u003c\u003c \"No addresses found\\n\";\n    return -3;\n}\n\n// socket() call creates a new socket and returns it's descriptor\nint sockFD = socket(p-\u003eai_family, p-\u003eai_socktype, p-\u003eai_protocol);\nif (sockFD == -1) {\n    std::cerr \u003c\u003c \"Error while creating socket\\n\";\n    return -4;\n}\n\n// Note: there is no bind() call as there was in Hello TCP Server\n// why? well you could call it though it's not necessary\n// because client doesn't necessarily has to have a fixed port number\n// so next call will bind it to a random available port number\n\n// connect() call tries to establish a TCP connection to the specified server\nint connectR = connect(sockFD, p-\u003eai_addr, p-\u003eai_addrlen);\nif (connectR == -1) {\n    close(sockFD);\n    std::cerr \u003c\u003c \"Error while connecting socket\\n\";\n    return -5;\n}\n\nstd::string reply(15, ' ');\n\n// recv() call tries to get the response from server\n// BUT there's a catch here, the response might take multiple calls\n// to recv() before it is completely received\n// will be demonstrated in another example to keep this minimal\nauto bytes_recv = recv(sockFD, \u0026reply.front(), reply.size(), 0);\nif (bytes_recv == -1) {\n    std::cerr \u003c\u003c \"Error while receiving bytes\\n\";\n    return -6;\n}\n\nstd::cout \u003c\u003c \"\\nClient recieved: \" \u003c\u003c reply \u003c\u003c std::endl;\nclose(sockFD);\nfreeaddrinfo(p);\n\nreturn 0;\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "auto \u0026ipAddress = argv[1];\nauto \u0026portNum   = argv[2];\n\naddrinfo hints, *p;\nmemset(\u0026hints, 0, sizeof(hints));\nhints.ai_family   = AF_UNSPEC;\nhints.ai_socktype = SOCK_STREAM;\nhints.ai_flags    = AI_PASSIVE;\n\nint gAddRes = getaddrinfo(ipAddress, portNum, \u0026hints, \u0026p);\nif (gAddRes != 0) {\n    std::cerr \u003c\u003c gai_strerror(gAddRes) \u003c\u003c \"\\n\";\n    return -2;\n}\n\nif (p == NULL) {\n    std::cerr \u003c\u003c \"No addresses found\\n\";\n    return -3;\n}\n\n// socket() call creates a new socket and returns it's descriptor\nint sockFD = socket(p-\u003eai_family, p-\u003eai_socktype, p-\u003eai_protocol);\nif (sockFD == -1) {\n    std::cerr \u003c\u003c \"Error while creating socket\\n\";\n    return -4;\n}\n\n// Note: there is no bind() call as there was in Hello TCP Server\n// why? well you could call it though it's not necessary\n// because client doesn't necessarily has to have a fixed port number\n// so next call will bind it to a random available port number\n\n// connect() call tries to establish a TCP connection to the specified server\nint connectR = connect(sockFD, p-\u003eai_addr, p-\u003eai_addrlen);\nif (connectR == -1) {\n    close(sockFD);\n    std::cerr \u003c\u003c \"Error while connecting socket\\n\";\n    return -5;\n}\n\nstd::string reply(15, ' ');\n\n// recv() call tries to get the response from server\n// BUT there's a catch here, the response might take multiple calls\n// to recv() before it is completely received\n// will be demonstrated in another example to keep this minimal\nauto bytes_recv = recv(sockFD, \u0026reply.front(), reply.size(), 0);\nif (bytes_recv == -1) {\n    std::cerr \u003c\u003c \"Error while receiving bytes\\n\";\n    return -6;\n}\n\nstd::cout \u003c\u003c \"\\nClient recieved: \" \u003c\u003c reply \u003c\u003c std::endl;\nclose(sockFD);\nfreeaddrinfo(p);\n\nreturn 0;\n}",
        "code_language": "Plain Text"
      }
    ],
    "title": "Hello TCP Client",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 19
    }
  ],
  "Tables": null
}