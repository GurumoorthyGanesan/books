{
  "ID": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
  "Root": {
    "alive": true,
    "content": [
      "7c2928db-6f8b-4ad0-8fc6-67fe47a85143",
      "d926eb8c-42ff-4c4b-a941-7033e14fde67",
      "fed99451-dace-472c-b00e-db7a5776ad04",
      "731a534f-ec35-4e60-82fd-c0f8fe382a82",
      "cdc8b55c-98bf-4109-95d2-d05dd3f4a685",
      "a872522d-3780-4236-806c-54a3b8761651",
      "2199f4da-4492-405f-a0b4-d854dcb3e28c",
      "f609568e-5304-4d05-9950-fd294bc24d5b",
      "5b75047b-7378-49c8-9cb0-bef3e955d06e",
      "00c897f9-7d47-4942-b862-1c932f92d54a",
      "f2b9f96a-4e90-4744-b3b8-31f2677dc42e",
      "9aac6f7d-1210-484c-9a9f-4cf491f07c32",
      "90545341-6ddb-4ec4-b04c-f00c41a265fd",
      "59946784-7463-444b-a5c5-e2e5ef5b1183",
      "e32076b0-a03f-46e0-b16d-77cb7adf92c0",
      "9ff23b73-bf7e-4c67-ab2a-88002e95d24c",
      "c558cc79-6008-4886-9fe5-c42508611d81",
      "f5f5e214-0b36-47e1-916b-88922b2a1496",
      "d20d9306-8d44-4145-9b04-78ea3c692ec1",
      "4abee05e-82f6-4475-89db-847da911cccc",
      "e81df8e4-e932-4781-bff1-b83237772f04",
      "5e0673fd-80fc-47f5-8359-8807e4ab1cf2",
      "10a9c993-e1fd-4e1b-846b-268a5e221eae",
      "e78a6207-6035-49c9-a5ea-a06148763944",
      "0df448d5-38ba-4063-8e5b-a5f21451e907"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1550522024616,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1550801640000,
    "parent_id": "40e8450d-4736-4ad0-be7d-a2d9307ddf4f",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Nested classes / structures"
        ]
      ]
    },
    "type": "page",
    "version": 26,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024612,
        "id": "7c2928db-6f8b-4ad0-8fc6-67fe47a85143",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522024612,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "A "
            ],
            [
              "class",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " or "
            ],
            [
              "struct",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " can also contain another "
            ],
            [
              "class",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "/"
            ],
            [
              "struct",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " definition inside itself, which is called a “nested class”; in this situation, the containing class is referred to as the “enclosing class”. The nested class definition is considered to be a member of the enclosing class, but is otherwise separate."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "A "
          },
          {
            "Text": "class",
            "AttrFlags": 2
          },
          {
            "Text": " or "
          },
          {
            "Text": "struct",
            "AttrFlags": 2
          },
          {
            "Text": " can also contain another "
          },
          {
            "Text": "class",
            "AttrFlags": 2
          },
          {
            "Text": "/"
          },
          {
            "Text": "struct",
            "AttrFlags": 2
          },
          {
            "Text": " definition inside itself, which is called a “nested class”; in this situation, the containing class is referred to as the “enclosing class”. The nested class definition is considered to be a member of the enclosing class, but is otherwise separate."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024613,
        "id": "d926eb8c-42ff-4c4b-a941-7033e14fde67",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550801580000,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "C++"
            ]
          ],
          "title": [
            [
              "struct Outer {\n    struct Inner { };\n};"
            ]
          ]
        },
        "type": "code",
        "version": 3,
        "code": "struct Outer {\n    struct Inner { };\n};",
        "code_language": "C++"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024613,
        "id": "fed99451-dace-472c-b00e-db7a5776ad04",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522024613,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "From outside of the enclosing class, nested classes are accessed using the scope operator. From inside the enclosing class, however, nested classes can be used without qualifiers:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "From outside of the enclosing class, nested classes are accessed using the scope operator. From inside the enclosing class, however, nested classes can be used without qualifiers:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024613,
        "id": "731a534f-ec35-4e60-82fd-c0f8fe382a82",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550801580000,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "C++"
            ]
          ],
          "title": [
            [
              "struct Outer {\n    struct Inner { };\n\n    Inner in;\n};\n\n// ...\n\nOuter o;\nOuter::Inner i = o.in;"
            ]
          ]
        },
        "type": "code",
        "version": 3,
        "code": "struct Outer {\n    struct Inner { };\n\n    Inner in;\n};\n\n// ...\n\nOuter o;\nOuter::Inner i = o.in;",
        "code_language": "C++"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024613,
        "id": "cdc8b55c-98bf-4109-95d2-d05dd3f4a685",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522024613,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "As with a non-nested "
            ],
            [
              "class",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "/"
            ],
            [
              "struct",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ", member functions and static variables can be defined either within a nested class, or in the enclosing namespace. However, they cannot be defined within the enclosing class, due to it being considered to be a different class than the nested class."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "As with a non-nested "
          },
          {
            "Text": "class",
            "AttrFlags": 2
          },
          {
            "Text": "/"
          },
          {
            "Text": "struct",
            "AttrFlags": 2
          },
          {
            "Text": ", member functions and static variables can be defined either within a nested class, or in the enclosing namespace. However, they cannot be defined within the enclosing class, due to it being considered to be a different class than the nested class."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024613,
        "id": "a872522d-3780-4236-806c-54a3b8761651",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550801580000,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "C++"
            ]
          ],
          "title": [
            [
              "// Bad.\nstruct Outer {\n    struct Inner {\n        void do_something();\n    };\n\n    void Inner::do_something() {}\n};\n\n\n// Good.\nstruct Outer {\n    struct Inner {\n        void do_something();\n    };\n\n};\n\nvoid Outer::Inner::do_something() {}"
            ]
          ]
        },
        "type": "code",
        "version": 3,
        "code": "// Bad.\nstruct Outer {\n    struct Inner {\n        void do_something();\n    };\n\n    void Inner::do_something() {}\n};\n\n\n// Good.\nstruct Outer {\n    struct Inner {\n        void do_something();\n    };\n\n};\n\nvoid Outer::Inner::do_something() {}",
        "code_language": "C++"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024614,
        "id": "2199f4da-4492-405f-a0b4-d854dcb3e28c",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522024614,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "As with non-nested classes, nested classes can be forward declared and defined later, provided they are defined before being used directly."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "As with non-nested classes, nested classes can be forward declared and defined later, provided they are defined before being used directly."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024614,
        "id": "f609568e-5304-4d05-9950-fd294bc24d5b",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550801580000,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "C++"
            ]
          ],
          "title": [
            [
              "class Outer {\n    class Inner1;\n    class Inner2;\n\n    class Inner1 {};\n\n    Inner1 in1;\n    Inner2* in2p;\n\n  public:\n    Outer();\n    ~Outer();\n};\n\nclass Outer::Inner2 {};\n\nOuter::Outer() : in1(Inner1()), in2p(new Inner2) {}\nOuter::~Outer() {\n    if (in2p) { delete in2p; }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 4,
        "code": "class Outer {\n    class Inner1;\n    class Inner2;\n\n    class Inner1 {};\n\n    Inner1 in1;\n    Inner2* in2p;\n\n  public:\n    Outer();\n    ~Outer();\n};\n\nclass Outer::Inner2 {};\n\nOuter::Outer() : in1(Inner1()), in2p(new Inner2) {}\nOuter::~Outer() {\n    if (in2p) { delete in2p; }\n}",
        "code_language": "C++"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024614,
        "id": "5b75047b-7378-49c8-9cb0-bef3e955d06e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522024614,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Prior to C++11, nested classes only had access to type names, "
            ],
            [
              "static",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " members, and enumerators from the enclosing class; all other members defined in the enclosing class were off-limits."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Prior to C++11, nested classes only had access to type names, "
          },
          {
            "Text": "static",
            "AttrFlags": 2
          },
          {
            "Text": " members, and enumerators from the enclosing class; all other members defined in the enclosing class were off-limits."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024614,
        "id": "00c897f9-7d47-4942-b862-1c932f92d54a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522024614,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "As of C++11, nested classes, and members thereof, are treated as if they were "
            ],
            [
              "friend",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "s of the enclosing class, and can access all of its members, according to the usual access rules; if members of the nested class require the ability to evaluate one or more non-static members of the enclosing class, they must therefore be passed an instance:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "As of C++11, nested classes, and members thereof, are treated as if they were "
          },
          {
            "Text": "friend",
            "AttrFlags": 2
          },
          {
            "Text": "s of the enclosing class, and can access all of its members, according to the usual access rules; if members of the nested class require the ability to evaluate one or more non-static members of the enclosing class, they must therefore be passed an instance:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024614,
        "id": "f2b9f96a-4e90-4744-b3b8-31f2677dc42e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550801580000,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "C++"
            ]
          ],
          "title": [
            [
              "class Outer {\n    struct Inner {\n        int get_sizeof_x() {\n            return sizeof(x); // Legal (C++11): x is unevaluated, so no instance is required.\n        }\n\n        int get_x() {\n            return x; // Illegal: Can't access non-static member without an instance.\n        }\n\n        int get_x(Outer\u0026 o) {\n            return o.x; // Legal (C++11): As a member of Outer, Inner can access private members.\n        }\n    };\n\n    int x;\n};"
            ]
          ]
        },
        "type": "code",
        "version": 3,
        "code": "class Outer {\n    struct Inner {\n        int get_sizeof_x() {\n            return sizeof(x); // Legal (C++11): x is unevaluated, so no instance is required.\n        }\n\n        int get_x() {\n            return x; // Illegal: Can't access non-static member without an instance.\n        }\n\n        int get_x(Outer\u0026 o) {\n            return o.x; // Legal (C++11): As a member of Outer, Inner can access private members.\n        }\n    };\n\n    int x;\n};",
        "code_language": "C++"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024614,
        "id": "9aac6f7d-1210-484c-9a9f-4cf491f07c32",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522024614,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Conversely, the enclosing class is "
            ],
            [
              "not",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " treated as a friend of the nested class, and thus cannot access its private members without explicitly being granted permission."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Conversely, the enclosing class is "
          },
          {
            "Text": "not",
            "AttrFlags": 4
          },
          {
            "Text": " treated as a friend of the nested class, and thus cannot access its private members without explicitly being granted permission."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024615,
        "id": "90545341-6ddb-4ec4-b04c-f00c41a265fd",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550801580000,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "C++"
            ]
          ],
          "title": [
            [
              "class Outer {\n    class Inner {\n        // friend class Outer;\n\n        int x;\n    };\n\n    Inner in;\n\n  public:\n    int get_x() {\n        return in.x; // Error: int Outer::Inner::x is private.\n        // Uncomment \"friend\" line above to fix.\n    }\n};"
            ]
          ]
        },
        "type": "code",
        "version": 3,
        "code": "class Outer {\n    class Inner {\n        // friend class Outer;\n\n        int x;\n    };\n\n    Inner in;\n\n  public:\n    int get_x() {\n        return in.x; // Error: int Outer::Inner::x is private.\n        // Uncomment \"friend\" line above to fix.\n    }\n};",
        "code_language": "C++"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024615,
        "id": "59946784-7463-444b-a5c5-e2e5ef5b1183",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522024615,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Friends of a nested class are not automatically considered friends of the enclosing class; if they need to be friends of the enclosing class as well, this must be declared separately. Conversely, as the enclosing class is not automatically considered a friend of the nested class, neither will friends of the enclosing class be considered friends of the nested class."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Friends of a nested class are not automatically considered friends of the enclosing class; if they need to be friends of the enclosing class as well, this must be declared separately. Conversely, as the enclosing class is not automatically considered a friend of the nested class, neither will friends of the enclosing class be considered friends of the nested class."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024615,
        "id": "e32076b0-a03f-46e0-b16d-77cb7adf92c0",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550801580000,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "C++"
            ]
          ],
          "title": [
            [
              "class Outer {\n    friend void barge_out(Outer\u0026 out, Inner\u0026 in);\n\n    class Inner {\n        friend void barge_in(Outer\u0026 out, Inner\u0026 in);\n\n        int i;\n    };\n\n    int o;\n};\n\nvoid barge_in(Outer\u0026 out, Outer::Inner\u0026 in) {\n    int i = in.i;  // Good.\n    int o = out.o; // Error: int Outer::o is private.\n}\n\nvoid barge_out(Outer\u0026 out, Outer::Inner\u0026 in) {\n    int i = in.i;  // Error: int Outer::Inner::i is private.\n    int o = out.o; // Good.\n}"
            ]
          ]
        },
        "type": "code",
        "version": 3,
        "code": "class Outer {\n    friend void barge_out(Outer\u0026 out, Inner\u0026 in);\n\n    class Inner {\n        friend void barge_in(Outer\u0026 out, Inner\u0026 in);\n\n        int i;\n    };\n\n    int o;\n};\n\nvoid barge_in(Outer\u0026 out, Outer::Inner\u0026 in) {\n    int i = in.i;  // Good.\n    int o = out.o; // Error: int Outer::o is private.\n}\n\nvoid barge_out(Outer\u0026 out, Outer::Inner\u0026 in) {\n    int i = in.i;  // Error: int Outer::Inner::i is private.\n    int o = out.o; // Good.\n}",
        "code_language": "C++"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024615,
        "id": "9ff23b73-bf7e-4c67-ab2a-88002e95d24c",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550801580000,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "type": "text",
        "version": 3
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024615,
        "id": "c558cc79-6008-4886-9fe5-c42508611d81",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522024615,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "As with all other class members, nested classes can only be named from outside the class if they have public access. However, you are allowed to access them regardless of access modifier, as long as you don’t explicitly name them."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "As with all other class members, nested classes can only be named from outside the class if they have public access. However, you are allowed to access them regardless of access modifier, as long as you don’t explicitly name them."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024615,
        "id": "f5f5e214-0b36-47e1-916b-88922b2a1496",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550801580000,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "C++"
            ]
          ],
          "title": [
            [
              "class Outer {\n    struct Inner {\n        void func() { std::cout \u003c\u003c \"I have no private taboo.\\n\"; }\n    };\n\n  public:\n    static Inner make_Inner() { return Inner(); }\n};\n\n// ...\n\nOuter::Inner oi; // Error: Outer::Inner is private.\n\nauto oi = Outer::make_Inner(); // Good.\noi.func();                     // Good.\nOuter::make_Inner().func();    // Good."
            ]
          ]
        },
        "type": "code",
        "version": 3,
        "code": "class Outer {\n    struct Inner {\n        void func() { std::cout \u003c\u003c \"I have no private taboo.\\n\"; }\n    };\n\n  public:\n    static Inner make_Inner() { return Inner(); }\n};\n\n// ...\n\nOuter::Inner oi; // Error: Outer::Inner is private.\n\nauto oi = Outer::make_Inner(); // Good.\noi.func();                     // Good.\nOuter::make_Inner().func();    // Good.",
        "code_language": "C++"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024615,
        "id": "d20d9306-8d44-4145-9b04-78ea3c692ec1",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522024615,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "You can also create a type alias for a nested class. If a type alias is contained in the enclosing class, the nested type and the type alias can have different access modifiers. If the type alias is outside the enclosing class, it requires that either the nested class, or a "
            ],
            [
              "typedef",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " thereof, be public."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "You can also create a type alias for a nested class. If a type alias is contained in the enclosing class, the nested type and the type alias can have different access modifiers. If the type alias is outside the enclosing class, it requires that either the nested class, or a "
          },
          {
            "Text": "typedef",
            "AttrFlags": 2
          },
          {
            "Text": " thereof, be public."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024615,
        "id": "4abee05e-82f6-4475-89db-847da911cccc",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550801640000,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "C++"
            ]
          ],
          "title": [
            [
              "class Outer {\n    class Inner_ {};\n\n  public:\n    typedef Inner_ Inner;\n};\n\ntypedef Outer::Inner  ImOut; // Good.\ntypedef Outer::Inner_ ImBad; // Error.\n\n// ...\n\nOuter::Inner  oi; // Good.\nOuter::Inner_ oi; // Error.\nImOut         oi; // Good."
            ]
          ]
        },
        "type": "code",
        "version": 3,
        "code": "class Outer {\n    class Inner_ {};\n\n  public:\n    typedef Inner_ Inner;\n};\n\ntypedef Outer::Inner  ImOut; // Good.\ntypedef Outer::Inner_ ImBad; // Error.\n\n// ...\n\nOuter::Inner  oi; // Good.\nOuter::Inner_ oi; // Error.\nImOut         oi; // Good.",
        "code_language": "C++"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024615,
        "id": "e81df8e4-e932-4781-bff1-b83237772f04",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522024615,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "As with other classes, nested classes can both derive from or be derived from by other classes."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "As with other classes, nested classes can both derive from or be derived from by other classes."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024616,
        "id": "5e0673fd-80fc-47f5-8359-8807e4ab1cf2",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550801640000,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "C++"
            ]
          ],
          "title": [
            [
              "struct Base {};\n\nstruct Outer {\n    struct Inner : Base {};\n};\n\nstruct Derived : Outer::Inner {};"
            ]
          ]
        },
        "type": "code",
        "version": 3,
        "code": "struct Base {};\n\nstruct Outer {\n    struct Inner : Base {};\n};\n\nstruct Derived : Outer::Inner {};",
        "code_language": "C++"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024616,
        "id": "10a9c993-e1fd-4e1b-846b-268a5e221eae",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522024616,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "This can be useful in situations where the enclosing class is derived from by another class, by allowing the programmer to update the nested class as necessary. This can be combined with a typedef to provide a consistent name for each enclosing class’ nested class:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "This can be useful in situations where the enclosing class is derived from by another class, by allowing the programmer to update the nested class as necessary. This can be combined with a typedef to provide a consistent name for each enclosing class’ nested class:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024616,
        "id": "e78a6207-6035-49c9-a5ea-a06148763944",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550801640000,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "C++"
            ]
          ],
          "title": [
            [
              "class BaseOuter {\n    struct BaseInner_ {\n        virtual void do_something() {}\n        virtual void do_something_else();\n    } b_in;\n\n  public:\n    typedef BaseInner_ Inner;\n\n    virtual ~BaseOuter() = default;\n\n    virtual Inner\u0026 getInner() { return b_in; }\n};\n\nvoid BaseOuter::BaseInner_::do_something_else() {}\n\n// ---\n\nclass DerivedOuter : public BaseOuter {\n    // Note the use of the qualified typedef; BaseOuter::BaseInner_ is private.\n    struct DerivedInner_ : BaseOuter::Inner {\n        void do_something() override {}\n        void do_something_else() override;\n    } d_in;\n\n  public:\n    typedef DerivedInner_ Inner;\n\n    BaseOuter::Inner\u0026 getInner() override { return d_in; }\n};\n\nvoid DerivedOuter::DerivedInner_::do_something_else() {}\n\n// ...\n\n// Calls BaseOuter::BaseInner_::do_something();\nBaseOuter* b = new BaseOuter;\nBaseOuter::Inner\u0026 bin = b-\u003egetInner();\nbin.do_something();\nb-\u003egetInner().do_something();\n\n// Calls DerivedOuter::DerivedInner_::do_something();\nBaseOuter* d = new DerivedOuter;\nBaseOuter::Inner\u0026 din = d-\u003egetInner();\ndin.do_something();\nd-\u003egetInner().do_something();"
            ]
          ]
        },
        "type": "code",
        "version": 4,
        "code": "class BaseOuter {\n    struct BaseInner_ {\n        virtual void do_something() {}\n        virtual void do_something_else();\n    } b_in;\n\n  public:\n    typedef BaseInner_ Inner;\n\n    virtual ~BaseOuter() = default;\n\n    virtual Inner\u0026 getInner() { return b_in; }\n};\n\nvoid BaseOuter::BaseInner_::do_something_else() {}\n\n// ---\n\nclass DerivedOuter : public BaseOuter {\n    // Note the use of the qualified typedef; BaseOuter::BaseInner_ is private.\n    struct DerivedInner_ : BaseOuter::Inner {\n        void do_something() override {}\n        void do_something_else() override;\n    } d_in;\n\n  public:\n    typedef DerivedInner_ Inner;\n\n    BaseOuter::Inner\u0026 getInner() override { return d_in; }\n};\n\nvoid DerivedOuter::DerivedInner_::do_something_else() {}\n\n// ...\n\n// Calls BaseOuter::BaseInner_::do_something();\nBaseOuter* b = new BaseOuter;\nBaseOuter::Inner\u0026 bin = b-\u003egetInner();\nbin.do_something();\nb-\u003egetInner().do_something();\n\n// Calls DerivedOuter::DerivedInner_::do_something();\nBaseOuter* d = new DerivedOuter;\nBaseOuter::Inner\u0026 din = d-\u003egetInner();\ndin.do_something();\nd-\u003egetInner().do_something();",
        "code_language": "C++"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550522024616,
        "id": "0df448d5-38ba-4063-8e5b-a5f21451e907",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550522024616,
        "parent_id": "3c435ce8-fbda-4ca2-8d24-5f24d0fe7b42",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "In the above case, both "
            ],
            [
              "BaseOuter",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "DerivedOuter",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " supply the member type "
            ],
            [
              "Inner",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ", as "
            ],
            [
              "BaseInner_",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "DerivedInner_",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ", respectively. This allows nested types to be derived without breaking the enclosing class’ interface, and allows the nested type to be used polymorphically."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "In the above case, both "
          },
          {
            "Text": "BaseOuter",
            "AttrFlags": 2
          },
          {
            "Text": " and "
          },
          {
            "Text": "DerivedOuter",
            "AttrFlags": 2
          },
          {
            "Text": " supply the member type "
          },
          {
            "Text": "Inner",
            "AttrFlags": 2
          },
          {
            "Text": ", as "
          },
          {
            "Text": "BaseInner_",
            "AttrFlags": 2
          },
          {
            "Text": " and "
          },
          {
            "Text": "DerivedInner_",
            "AttrFlags": 2
          },
          {
            "Text": ", respectively. This allows nested types to be derived without breaking the enclosing class’ interface, and allows the nested type to be used polymorphically."
          }
        ]
      }
    ],
    "title": "Nested classes / structures",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}