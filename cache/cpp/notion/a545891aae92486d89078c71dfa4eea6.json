{
  "ID": "a545891a-ae92-486d-8907-8c71dfa4eea6",
  "Root": {
    "alive": true,
    "content": [
      "04ed8226-c5cb-4095-a475-d22460517c59",
      "08d15476-ef11-4c5c-8a49-b2da966e5645",
      "2c9de5f3-eb9c-4d16-a2d0-cd8323682a48",
      "a2b5e704-d41c-4249-9b9a-b02b5c94cadf",
      "d185468e-4096-4b0f-9309-2784aa0989db",
      "b949498c-1085-4b54-9648-8a67a286e340",
      "b239223e-5a74-4861-a5ed-d46ec57280ba",
      "d3e2bbab-33de-4bfe-8684-d60071e4bcec"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1550523073869,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "a545891a-ae92-486d-8907-8c71dfa4eea6",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1552297080000,
    "parent_id": "3724ad56-a879-48bf-847e-5adcfcb60c18",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Dynamic size matrix using std::vector for storage"
        ]
      ]
    },
    "type": "page",
    "version": 21,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523073865,
        "id": "04ed8226-c5cb-4095-a475-d22460517c59",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550523073865,
        "parent_id": "a545891a-ae92-486d-8907-8c71dfa4eea6",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Unfortunately as of C++14 there’s no dynamic size matrix class in the C++ standard library. Matrix classes that support dynamic size are however available from a number of 3rd party libraries, including the Boost Matrix library (a sub-library within the Boost library)."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Unfortunately as of C++14 there’s no dynamic size matrix class in the C++ standard library. Matrix classes that support dynamic size are however available from a number of 3rd party libraries, including the Boost Matrix library (a sub-library within the Boost library)."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523073868,
        "id": "08d15476-ef11-4c5c-8a49-b2da966e5645",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550523073868,
        "parent_id": "a545891a-ae92-486d-8907-8c71dfa4eea6",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "If you don’t want a dependency on Boost or some other library, then one poor man’s dynamic size matrix in C++ is just like"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "If you don’t want a dependency on Boost or some other library, then one poor man’s dynamic size matrix in C++ is just like"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523073868,
        "id": "2c9de5f3-eb9c-4d16-a2d0-cd8323682a48",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550778600000,
        "parent_id": "a545891a-ae92-486d-8907-8c71dfa4eea6",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "C++"
            ]
          ],
          "title": [
            [
              "vector\u003cvector\u003cint\u003e\u003e m( 3, vector\u003cint\u003e( 7 ) );"
            ]
          ]
        },
        "type": "code",
        "version": 3,
        "code": "vector\u003cvector\u003cint\u003e\u003e m( 3, vector\u003cint\u003e( 7 ) );",
        "code_language": "C++"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523073868,
        "id": "a2b5e704-d41c-4249-9b9a-b02b5c94cadf",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550523073868,
        "parent_id": "a545891a-ae92-486d-8907-8c71dfa4eea6",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "… where "
            ],
            [
              "vector",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " is "
            ],
            [
              "std::vector",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ". The matrix is here created by copying a row vector "
            ],
            [
              "n",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " times where "
            ],
            [
              "n",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " is the number of rows, here 3. It has the advantage of providing the same "
            ],
            [
              "m[y]",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " indexing notation as for a fixed size raw array matrix, but it’s a bit inefficient because it involves a dynamic allocation for each row, and it’s a bit unsafe because it’s possible to inadvertently resize a row."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "… where "
          },
          {
            "Text": "vector",
            "AttrFlags": 2
          },
          {
            "Text": " is "
          },
          {
            "Text": "std::vector",
            "AttrFlags": 2
          },
          {
            "Text": ". The matrix is here created by copying a row vector "
          },
          {
            "Text": "n",
            "AttrFlags": 4
          },
          {
            "Text": " times where "
          },
          {
            "Text": "n",
            "AttrFlags": 4
          },
          {
            "Text": " is the number of rows, here 3. It has the advantage of providing the same "
          },
          {
            "Text": "m[y]",
            "AttrFlags": 2
          },
          {
            "Text": " indexing notation as for a fixed size raw array matrix, but it’s a bit inefficient because it involves a dynamic allocation for each row, and it’s a bit unsafe because it’s possible to inadvertently resize a row."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523073868,
        "id": "d185468e-4096-4b0f-9309-2784aa0989db",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550523073868,
        "parent_id": "a545891a-ae92-486d-8907-8c71dfa4eea6",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "A more safe and efficient approach is to use a single vector as "
            ],
            [
              "storage",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " for the matrix, and map the client code’s ("
            ],
            [
              "x",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "y",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ") to a corresponding index in that vector:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "A more safe and efficient approach is to use a single vector as "
          },
          {
            "Text": "storage",
            "AttrFlags": 4
          },
          {
            "Text": " for the matrix, and map the client code’s ("
          },
          {
            "Text": "x",
            "AttrFlags": 4
          },
          {
            "Text": ", "
          },
          {
            "Text": "y",
            "AttrFlags": 4
          },
          {
            "Text": ") to a corresponding index in that vector:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523073869,
        "id": "b949498c-1085-4b54-9648-8a67a286e340",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1552297080000,
        "parent_id": "a545891a-ae92-486d-8907-8c71dfa4eea6",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "C++"
            ]
          ],
          "title": [
            [
              "// :glot\n#include \u003calgorithm\u003e        // std::copy\n#include \u003ccassert\u003e          // assert\n#include \u003cinitializer_list\u003e // std::initializer_list\n#include \u003cvector\u003e           // std::vector\n#include \u003ccstddef\u003e          // ptrdiff_t\n\n// A dynamic size matrix using std::vector for storage.\n\nnamespace my {\n    using Size = ptrdiff_t;\n    using std::initializer_list;\n    using std::vector;\n\n    template\u003c class Item \u003e\n    class Matrix\n    {\n    private:\n        vector\u003cItem\u003e    items_;\n        Size            n_cols_;\n        \n        auto index_for( Size const x, Size const y ) const\n            -\u003e Size\n        { return y*n_cols_ + x; }\n\n    public:\n        auto n_rows() const -\u003e Size { return items_.size()/n_cols_; }\n        auto n_cols() const -\u003e Size { return n_cols_; }\n\n        auto item( Size const x, Size const y )\n            -\u003e Item\u0026\n        { return items_[index_for(x, y)]; }\n        \n        auto item( Size const x, Size const y ) const\n            -\u003e Item const\u0026\n        { return items_[index_for(x, y)]; }\n\n        Matrix(): n_cols_( 0 ) {}\n\n        Matrix( Size const n_cols, Size const n_rows )\n            : items_( n_cols*n_rows )\n            , n_cols_( n_cols )\n        {}\n        \n        Matrix( initializer_list\u003c initializer_list\u003cItem\u003e \u003e const\u0026 values )\n            : items_()\n            , n_cols_( values.size() == 0? 0 : values.begin()-\u003esize() )\n        {\n            for( auto const\u0026 row : values )\n            {\n                assert( Size( row.size() ) == n_cols_ );\n                items_.insert( items_.end(), row.begin(), row.end() );\n            }\n        }\n    };\n}  // namespace my\n\n//--------------------------------------------- Usage:\nusing my::Matrix;\n\nauto some_matrix()\n    -\u003e Matrix\u003cint\u003e\n{\n    return\n    {\n        {  1,  2,  3,  4,  5,  6,  7 },\n        {  8,  9, 10, 11, 12, 13, 14 },\n        { 15, 16, 17, 18, 19, 20, 21 }\n    };\n}\n\n#include \u003ciostream\u003e\n#include \u003ciomanip\u003e\nusing namespace std;\nauto main() -\u003e int\n{\n    Matrix\u003cint\u003e const m = some_matrix();\n    assert( m.n_cols() == 7 );\n    assert( m.n_rows() == 3 );\n    for( int y = 0, y_end = m.n_rows(); y \u003c y_end; ++y )\n    {\n        for( int x = 0, x_end = m.n_cols(); x \u003c x_end; ++x )\n        {\n            cout \u003c\u003c setw( 4 ) \u003c\u003c m.item( x, y );        // ← Note: not `m[y][x]`!\n        }\n        cout \u003c\u003c '\\n';\n    }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 33,
        "code": "// :glot\n#include \u003calgorithm\u003e        // std::copy\n#include \u003ccassert\u003e          // assert\n#include \u003cinitializer_list\u003e // std::initializer_list\n#include \u003cvector\u003e           // std::vector\n#include \u003ccstddef\u003e          // ptrdiff_t\n\n// A dynamic size matrix using std::vector for storage.\n\nnamespace my {\n    using Size = ptrdiff_t;\n    using std::initializer_list;\n    using std::vector;\n\n    template\u003c class Item \u003e\n    class Matrix\n    {\n    private:\n        vector\u003cItem\u003e    items_;\n        Size            n_cols_;\n        \n        auto index_for( Size const x, Size const y ) const\n            -\u003e Size\n        { return y*n_cols_ + x; }\n\n    public:\n        auto n_rows() const -\u003e Size { return items_.size()/n_cols_; }\n        auto n_cols() const -\u003e Size { return n_cols_; }\n\n        auto item( Size const x, Size const y )\n            -\u003e Item\u0026\n        { return items_[index_for(x, y)]; }\n        \n        auto item( Size const x, Size const y ) const\n            -\u003e Item const\u0026\n        { return items_[index_for(x, y)]; }\n\n        Matrix(): n_cols_( 0 ) {}\n\n        Matrix( Size const n_cols, Size const n_rows )\n            : items_( n_cols*n_rows )\n            , n_cols_( n_cols )\n        {}\n        \n        Matrix( initializer_list\u003c initializer_list\u003cItem\u003e \u003e const\u0026 values )\n            : items_()\n            , n_cols_( values.size() == 0? 0 : values.begin()-\u003esize() )\n        {\n            for( auto const\u0026 row : values )\n            {\n                assert( Size( row.size() ) == n_cols_ );\n                items_.insert( items_.end(), row.begin(), row.end() );\n            }\n        }\n    };\n}  // namespace my\n\n//--------------------------------------------- Usage:\nusing my::Matrix;\n\nauto some_matrix()\n    -\u003e Matrix\u003cint\u003e\n{\n    return\n    {\n        {  1,  2,  3,  4,  5,  6,  7 },\n        {  8,  9, 10, 11, 12, 13, 14 },\n        { 15, 16, 17, 18, 19, 20, 21 }\n    };\n}\n\n#include \u003ciostream\u003e\n#include \u003ciomanip\u003e\nusing namespace std;\nauto main() -\u003e int\n{\n    Matrix\u003cint\u003e const m = some_matrix();\n    assert( m.n_cols() == 7 );\n    assert( m.n_rows() == 3 );\n    for( int y = 0, y_end = m.n_rows(); y \u003c y_end; ++y )\n    {\n        for( int x = 0, x_end = m.n_cols(); x \u003c x_end; ++x )\n        {\n            cout \u003c\u003c setw( 4 ) \u003c\u003c m.item( x, y );        // ← Note: not `m[y][x]`!\n        }\n        cout \u003c\u003c '\\n';\n    }\n}",
        "code_language": "C++"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523073869,
        "id": "b239223e-5a74-4861-a5ed-d46ec57280ba",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550523073869,
        "parent_id": "a545891a-ae92-486d-8907-8c71dfa4eea6",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The above code is not industrial grade: it’s designed to show the basic principles, and serve the needs of students learning C++."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The above code is not industrial grade: it’s designed to show the basic principles, and serve the needs of students learning C++."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550523073869,
        "id": "d3e2bbab-33de-4bfe-8684-d60071e4bcec",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550523073869,
        "parent_id": "a545891a-ae92-486d-8907-8c71dfa4eea6",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "For example, one may define "
            ],
            [
              "operator()",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " overloads to simplify the indexing notation."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "For example, one may define "
          },
          {
            "Text": "operator()",
            "AttrFlags": 2
          },
          {
            "Text": " overloads to simplify the indexing notation."
          }
        ]
      }
    ],
    "title": "Dynamic size matrix using std::vector for storage",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 19
    }
  ],
  "Tables": null
}