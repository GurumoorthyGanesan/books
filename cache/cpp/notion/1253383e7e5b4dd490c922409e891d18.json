{
  "ID": "1253383e-7e5b-4dd4-90c9-22409e891d18",
  "Root": {
    "alive": true,
    "content": [
      "fa7814aa-e4e8-4322-9315-2d10e44d5ef8",
      "a52e211a-9190-4f0a-8751-4f660fd95eea",
      "37b9e6a2-b456-4dfa-a1f6-55239d9f1544",
      "04e66f38-cddc-4742-ba48-9803e84f7074",
      "4474fc7a-cb30-4253-b019-d00f295670d4",
      "88cb75c5-50dd-4ad6-8cc7-87976902f8dd",
      "4467222c-2e78-4310-b3f3-e8089e7ec29c",
      "f15e693d-ebbd-4932-8980-a2849aadf2bf",
      "aa050ad3-fd4a-484a-98d6-b5b7302d9a50",
      "e6c2140f-ce69-4f3a-99d8-85bb392a2565",
      "a677e302-4293-4318-95d5-56c690a2c051",
      "80565f73-e202-4122-9d4c-db171b922b6c",
      "06f7b7e4-833f-42db-b7da-a1fe77493c18",
      "081db3be-4e47-4b90-850c-3f3715b95f6d",
      "fd03adef-e425-451b-a8e9-96237686b9f9",
      "63c057cf-c5b4-47db-88be-c90e3848d2ca",
      "5659dace-bdd1-463f-a256-96a4b780e42f",
      "20e5ad8f-8d26-4b8f-a5b0-626b26eb11cb",
      "2cab6b08-cc3b-432c-8829-0e8f47075525",
      "8ca3514d-aac5-40f6-ab6b-c2b083076f90",
      "80c201ef-22e7-4a64-8087-3006e9a42c90",
      "10b75dde-faa7-4c87-97a9-99e96ba9cad1",
      "0ef6ffe2-7285-410c-b0e7-ab5d33e259e1",
      "e05d256c-44fd-4e21-90e5-62b244fa1a0e",
      "2900cd6b-9af4-4e25-8a8f-437f4f2b7cd2"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1550525419525,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1551689221835,
    "parent_id": "f0a4483b-95d9-4c82-8e41-15c96d864674",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Mutexes"
        ]
      ]
    },
    "type": "page",
    "version": 4,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419519,
        "id": "fa7814aa-e4e8-4322-9315-2d10e44d5ef8",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419519,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Versions"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Versions"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419522,
        "id": "a52e211a-9190-4f0a-8751-4f660fd95eea",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419522,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "[{“Name”:“C++11”,“GroupName”:null},{“Name”:“c++11”,“GroupName”:null},{“Name”:“C++14”,“GroupName”:null},{“Name”:“c++14”,“GroupName”:null},{“Name”:“C++17”,“GroupName”:null},{“Name”:“c++17”,“GroupName”:null}]"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "[{“Name”:“C++11”,“GroupName”:null},{“Name”:“c++11”,“GroupName”:null},{“Name”:“C++14”,“GroupName”:null},{“Name”:“c++14”,“GroupName”:null},{“Name”:“C++17”,“GroupName”:null},{“Name”:“c++17”,“GroupName”:null}]"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419522,
        "id": "37b9e6a2-b456-4dfa-a1f6-55239d9f1544",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419522,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Remarks"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Remarks"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419522,
        "id": "04e66f38-cddc-4742-ba48-9803e84f7074",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419522,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "It is better to use "
            ],
            [
              "std::shared_mutex",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " than "
            ],
            [
              "std::shared_timed_mutex",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "header",
        "version": 1,
        "inline_content": [
          {
            "Text": "It is better to use "
          },
          {
            "Text": "std::shared_mutex",
            "AttrFlags": 4
          },
          {
            "Text": " than "
          },
          {
            "Text": "std::shared_timed_mutex",
            "AttrFlags": 4
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419522,
        "id": "4474fc7a-cb30-4253-b019-d00f295670d4",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419522,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The performance difference is more than double.",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The performance difference is more than double.",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419523,
        "id": "88cb75c5-50dd-4ad6-8cc7-87976902f8dd",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419523,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "If you want to use RWLock, you will find that there are two options."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "If you want to use RWLock, you will find that there are two options."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419523,
        "id": "4467222c-2e78-4310-b3f3-e8089e7ec29c",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419523,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "It is std::shared_mutex and shared_timed_mutex."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "It is std::shared_mutex and shared_timed_mutex."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419523,
        "id": "f15e693d-ebbd-4932-8980-a2849aadf2bf",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419523,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "you may think std::shared_timed_mutex is just the version ‘std::shared_mutex + time method’."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "you may think std::shared_timed_mutex is just the version ‘std::shared_mutex + time method’."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419523,
        "id": "aa050ad3-fd4a-484a-98d6-b5b7302d9a50",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419523,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "But the implementation is totally different.",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "But the implementation is totally different.",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419523,
        "id": "e6c2140f-ce69-4f3a-99d8-85bb392a2565",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419523,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The code below is MSVC14.1 implementation of std::shared_mutex."
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "The code below is MSVC14.1 implementation of std::shared_mutex."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419523,
        "id": "a677e302-4293-4318-95d5-56c690a2c051",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419523,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "class shared_mutex\n{\npublic: \ntypedef _Smtx_t * native_handle_type;\n\nshared_mutex() _NOEXCEPT\n    : _Myhandle(0)\n    {    // default construct\n    }\n\n~shared_mutex() _NOEXCEPT\n    {    // destroy the object\n    }\n\nvoid lock() _NOEXCEPT\n    {    // lock exclusive\n    _Smtx_lock_exclusive(\u0026_Myhandle);\n    }\n\nbool try_lock() _NOEXCEPT\n    {    // try to lock exclusive\n    return (_Smtx_try_lock_exclusive(\u0026_Myhandle) != 0);\n    }\n\nvoid unlock() _NOEXCEPT\n    {    // unlock exclusive\n    _Smtx_unlock_exclusive(\u0026_Myhandle);\n    }\n\nvoid lock_shared() _NOEXCEPT\n    {    // lock non-exclusive\n    _Smtx_lock_shared(\u0026_Myhandle);\n    }\n\nbool try_lock_shared() _NOEXCEPT\n    {    // try to lock non-exclusive\n    return (_Smtx_try_lock_shared(\u0026_Myhandle) != 0);\n    }\n\nvoid unlock_shared() _NOEXCEPT\n    {    // unlock non-exclusive\n    _Smtx_unlock_shared(\u0026_Myhandle);\n    }\n\nnative_handle_type native_handle() _NOEXCEPT\n    {    // get native handle\n    return (\u0026_Myhandle);\n    }\n\nshared_mutex(const shared_mutex\u0026) = delete;\nshared_mutex\u0026 operator=(const shared_mutex\u0026) = delete;\nprivate: \n    _Smtx_t _Myhandle;\n};\n\nvoid __cdecl _Smtx_lock_exclusive(_Smtx_t * smtx)\n{    /* lock shared mutex exclusively */\nAcquireSRWLockExclusive(reinterpret_cast\u003cPSRWLOCK\u003e(smtx));\n}\n\nvoid __cdecl _Smtx_lock_shared(_Smtx_t * smtx)\n{    /* lock shared mutex non-exclusively */\nAcquireSRWLockShared(reinterpret_cast\u003cPSRWLOCK\u003e(smtx));\n}\n\nint __cdecl _Smtx_try_lock_exclusive(_Smtx_t * smtx)\n{    /* try to lock shared mutex exclusively */\nreturn (TryAcquireSRWLockExclusive(reinterpret_cast\u003cPSRWLOCK\u003e(smtx)));\n}\n\nint __cdecl _Smtx_try_lock_shared(_Smtx_t * smtx)\n{    /* try to lock shared mutex non-exclusively */\nreturn (TryAcquireSRWLockShared(reinterpret_cast\u003cPSRWLOCK\u003e(smtx)));\n}\n\nvoid __cdecl _Smtx_unlock_exclusive(_Smtx_t * smtx)\n{    /* unlock exclusive shared mutex */\nReleaseSRWLockExclusive(reinterpret_cast\u003cPSRWLOCK\u003e(smtx));\n}\n\nvoid __cdecl _Smtx_unlock_shared(_Smtx_t * smtx)\n{    /* unlock non-exclusive shared mutex */\nReleaseSRWLockShared(reinterpret_cast\u003cPSRWLOCK\u003e(smtx));\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "class shared_mutex\n{\npublic: \ntypedef _Smtx_t * native_handle_type;\n\nshared_mutex() _NOEXCEPT\n    : _Myhandle(0)\n    {    // default construct\n    }\n\n~shared_mutex() _NOEXCEPT\n    {    // destroy the object\n    }\n\nvoid lock() _NOEXCEPT\n    {    // lock exclusive\n    _Smtx_lock_exclusive(\u0026_Myhandle);\n    }\n\nbool try_lock() _NOEXCEPT\n    {    // try to lock exclusive\n    return (_Smtx_try_lock_exclusive(\u0026_Myhandle) != 0);\n    }\n\nvoid unlock() _NOEXCEPT\n    {    // unlock exclusive\n    _Smtx_unlock_exclusive(\u0026_Myhandle);\n    }\n\nvoid lock_shared() _NOEXCEPT\n    {    // lock non-exclusive\n    _Smtx_lock_shared(\u0026_Myhandle);\n    }\n\nbool try_lock_shared() _NOEXCEPT\n    {    // try to lock non-exclusive\n    return (_Smtx_try_lock_shared(\u0026_Myhandle) != 0);\n    }\n\nvoid unlock_shared() _NOEXCEPT\n    {    // unlock non-exclusive\n    _Smtx_unlock_shared(\u0026_Myhandle);\n    }\n\nnative_handle_type native_handle() _NOEXCEPT\n    {    // get native handle\n    return (\u0026_Myhandle);\n    }\n\nshared_mutex(const shared_mutex\u0026) = delete;\nshared_mutex\u0026 operator=(const shared_mutex\u0026) = delete;\nprivate: \n    _Smtx_t _Myhandle;\n};\n\nvoid __cdecl _Smtx_lock_exclusive(_Smtx_t * smtx)\n{    /* lock shared mutex exclusively */\nAcquireSRWLockExclusive(reinterpret_cast\u003cPSRWLOCK\u003e(smtx));\n}\n\nvoid __cdecl _Smtx_lock_shared(_Smtx_t * smtx)\n{    /* lock shared mutex non-exclusively */\nAcquireSRWLockShared(reinterpret_cast\u003cPSRWLOCK\u003e(smtx));\n}\n\nint __cdecl _Smtx_try_lock_exclusive(_Smtx_t * smtx)\n{    /* try to lock shared mutex exclusively */\nreturn (TryAcquireSRWLockExclusive(reinterpret_cast\u003cPSRWLOCK\u003e(smtx)));\n}\n\nint __cdecl _Smtx_try_lock_shared(_Smtx_t * smtx)\n{    /* try to lock shared mutex non-exclusively */\nreturn (TryAcquireSRWLockShared(reinterpret_cast\u003cPSRWLOCK\u003e(smtx)));\n}\n\nvoid __cdecl _Smtx_unlock_exclusive(_Smtx_t * smtx)\n{    /* unlock exclusive shared mutex */\nReleaseSRWLockExclusive(reinterpret_cast\u003cPSRWLOCK\u003e(smtx));\n}\n\nvoid __cdecl _Smtx_unlock_shared(_Smtx_t * smtx)\n{    /* unlock non-exclusive shared mutex */\nReleaseSRWLockShared(reinterpret_cast\u003cPSRWLOCK\u003e(smtx));\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419523,
        "id": "80565f73-e202-4122-9d4c-db171b922b6c",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419523,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "You can see that std::shared_mutex is implemented in Windows Slim Reader/Write Locks(https://msdn.microsoft.com/ko-kr/library/windows/desktop/aa904937(v=vs.85).aspx)"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "You can see that std::shared_mutex is implemented in Windows Slim Reader/Write Locks(https://msdn.microsoft.com/ko-kr/library/windows/desktop/aa904937(v=vs.85).aspx)"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419523,
        "id": "06f7b7e4-833f-42db-b7da-a1fe77493c18",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419523,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Now Let’s look at the implementation of std::shared_timed_mutex."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Now Let’s look at the implementation of std::shared_timed_mutex."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419524,
        "id": "081db3be-4e47-4b90-850c-3f3715b95f6d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419524,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The code below is MSVC14.1 implementation of std::shared_timed_mutex."
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "The code below is MSVC14.1 implementation of std::shared_timed_mutex."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419524,
        "id": "fd03adef-e425-451b-a8e9-96237686b9f9",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419524,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "class shared_timed_mutex\n{\ntypedef unsigned int _Read_cnt_t;\nstatic constexpr _Read_cnt_t _Max_readers = _Read_cnt_t(-1);\npublic:\nshared_timed_mutex() _NOEXCEPT\n    : _Mymtx(), _Read_queue(), _Write_queue(),\n        _Readers(0), _Writing(false)\n    {    // default construct\n    }\n\n~shared_timed_mutex() _NOEXCEPT\n    {    // destroy the object\n    }\n\nvoid lock()\n    {    // lock exclusive\n    unique_lock\u003cmutex\u003e _Lock(_Mymtx);\n    while (_Writing)\n        _Write_queue.wait(_Lock);\n    _Writing = true;\n    while (0 \u003c _Readers)\n        _Read_queue.wait(_Lock);    // wait for writing, no readers\n    }\n\nbool try_lock()\n    {    // try to lock exclusive\n    lock_guard\u003cmutex\u003e _Lock(_Mymtx);\n    if (_Writing || 0 \u003c _Readers)\n        return (false);\n    else\n        {    // set writing, no readers\n        _Writing = true;\n        return (true);\n        }\n    }\n\ntemplate\u003cclass _Rep,\n    class _Period\u003e\n    bool try_lock_for(\n        const chrono::duration\u003c_Rep, _Period\u003e\u0026 _Rel_time)\n    {    // try to lock for duration\n    return (try_lock_until(chrono::steady_clock::now() + _Rel_time));\n    }\n\ntemplate\u003cclass _Clock,\n    class _Duration\u003e\n    bool try_lock_until(\n        const chrono::time_point\u003c_Clock, _Duration\u003e\u0026 _Abs_time)\n    {    // try to lock until time point\n    auto _Not_writing = [this] { return (!_Writing); };\n    auto _Zero_readers = [this] { return (_Readers == 0); };\n    unique_lock\u003cmutex\u003e _Lock(_Mymtx);\n\n    if (!_Write_queue.wait_until(_Lock, _Abs_time, _Not_writing))\n        return (false);\n\n    _Writing = true;\n\n    if (!_Read_queue.wait_until(_Lock, _Abs_time, _Zero_readers))\n        {    // timeout, leave writing state\n        _Writing = false;\n        _Lock.unlock();    // unlock before notifying, for efficiency\n        _Write_queue.notify_all();\n        return (false);\n        }\n\n    return (true);\n    }\n\nvoid unlock()\n    {    // unlock exclusive\n        {    // unlock before notifying, for efficiency\n        lock_guard\u003cmutex\u003e _Lock(_Mymtx);\n\n        _Writing = false;\n        }\n\n    _Write_queue.notify_all();\n    }\n\nvoid lock_shared()\n    {    // lock non-exclusive\n    unique_lock\u003cmutex\u003e _Lock(_Mymtx);\n    while (_Writing || _Readers == _Max_readers)\n        _Write_queue.wait(_Lock);\n    ++_Readers;\n    }\n\nbool try_lock_shared()\n    {    // try to lock non-exclusive\n    lock_guard\u003cmutex\u003e _Lock(_Mymtx);\n    if (_Writing || _Readers == _Max_readers)\n        return (false);\n    else\n        {    // count another reader\n        ++_Readers;\n        return (true);\n        }\n    }\n\ntemplate\u003cclass _Rep,\n    class _Period\u003e\n    bool try_lock_shared_for(\n        const chrono::duration\u003c_Rep, _Period\u003e\u0026 _Rel_time)\n    {    // try to lock non-exclusive for relative time\n    return (try_lock_shared_until(_Rel_time\n        + chrono::steady_clock::now()));\n    }\n\ntemplate\u003cclass _Time\u003e\n    bool _Try_lock_shared_until(_Time _Abs_time)\n    {    // try to lock non-exclusive until absolute time\n    auto _Can_acquire = [this] {\n        return (!_Writing \u0026\u0026 _Readers \u003c _Max_readers); };\n\n    unique_lock\u003cmutex\u003e _Lock(_Mymtx);\n\n    if (!_Write_queue.wait_until(_Lock, _Abs_time, _Can_acquire))\n        return (false);\n\n    ++_Readers;\n    return (true);\n    }\n\ntemplate\u003cclass _Clock,\n    class _Duration\u003e\n    bool try_lock_shared_until(\n        const chrono::time_point\u003c_Clock, _Duration\u003e\u0026 _Abs_time)\n    {    // try to lock non-exclusive until absolute time\n    return (_Try_lock_shared_until(_Abs_time));\n    }\n\nbool try_lock_shared_until(const xtime *_Abs_time)\n    {    // try to lock non-exclusive until absolute time\n    return (_Try_lock_shared_until(_Abs_time));\n    }\n\nvoid unlock_shared()\n    {    // unlock non-exclusive\n    _Read_cnt_t _Local_readers;\n    bool _Local_writing;\n\n        {    // unlock before notifying, for efficiency\n        lock_guard\u003cmutex\u003e _Lock(_Mymtx);\n        --_Readers;\n        _Local_readers = _Readers;\n        _Local_writing = _Writing;\n        }\n\n    if (_Local_writing \u0026\u0026 _Local_readers == 0)\n        _Read_queue.notify_one();\n    else if (!_Local_writing \u0026\u0026 _Local_readers == _Max_readers - 1)\n        _Write_queue.notify_all();\n    }\n\nshared_timed_mutex(const shared_timed_mutex\u0026) = delete;\nshared_timed_mutex\u0026 operator=(const shared_timed_mutex\u0026) = delete;\nprivate:\nmutex _Mymtx;\ncondition_variable _Read_queue, _Write_queue;\n_Read_cnt_t _Readers;\nbool _Writing;\n};\n\nclass stl_condition_variable_win7 final : public stl_condition_variable_interface\n{\npublic:\n    stl_condition_variable_win7()\n    {\n        __crtInitializeConditionVariable(\u0026m_condition_variable);\n    }\n\n    ~stl_condition_variable_win7() = delete;\n    stl_condition_variable_win7(const stl_condition_variable_win7\u0026) = delete;\n    stl_condition_variable_win7\u0026 operator=(const stl_condition_variable_win7\u0026) = delete;\n\n    virtual void destroy() override {}\n\n    virtual void wait(stl_critical_section_interface *lock) override\n    {\n        if (!stl_condition_variable_win7::wait_for(lock, INFINITE))\n            std::terminate();\n    }\n\n    virtual bool wait_for(stl_critical_section_interface *lock, unsigned int timeout) override\n    {\n        return __crtSleepConditionVariableSRW(\u0026m_condition_variable, static_cast\u003cstl_critical_section_win7 *\u003e(lock)-\u003enative_handle(), timeout, 0) != 0;\n    }\n\n    virtual void notify_one() override\n    {\n        __crtWakeConditionVariable(\u0026m_condition_variable);\n    }\n\n    virtual void notify_all() override\n    {\n        __crtWakeAllConditionVariable(\u0026m_condition_variable);\n    }\n\nprivate:\n    CONDITION_VARIABLE m_condition_variable;\n};"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "class shared_timed_mutex\n{\ntypedef unsigned int _Read_cnt_t;\nstatic constexpr _Read_cnt_t _Max_readers = _Read_cnt_t(-1);\npublic:\nshared_timed_mutex() _NOEXCEPT\n    : _Mymtx(), _Read_queue(), _Write_queue(),\n        _Readers(0), _Writing(false)\n    {    // default construct\n    }\n\n~shared_timed_mutex() _NOEXCEPT\n    {    // destroy the object\n    }\n\nvoid lock()\n    {    // lock exclusive\n    unique_lock\u003cmutex\u003e _Lock(_Mymtx);\n    while (_Writing)\n        _Write_queue.wait(_Lock);\n    _Writing = true;\n    while (0 \u003c _Readers)\n        _Read_queue.wait(_Lock);    // wait for writing, no readers\n    }\n\nbool try_lock()\n    {    // try to lock exclusive\n    lock_guard\u003cmutex\u003e _Lock(_Mymtx);\n    if (_Writing || 0 \u003c _Readers)\n        return (false);\n    else\n        {    // set writing, no readers\n        _Writing = true;\n        return (true);\n        }\n    }\n\ntemplate\u003cclass _Rep,\n    class _Period\u003e\n    bool try_lock_for(\n        const chrono::duration\u003c_Rep, _Period\u003e\u0026 _Rel_time)\n    {    // try to lock for duration\n    return (try_lock_until(chrono::steady_clock::now() + _Rel_time));\n    }\n\ntemplate\u003cclass _Clock,\n    class _Duration\u003e\n    bool try_lock_until(\n        const chrono::time_point\u003c_Clock, _Duration\u003e\u0026 _Abs_time)\n    {    // try to lock until time point\n    auto _Not_writing = [this] { return (!_Writing); };\n    auto _Zero_readers = [this] { return (_Readers == 0); };\n    unique_lock\u003cmutex\u003e _Lock(_Mymtx);\n\n    if (!_Write_queue.wait_until(_Lock, _Abs_time, _Not_writing))\n        return (false);\n\n    _Writing = true;\n\n    if (!_Read_queue.wait_until(_Lock, _Abs_time, _Zero_readers))\n        {    // timeout, leave writing state\n        _Writing = false;\n        _Lock.unlock();    // unlock before notifying, for efficiency\n        _Write_queue.notify_all();\n        return (false);\n        }\n\n    return (true);\n    }\n\nvoid unlock()\n    {    // unlock exclusive\n        {    // unlock before notifying, for efficiency\n        lock_guard\u003cmutex\u003e _Lock(_Mymtx);\n\n        _Writing = false;\n        }\n\n    _Write_queue.notify_all();\n    }\n\nvoid lock_shared()\n    {    // lock non-exclusive\n    unique_lock\u003cmutex\u003e _Lock(_Mymtx);\n    while (_Writing || _Readers == _Max_readers)\n        _Write_queue.wait(_Lock);\n    ++_Readers;\n    }\n\nbool try_lock_shared()\n    {    // try to lock non-exclusive\n    lock_guard\u003cmutex\u003e _Lock(_Mymtx);\n    if (_Writing || _Readers == _Max_readers)\n        return (false);\n    else\n        {    // count another reader\n        ++_Readers;\n        return (true);\n        }\n    }\n\ntemplate\u003cclass _Rep,\n    class _Period\u003e\n    bool try_lock_shared_for(\n        const chrono::duration\u003c_Rep, _Period\u003e\u0026 _Rel_time)\n    {    // try to lock non-exclusive for relative time\n    return (try_lock_shared_until(_Rel_time\n        + chrono::steady_clock::now()));\n    }\n\ntemplate\u003cclass _Time\u003e\n    bool _Try_lock_shared_until(_Time _Abs_time)\n    {    // try to lock non-exclusive until absolute time\n    auto _Can_acquire = [this] {\n        return (!_Writing \u0026\u0026 _Readers \u003c _Max_readers); };\n\n    unique_lock\u003cmutex\u003e _Lock(_Mymtx);\n\n    if (!_Write_queue.wait_until(_Lock, _Abs_time, _Can_acquire))\n        return (false);\n\n    ++_Readers;\n    return (true);\n    }\n\ntemplate\u003cclass _Clock,\n    class _Duration\u003e\n    bool try_lock_shared_until(\n        const chrono::time_point\u003c_Clock, _Duration\u003e\u0026 _Abs_time)\n    {    // try to lock non-exclusive until absolute time\n    return (_Try_lock_shared_until(_Abs_time));\n    }\n\nbool try_lock_shared_until(const xtime *_Abs_time)\n    {    // try to lock non-exclusive until absolute time\n    return (_Try_lock_shared_until(_Abs_time));\n    }\n\nvoid unlock_shared()\n    {    // unlock non-exclusive\n    _Read_cnt_t _Local_readers;\n    bool _Local_writing;\n\n        {    // unlock before notifying, for efficiency\n        lock_guard\u003cmutex\u003e _Lock(_Mymtx);\n        --_Readers;\n        _Local_readers = _Readers;\n        _Local_writing = _Writing;\n        }\n\n    if (_Local_writing \u0026\u0026 _Local_readers == 0)\n        _Read_queue.notify_one();\n    else if (!_Local_writing \u0026\u0026 _Local_readers == _Max_readers - 1)\n        _Write_queue.notify_all();\n    }\n\nshared_timed_mutex(const shared_timed_mutex\u0026) = delete;\nshared_timed_mutex\u0026 operator=(const shared_timed_mutex\u0026) = delete;\nprivate:\nmutex _Mymtx;\ncondition_variable _Read_queue, _Write_queue;\n_Read_cnt_t _Readers;\nbool _Writing;\n};\n\nclass stl_condition_variable_win7 final : public stl_condition_variable_interface\n{\npublic:\n    stl_condition_variable_win7()\n    {\n        __crtInitializeConditionVariable(\u0026m_condition_variable);\n    }\n\n    ~stl_condition_variable_win7() = delete;\n    stl_condition_variable_win7(const stl_condition_variable_win7\u0026) = delete;\n    stl_condition_variable_win7\u0026 operator=(const stl_condition_variable_win7\u0026) = delete;\n\n    virtual void destroy() override {}\n\n    virtual void wait(stl_critical_section_interface *lock) override\n    {\n        if (!stl_condition_variable_win7::wait_for(lock, INFINITE))\n            std::terminate();\n    }\n\n    virtual bool wait_for(stl_critical_section_interface *lock, unsigned int timeout) override\n    {\n        return __crtSleepConditionVariableSRW(\u0026m_condition_variable, static_cast\u003cstl_critical_section_win7 *\u003e(lock)-\u003enative_handle(), timeout, 0) != 0;\n    }\n\n    virtual void notify_one() override\n    {\n        __crtWakeConditionVariable(\u0026m_condition_variable);\n    }\n\n    virtual void notify_all() override\n    {\n        __crtWakeAllConditionVariable(\u0026m_condition_variable);\n    }\n\nprivate:\n    CONDITION_VARIABLE m_condition_variable;\n};",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419524,
        "id": "63c057cf-c5b4-47db-88be-c90e3848d2ca",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419524,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "You can see that std::shared_timed_mutex is implemented in std::condition_value."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "You can see that std::shared_timed_mutex is implemented in std::condition_value."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419524,
        "id": "5659dace-bdd1-463f-a256-96a4b780e42f",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419524,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "This is a huge difference."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "This is a huge difference."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419524,
        "id": "20e5ad8f-8d26-4b8f-a5b0-626b26eb11cb",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419524,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "So Let’s check the performance of two of them."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "So Let’s check the performance of two of them."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419524,
        "id": "2cab6b08-cc3b-432c-8829-0e8f47075525",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419524,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "source": [
            [
              "/tmp/b9e0d0b5-2b5a-4353-8b29-15c691c80b3c/f109152b37fdc74ab2796766013ff66197bf50b2.png"
            ]
          ]
        },
        "type": "image",
        "version": 1,
        "source": "/tmp/b9e0d0b5-2b5a-4353-8b29-15c691c80b3c/f109152b37fdc74ab2796766013ff66197bf50b2.png",
        "image_url": "https://www.notion.so/image/https:%2F%2Fwww.notion.so%2Ftmp%2Fb9e0d0b5-2b5a-4353-8b29-15c691c80b3c%2Ff109152b37fdc74ab2796766013ff66197bf50b2.png"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419524,
        "id": "8ca3514d-aac5-40f6-ab6b-c2b083076f90",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419524,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "This is the result of read/write test for 1000 millisecond."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "This is the result of read/write test for 1000 millisecond."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419524,
        "id": "80c201ef-22e7-4a64-8087-3006e9a42c90",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419524,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "std::shared_mutex processed read/write "
            ],
            [
              "over 2 times",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " more than std::shared_timed_mutex."
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "std::shared_mutex processed read/write "
          },
          {
            "Text": "over 2 times",
            "AttrFlags": 1
          },
          {
            "Text": " more than std::shared_timed_mutex."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419525,
        "id": "10b75dde-faa7-4c87-97a9-99e96ba9cad1",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419525,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "In this example, the read / write ratio is the same, but the read rate is more frequent than the write rate in real."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "In this example, the read / write ratio is the same, but the read rate is more frequent than the write rate in real."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419525,
        "id": "0ef6ffe2-7285-410c-b0e7-ab5d33e259e1",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419525,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Therefore, the performance difference can be larger."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Therefore, the performance difference can be larger."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419525,
        "id": "e05d256c-44fd-4e21-90e5-62b244fa1a0e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419525,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "the code below is the code in this example."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "the code below is the code in this example."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550525419525,
        "id": "2900cd6b-9af4-4e25-8a8f-437f4f2b7cd2",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550525419525,
        "parent_id": "1253383e-7e5b-4dd4-90c9-22409e891d18",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "void useSTLSharedMutex()\n{\n    std::shared_mutex shared_mtx_lock;\n\n    std::vector\u003cstd::thread\u003e readThreads;\n    std::vector\u003cstd::thread\u003e writeThreads;\n\n    std::list\u003cint\u003e data = { 0 };\n    volatile bool exit = false;\n\n    std::atomic\u003cint\u003e readProcessedCnt(0);\n    std::atomic\u003cint\u003e writeProcessedCnt(0);\n\n    for (unsigned int i = 0; i \u003c std::thread::hardware_concurrency(); i++)\n    {\n\n        readThreads.push_back(std::thread([\u0026data, \u0026exit, \u0026shared_mtx_lock, \u0026readProcessedCnt]() {\n            std::list\u003cint\u003e mydata;\n            int localProcessCnt = 0;\n\n            while (true)\n            {\n                shared_mtx_lock.lock_shared();\n\n                mydata.push_back(data.back());\n                ++localProcessCnt;\n\n                shared_mtx_lock.unlock_shared();\n\n                if (exit)\n                    break;\n            }\n\n            std::atomic_fetch_add(\u0026readProcessedCnt, localProcessCnt);\n\n        }));\n\n        writeThreads.push_back(std::thread([\u0026data, \u0026exit, \u0026shared_mtx_lock, \u0026writeProcessedCnt]() {\n\n            int localProcessCnt = 0;\n\n            while (true)\n            {\n                shared_mtx_lock.lock();\n\n                data.push_back(rand() % 100);\n                ++localProcessCnt;\n\n                shared_mtx_lock.unlock();\n\n                if (exit)\n                    break;\n            }\n\n            std::atomic_fetch_add(\u0026writeProcessedCnt, localProcessCnt);\n\n        }));\n    }\n\n    std::this_thread::sleep_for(std::chrono::milliseconds(MAIN_WAIT_MILLISECONDS));\n    exit = true;\n\n    for (auto \u0026r : readThreads)\n        r.join();\n\n    for (auto \u0026w : writeThreads)\n        w.join();\n\n    std::cout \u003c\u003c \"STLSharedMutex READ :           \" \u003c\u003c readProcessedCnt \u003c\u003c std::endl;\n    std::cout \u003c\u003c \"STLSharedMutex WRITE :          \" \u003c\u003c writeProcessedCnt \u003c\u003c std::endl;\n    std::cout \u003c\u003c \"TOTAL READ\u0026WRITE :              \" \u003c\u003c readProcessedCnt + writeProcessedCnt \u003c\u003c std::endl \u003c\u003c std::endl;\n}\n\nvoid useSTLSharedTimedMutex()\n{\n    std::shared_timed_mutex shared_mtx_lock;\n\n    std::vector\u003cstd::thread\u003e readThreads;\n    std::vector\u003cstd::thread\u003e writeThreads;\n\n    std::list\u003cint\u003e data = { 0 };\n    volatile bool exit = false;\n\n    std::atomic\u003cint\u003e readProcessedCnt(0);\n    std::atomic\u003cint\u003e writeProcessedCnt(0);\n\n    for (unsigned int i = 0; i \u003c std::thread::hardware_concurrency(); i++)\n    {\n\n        readThreads.push_back(std::thread([\u0026data, \u0026exit, \u0026shared_mtx_lock, \u0026readProcessedCnt]() {\n            std::list\u003cint\u003e mydata;\n            int localProcessCnt = 0;\n\n            while (true)\n            {\n                shared_mtx_lock.lock_shared();\n\n                mydata.push_back(data.back());\n                ++localProcessCnt;\n\n                shared_mtx_lock.unlock_shared();\n\n                if (exit)\n                    break;\n            }\n\n            std::atomic_fetch_add(\u0026readProcessedCnt, localProcessCnt);\n\n        }));\n\n        writeThreads.push_back(std::thread([\u0026data, \u0026exit, \u0026shared_mtx_lock, \u0026writeProcessedCnt]() {\n\n            int localProcessCnt = 0;\n\n            while (true)\n            {\n                shared_mtx_lock.lock();\n\n                data.push_back(rand() % 100);\n                ++localProcessCnt;\n\n                shared_mtx_lock.unlock();\n\n                if (exit)\n                    break;\n            }\n\n            std::atomic_fetch_add(\u0026writeProcessedCnt, localProcessCnt);\n\n        }));\n    }\n\n    std::this_thread::sleep_for(std::chrono::milliseconds(MAIN_WAIT_MILLISECONDS));\n    exit = true;\n\n    for (auto \u0026r : readThreads)\n        r.join();\n\n    for (auto \u0026w : writeThreads)\n        w.join();\n\n    std::cout \u003c\u003c \"STLSharedTimedMutex READ :      \" \u003c\u003c readProcessedCnt \u003c\u003c std::endl;\n    std::cout \u003c\u003c \"STLSharedTimedMutex WRITE :     \" \u003c\u003c writeProcessedCnt \u003c\u003c std::endl;\n    std::cout \u003c\u003c \"TOTAL READ\u0026WRITE :              \" \u003c\u003c readProcessedCnt + writeProcessedCnt \u003c\u003c std::endl \u003c\u003c std::endl;\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "void useSTLSharedMutex()\n{\n    std::shared_mutex shared_mtx_lock;\n\n    std::vector\u003cstd::thread\u003e readThreads;\n    std::vector\u003cstd::thread\u003e writeThreads;\n\n    std::list\u003cint\u003e data = { 0 };\n    volatile bool exit = false;\n\n    std::atomic\u003cint\u003e readProcessedCnt(0);\n    std::atomic\u003cint\u003e writeProcessedCnt(0);\n\n    for (unsigned int i = 0; i \u003c std::thread::hardware_concurrency(); i++)\n    {\n\n        readThreads.push_back(std::thread([\u0026data, \u0026exit, \u0026shared_mtx_lock, \u0026readProcessedCnt]() {\n            std::list\u003cint\u003e mydata;\n            int localProcessCnt = 0;\n\n            while (true)\n            {\n                shared_mtx_lock.lock_shared();\n\n                mydata.push_back(data.back());\n                ++localProcessCnt;\n\n                shared_mtx_lock.unlock_shared();\n\n                if (exit)\n                    break;\n            }\n\n            std::atomic_fetch_add(\u0026readProcessedCnt, localProcessCnt);\n\n        }));\n\n        writeThreads.push_back(std::thread([\u0026data, \u0026exit, \u0026shared_mtx_lock, \u0026writeProcessedCnt]() {\n\n            int localProcessCnt = 0;\n\n            while (true)\n            {\n                shared_mtx_lock.lock();\n\n                data.push_back(rand() % 100);\n                ++localProcessCnt;\n\n                shared_mtx_lock.unlock();\n\n                if (exit)\n                    break;\n            }\n\n            std::atomic_fetch_add(\u0026writeProcessedCnt, localProcessCnt);\n\n        }));\n    }\n\n    std::this_thread::sleep_for(std::chrono::milliseconds(MAIN_WAIT_MILLISECONDS));\n    exit = true;\n\n    for (auto \u0026r : readThreads)\n        r.join();\n\n    for (auto \u0026w : writeThreads)\n        w.join();\n\n    std::cout \u003c\u003c \"STLSharedMutex READ :           \" \u003c\u003c readProcessedCnt \u003c\u003c std::endl;\n    std::cout \u003c\u003c \"STLSharedMutex WRITE :          \" \u003c\u003c writeProcessedCnt \u003c\u003c std::endl;\n    std::cout \u003c\u003c \"TOTAL READ\u0026WRITE :              \" \u003c\u003c readProcessedCnt + writeProcessedCnt \u003c\u003c std::endl \u003c\u003c std::endl;\n}\n\nvoid useSTLSharedTimedMutex()\n{\n    std::shared_timed_mutex shared_mtx_lock;\n\n    std::vector\u003cstd::thread\u003e readThreads;\n    std::vector\u003cstd::thread\u003e writeThreads;\n\n    std::list\u003cint\u003e data = { 0 };\n    volatile bool exit = false;\n\n    std::atomic\u003cint\u003e readProcessedCnt(0);\n    std::atomic\u003cint\u003e writeProcessedCnt(0);\n\n    for (unsigned int i = 0; i \u003c std::thread::hardware_concurrency(); i++)\n    {\n\n        readThreads.push_back(std::thread([\u0026data, \u0026exit, \u0026shared_mtx_lock, \u0026readProcessedCnt]() {\n            std::list\u003cint\u003e mydata;\n            int localProcessCnt = 0;\n\n            while (true)\n            {\n                shared_mtx_lock.lock_shared();\n\n                mydata.push_back(data.back());\n                ++localProcessCnt;\n\n                shared_mtx_lock.unlock_shared();\n\n                if (exit)\n                    break;\n            }\n\n            std::atomic_fetch_add(\u0026readProcessedCnt, localProcessCnt);\n\n        }));\n\n        writeThreads.push_back(std::thread([\u0026data, \u0026exit, \u0026shared_mtx_lock, \u0026writeProcessedCnt]() {\n\n            int localProcessCnt = 0;\n\n            while (true)\n            {\n                shared_mtx_lock.lock();\n\n                data.push_back(rand() % 100);\n                ++localProcessCnt;\n\n                shared_mtx_lock.unlock();\n\n                if (exit)\n                    break;\n            }\n\n            std::atomic_fetch_add(\u0026writeProcessedCnt, localProcessCnt);\n\n        }));\n    }\n\n    std::this_thread::sleep_for(std::chrono::milliseconds(MAIN_WAIT_MILLISECONDS));\n    exit = true;\n\n    for (auto \u0026r : readThreads)\n        r.join();\n\n    for (auto \u0026w : writeThreads)\n        w.join();\n\n    std::cout \u003c\u003c \"STLSharedTimedMutex READ :      \" \u003c\u003c readProcessedCnt \u003c\u003c std::endl;\n    std::cout \u003c\u003c \"STLSharedTimedMutex WRITE :     \" \u003c\u003c writeProcessedCnt \u003c\u003c std::endl;\n    std::cout \u003c\u003c \"TOTAL READ\u0026WRITE :              \" \u003c\u003c readProcessedCnt + writeProcessedCnt \u003c\u003c std::endl \u003c\u003c std::endl;\n}",
        "code_language": "Plain Text"
      }
    ],
    "title": "Mutexes",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 19
    }
  ],
  "Tables": null
}