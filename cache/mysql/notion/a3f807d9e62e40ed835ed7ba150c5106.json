{
  "ID": "a3f807d9-e62e-40ed-835e-d7ba150c5106",
  "Root": {
    "alive": true,
    "content": [
      "b7b7d3c5-fd4f-4024-a0a7-f8e06a61a9bc",
      "21d63801-dd2d-4adf-ab37-933872e339ce",
      "146c5e8d-2080-4090-a5b6-ae4f966a0be1",
      "c5ecbe4b-3342-4bf1-a150-bdd9e7879fde",
      "f935a9be-6ff8-4e07-adfb-d5040698f1f3",
      "eac8a6a1-a25f-41e2-9ca8-77bb7f4dc9ab",
      "533282f8-34c7-47e1-8425-4eb4332b871a",
      "d56a5889-baea-4fe4-b320-a09577afe31e",
      "d8497c43-2e55-441b-95d4-2ce2eb720622",
      "27be5d67-4538-42e4-b71f-fe619723d8bc"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1550383528442,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "a3f807d9-e62e-40ed-835e-d7ba150c5106",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1550642880000,
    "parent_id": "a14c3674-c8f3-42a7-bde0-6fe36822313f",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Optimizing Storage Layout for InnoDB Tables"
        ]
      ]
    },
    "type": "page",
    "version": 8,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550383528437,
        "id": "b7b7d3c5-fd4f-4024-a0a7-f8e06a61a9bc",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550383528437,
        "parent_id": "a3f807d9-e62e-40ed-835e-d7ba150c5106",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "In InnoDB, having a long PRIMARY KEY (either a single column with a"
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "In InnoDB, having a long PRIMARY KEY (either a single column with a"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550383528437,
        "id": "21d63801-dd2d-4adf-ab37-933872e339ce",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550383528437,
        "parent_id": "a3f807d9-e62e-40ed-835e-d7ba150c5106",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "lengthy value, or several columns that form a long composite value) \nwastes a lot of disk space. The primary key value for a row is duplicated in all the secondary index records that point to the same\nrow. Create an AUTO_INCREMENT column as the primary key if your\nprimary key is long."
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "lengthy value, or several columns that form a long composite value) \nwastes a lot of disk space. The primary key value for a row is duplicated in all the secondary index records that point to the same\nrow. Create an AUTO_INCREMENT column as the primary key if your\nprimary key is long.",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550383528441,
        "id": "146c5e8d-2080-4090-a5b6-ae4f966a0be1",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550383528441,
        "parent_id": "a3f807d9-e62e-40ed-835e-d7ba150c5106",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Use the VARCHAR data type instead of CHAR to store variable-length"
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Use the VARCHAR data type instead of CHAR to store variable-length"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550383528441,
        "id": "c5ecbe4b-3342-4bf1-a150-bdd9e7879fde",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550383528441,
        "parent_id": "a3f807d9-e62e-40ed-835e-d7ba150c5106",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "strings or for columns with many NULL values. A CHAR(N) column\nalways takes N characters to store data, even if the string is\nshorter or its value is NULL. Smaller tables fit better in the\nbuffer pool and reduce disk I/O."
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "strings or for columns with many NULL values. A CHAR(N) column\nalways takes N characters to store data, even if the string is\nshorter or its value is NULL. Smaller tables fit better in the\nbuffer pool and reduce disk I/O.",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550383528442,
        "id": "f935a9be-6ff8-4e07-adfb-d5040698f1f3",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550383528442,
        "parent_id": "a3f807d9-e62e-40ed-835e-d7ba150c5106",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "When using COMPACT row format (the default InnoDB format) and variable-length character sets, such as utf8 or sjis, CHAR(N) columns occupy a variable amount of space, but still at least N bytes."
            ]
          ]
        },
        "type": "quote",
        "version": 1,
        "inline_content": [
          {
            "Text": "When using COMPACT row format (the default InnoDB format) and variable-length character sets, such as utf8 or sjis, CHAR(N) columns occupy a variable amount of space, but still at least N bytes."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550383528442,
        "id": "eac8a6a1-a25f-41e2-9ca8-77bb7f4dc9ab",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550383528442,
        "parent_id": "a3f807d9-e62e-40ed-835e-d7ba150c5106",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "For tables that are big, or contain lots of repetitive text or"
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "For tables that are big, or contain lots of repetitive text or"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550383528442,
        "id": "533282f8-34c7-47e1-8425-4eb4332b871a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550383528442,
        "parent_id": "a3f807d9-e62e-40ed-835e-d7ba150c5106",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "numeric data, consider using COMPRESSED row format. Less disk I/O is\nrequired to bring data into the buffer pool, or to perform full\ntable scans. Before making a permanent decision, measure the amount\nof compression you can achieve by using COMPRESSED versus COMPACT\nrow format.  _Caveat:_  Benchmarks rarely show better than 2:1 compression\nand there is a lot of overhead in the buffer_pool for COMPRESSED."
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "numeric data, consider using COMPRESSED row format. Less disk I/O is\nrequired to bring data into the buffer pool, or to perform full\ntable scans. Before making a permanent decision, measure the amount\nof compression you can achieve by using COMPRESSED versus COMPACT\nrow format.  _Caveat:_  Benchmarks rarely show better than 2:1 compression\nand there is a lot of overhead in the buffer_pool for COMPRESSED.",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550383528442,
        "id": "d56a5889-baea-4fe4-b320-a09577afe31e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550383528442,
        "parent_id": "a3f807d9-e62e-40ed-835e-d7ba150c5106",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Once your data reaches a stable size, or a growing table has"
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Once your data reaches a stable size, or a growing table has"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550383528442,
        "id": "d8497c43-2e55-441b-95d4-2ce2eb720622",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550383528442,
        "parent_id": "a3f807d9-e62e-40ed-835e-d7ba150c5106",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "increased by tens or some hundreds of megabytes, consider using the\nOPTIMIZE TABLE statement to reorganize the table and compact any\nwasted space. The reorganized tables require less disk I/O to\nperform full table scans. This is a straightforward technique that\ncan improve performance when other techniques such as improving\nindex usage or tuning application code are not practical.\n_Caveat_:  Regardless of table size, OPTIMIZE TABLE should only rarely be performed.\nThis is because it is costly, and rarely improves the table enough to be worth it.\nInnoDB is reasonably good at keeping its B+Trees free of a lot of wasted space."
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "increased by tens or some hundreds of megabytes, consider using the\nOPTIMIZE TABLE statement to reorganize the table and compact any\nwasted space. The reorganized tables require less disk I/O to\nperform full table scans. This is a straightforward technique that\ncan improve performance when other techniques such as improving\nindex usage or tuning application code are not practical.\n_Caveat_:  Regardless of table size, OPTIMIZE TABLE should only rarely be performed.\nThis is because it is costly, and rarely improves the table enough to be worth it.\nInnoDB is reasonably good at keeping its B+Trees free of a lot of wasted space.",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550383528442,
        "id": "27be5d67-4538-42e4-b71f-fe619723d8bc",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550383528442,
        "parent_id": "a3f807d9-e62e-40ed-835e-d7ba150c5106",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "OPTIMIZE TABLE copies the data part of the table and rebuilds the indexes. The benefits come from improved packing of data within indexes, and reduced fragmentation within the tablespaces and on disk. The benefits vary depending on the data in each table. You may find that there are significant gains for some and not for others, or that the gains decrease over time until you next optimize the table. This operation can be slow if the table is large or if the indexes being rebuilt do not fit into the buffer pool. The first run after adding a lot of data to a table is often much slower than later runs."
            ]
          ]
        },
        "type": "quote",
        "version": 1,
        "inline_content": [
          {
            "Text": "OPTIMIZE TABLE copies the data part of the table and rebuilds the indexes. The benefits come from improved packing of data within indexes, and reduced fragmentation within the tablespaces and on disk. The benefits vary depending on the data in each table. You may find that there are significant gains for some and not for others, or that the gains decrease over time until you next optimize the table. This operation can be slow if the table is large or if the indexes being rebuilt do not fit into the buffer pool. The first run after adding a lot of data to a table is often much slower than later runs."
          }
        ]
      }
    ],
    "title": "Optimizing Storage Layout for InnoDB Tables",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}