{
  "ID": "8b0184ab-afca-426b-9625-8c2fdf6f2529",
  "Root": {
    "id": "8b0184ab-afca-426b-9625-8c2fdf6f2529",
    "alive": true,
    "content": [
      "77c61b8d-22b8-4a09-9d18-6f8ee5bc4059",
      "0355a915-7fbc-4e9d-9125-2601cc0860cd",
      "ef87f1ae-e43d-46e7-aec2-0467d159431d",
      "6b77679e-e652-4166-a07e-328fd81d21d5",
      "d4d47e7c-37c8-4b81-b130-5909d32d5b3b",
      "684382c9-7420-48d5-8f4f-237d06f98fcf",
      "a6bbdcf3-fd54-4a17-bfdf-12dc9dc8bf73",
      "d0c7c340-3c24-4d19-abf0-45a2eb47c8b5"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1549528668438,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1550213700000,
    "parent_id": "f0c07076-1721-4628-bc3b-9d40618aeb3a",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Fast Asymmetric File Encryption"
        ]
      ]
    },
    "type": "page",
    "version": 40,
    "content_resolved": [
      {
        "id": "77c61b8d-22b8-4a09-9d18-6f8ee5bc4059",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1549528668432,
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1549528668432,
        "parent_id": "8b0184ab-afca-426b-9625-8c2fdf6f2529",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Asymmetric encryption is often regarded as preferable to Symmetric encryption for transferring messages to other parties. This is mainly because it negates many of the risks related to the exchange of a shared key and ensures that whilst anyone with the public key can encrypt a message for the intended recipient, only that recipient can decrypt it. Unfortunately the major down-side of asymmetric encryption algorithms is that they are significantly slower than their symmetric cousins. As such the asymmetric encryption of files, especially large ones, can often be a very computationally intensive process."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Asymmetric encryption is often regarded as preferable to Symmetric encryption for transferring messages to other parties. This is mainly because it negates many of the risks related to the exchange of a shared key and ensures that whilst anyone with the public key can encrypt a message for the intended recipient, only that recipient can decrypt it. Unfortunately the major down-side of asymmetric encryption algorithms is that they are significantly slower than their symmetric cousins. As such the asymmetric encryption of files, especially large ones, can often be a very computationally intensive process."
          }
        ]
      },
      {
        "id": "0355a915-7fbc-4e9d-9125-2601cc0860cd",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1549528668435,
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1549528668435,
        "parent_id": "8b0184ab-afca-426b-9625-8c2fdf6f2529",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "In order to provide both security AND performance, a hybrid approach can be taken. This entails the cryptographically random generation of a key and initialization vector for "
            ],
            [
              "Symmetric",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " encryption. These values are then encrypted using an "
            ],
            [
              "Asymmetric",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " algorithm and written to the output file, before being used to encrypt the source data "
            ],
            [
              "Symmetrically",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " and appending it to the output."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "In order to provide both security AND performance, a hybrid approach can be taken. This entails the cryptographically random generation of a key and initialization vector for "
          },
          {
            "Text": "Symmetric",
            "AttrFlags": 4
          },
          {
            "Text": " encryption. These values are then encrypted using an "
          },
          {
            "Text": "Asymmetric",
            "AttrFlags": 4
          },
          {
            "Text": " algorithm and written to the output file, before being used to encrypt the source data "
          },
          {
            "Text": "Symmetrically",
            "AttrFlags": 4
          },
          {
            "Text": " and appending it to the output."
          }
        ]
      },
      {
        "id": "ef87f1ae-e43d-46e7-aec2-0467d159431d",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1549528668435,
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1549528668435,
        "parent_id": "8b0184ab-afca-426b-9625-8c2fdf6f2529",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "This approach provides a high degree of both performance and security, in that the data is encrypted using a symmetric algorithm (fast) and the key and iv, both randomly generated (secure) are encrypted by an asymmetric algorithm (secure). It also has the added advantage that the same payload encrypted on different occasions will have very different cyphertext, because the symmetric keys are randomly generated each time."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "This approach provides a high degree of both performance and security, in that the data is encrypted using a symmetric algorithm (fast) and the key and iv, both randomly generated (secure) are encrypted by an asymmetric algorithm (secure). It also has the added advantage that the same payload encrypted on different occasions will have very different cyphertext, because the symmetric keys are randomly generated each time."
          }
        ]
      },
      {
        "id": "6b77679e-e652-4166-a07e-328fd81d21d5",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1549528668435,
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1549528668435,
        "parent_id": "8b0184ab-afca-426b-9625-8c2fdf6f2529",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The following class demonstrates asymmetric encryption of strings and byte arrays, as well as hybrid file encryption."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The following class demonstrates asymmetric encryption of strings and byte arrays, as well as hybrid file encryption."
          }
        ]
      },
      {
        "id": "d4d47e7c-37c8-4b81-b130-5909d32d5b3b",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1549528668435,
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550213640000,
        "parent_id": "8b0184ab-afca-426b-9625-8c2fdf6f2529",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "C#"
            ]
          ],
          "title": [
            [
              "public static class AsymmetricProvider\n{\n    #region Key Generation\n    public class KeyPair\n    {\n        public string PublicKey { get; set; }\n        public string PrivateKey { get; set; }\n    }\n\n    public static KeyPair GenerateNewKeyPair(int keySize = 4096)\n    {\n        // KeySize is measured in bits. 1024 is the default, 2048 is better, 4096 is more robust but takes a fair bit longer to generate.\n        using (var rsa = new RSACryptoServiceProvider(keySize))\n        {\n            return new KeyPair {PublicKey = rsa.ToXmlString(false), PrivateKey = rsa.ToXmlString(true)};\n        }\n    }\n\n    #endregion\n\n    #region Asymmetric Data Encryption and Decryption\n\n    public static byte[] EncryptData(byte[] data, string publicKey)\n    {\n        using (var asymmetricProvider = new RSACryptoServiceProvider())\n        {\n            asymmetricProvider.FromXmlString(publicKey);\n            return asymmetricProvider.Encrypt(data, true);\n        }\n    }\n\n    public static byte[] DecryptData(byte[] data, string publicKey)\n    {\n        using (var asymmetricProvider = new RSACryptoServiceProvider())\n        {\n            asymmetricProvider.FromXmlString(publicKey);\n            if (asymmetricProvider.PublicOnly)\n                throw new Exception(\"The key provided is a public key and does not contain the private key elements required for decryption\");\n            return asymmetricProvider.Decrypt(data, true);\n        }\n    }\n\n    public static string EncryptString(string value, string publicKey)\n    {\n        return Convert.ToBase64String(EncryptData(Encoding.UTF8.GetBytes(value), publicKey));\n    }\n\n    public static string DecryptString(string value, string privateKey)\n    {\n        return Encoding.UTF8.GetString(EncryptData(Convert.FromBase64String(value), privateKey));\n    }\n\n    #endregion\n\n    #region Hybrid File Encryption and Decription\n\n    public static void EncryptFile(string inputFilePath, string outputFilePath, string publicKey)\n    {\n        using (var symmetricCypher = new AesManaged())\n        {\n            // Generate random key and IV for symmetric encryption\n            var key = new byte[symmetricCypher.KeySize / 8];\n            var iv = new byte[symmetricCypher.BlockSize / 8];\n            using (var rng = new RNGCryptoServiceProvider())\n            {\n                rng.GetBytes(key);\n                rng.GetBytes(iv);\n            }\n\n            // Encrypt the symmetric key and IV\n            var buf = new byte[key.Length + iv.Length];\n            Array.Copy(key, buf, key.Length);\n            Array.Copy(iv, 0, buf, key.Length, iv.Length);\n            buf = EncryptData(buf, publicKey);\n\n            var bufLen = BitConverter.GetBytes(buf.Length);\n\n            // Symmetrically encrypt the data and write it to the file, along with the encrypted key and iv\n            using (var cypherKey = symmetricCypher.CreateEncryptor(key, iv))\n            using (var fsIn = new FileStream(inputFilePath, FileMode.Open))\n            using (var fsOut = new FileStream(outputFilePath, FileMode.Create))\n            using (var cs = new CryptoStream(fsOut, cypherKey, CryptoStreamMode.Write))\n            {\n                fsOut.Write(bufLen,0, bufLen.Length);\n                fsOut.Write(buf, 0, buf.Length);\n                fsIn.CopyTo(cs);\n            }\n        }\n    }\n\n    public static void DecryptFile(string inputFilePath, string outputFilePath, string privateKey)\n    {\n        using (var symmetricCypher = new AesManaged())\n        using (var fsIn = new FileStream(inputFilePath, FileMode.Open))\n        {\n            // Determine the length of the encrypted key and IV\n            var buf = new byte[sizeof(int)];\n            fsIn.Read(buf, 0, buf.Length);\n            var bufLen = BitConverter.ToInt32(buf, 0);\n\n            // Read the encrypted key and IV data from the file and decrypt using the asymmetric algorithm\n            buf = new byte[bufLen];\n            fsIn.Read(buf, 0, buf.Length);\n            buf = DecryptData(buf, privateKey);\n\n            var key = new byte[symmetricCypher.KeySize / 8];\n            var iv = new byte[symmetricCypher.BlockSize / 8];\n            Array.Copy(buf, key, key.Length);\n            Array.Copy(buf, key.Length, iv, 0, iv.Length);\n\n            // Decript the file data using the symmetric algorithm\n            using (var cypherKey = symmetricCypher.CreateDecryptor(key, iv))\n            using (var fsOut = new FileStream(outputFilePath, FileMode.Create))\n            using (var cs = new CryptoStream(fsOut, cypherKey, CryptoStreamMode.Write))\n            {\n                fsIn.CopyTo(cs);\n            }\n        }\n    }\n\n    #endregion\n\n    #region Key Storage\n\n    public static void WritePublicKey(string publicKeyFilePath, string publicKey)\n    {\n        File.WriteAllText(publicKeyFilePath, publicKey);\n    }\n    public static string ReadPublicKey(string publicKeyFilePath)\n    {\n        return File.ReadAllText(publicKeyFilePath);\n    }\n\n    private const string SymmetricSalt = \"Stack_Overflow!\"; // Change me!\n\n    public static string ReadPrivateKey(string privateKeyFilePath, string password)\n    {\n        var salt = Encoding.UTF8.GetBytes(SymmetricSalt);\n        var cypherText = File.ReadAllBytes(privateKeyFilePath);\n\n        using (var cypher = new AesManaged())\n        {\n            var pdb = new Rfc2898DeriveBytes(password, salt);\n            var key = pdb.GetBytes(cypher.KeySize / 8);\n            var iv = pdb.GetBytes(cypher.BlockSize / 8);\n\n            using (var decryptor = cypher.CreateDecryptor(key, iv))\n            using (var msDecrypt = new MemoryStream(cypherText))\n            using (var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))\n            using (var srDecrypt = new StreamReader(csDecrypt))\n            {\n                return srDecrypt.ReadToEnd();\n            }\n        }\n    }\n\n    public static void WritePrivateKey(string privateKeyFilePath, string privateKey, string password)\n    {\n        var salt = Encoding.UTF8.GetBytes(SymmetricSalt);\n        using (var cypher = new AesManaged())\n        {\n            var pdb = new Rfc2898DeriveBytes(password, salt);\n            var key = pdb.GetBytes(cypher.KeySize / 8);\n            var iv = pdb.GetBytes(cypher.BlockSize / 8);\n\n            using (var encryptor = cypher.CreateEncryptor(key, iv))\n            using (var fsEncrypt = new FileStream(privateKeyFilePath, FileMode.Create))\n            using (var csEncrypt = new CryptoStream(fsEncrypt, encryptor, CryptoStreamMode.Write))\n            using (var swEncrypt = new StreamWriter(csEncrypt))\n            {\n                swEncrypt.Write(privateKey);\n            }\n        }\n    }\n\n    #endregion\n}"
            ]
          ]
        },
        "type": "code",
        "version": 7,
        "code": "public static class AsymmetricProvider\n{\n    #region Key Generation\n    public class KeyPair\n    {\n        public string PublicKey { get; set; }\n        public string PrivateKey { get; set; }\n    }\n\n    public static KeyPair GenerateNewKeyPair(int keySize = 4096)\n    {\n        // KeySize is measured in bits. 1024 is the default, 2048 is better, 4096 is more robust but takes a fair bit longer to generate.\n        using (var rsa = new RSACryptoServiceProvider(keySize))\n        {\n            return new KeyPair {PublicKey = rsa.ToXmlString(false), PrivateKey = rsa.ToXmlString(true)};\n        }\n    }\n\n    #endregion\n\n    #region Asymmetric Data Encryption and Decryption\n\n    public static byte[] EncryptData(byte[] data, string publicKey)\n    {\n        using (var asymmetricProvider = new RSACryptoServiceProvider())\n        {\n            asymmetricProvider.FromXmlString(publicKey);\n            return asymmetricProvider.Encrypt(data, true);\n        }\n    }\n\n    public static byte[] DecryptData(byte[] data, string publicKey)\n    {\n        using (var asymmetricProvider = new RSACryptoServiceProvider())\n        {\n            asymmetricProvider.FromXmlString(publicKey);\n            if (asymmetricProvider.PublicOnly)\n                throw new Exception(\"The key provided is a public key and does not contain the private key elements required for decryption\");\n            return asymmetricProvider.Decrypt(data, true);\n        }\n    }\n\n    public static string EncryptString(string value, string publicKey)\n    {\n        return Convert.ToBase64String(EncryptData(Encoding.UTF8.GetBytes(value), publicKey));\n    }\n\n    public static string DecryptString(string value, string privateKey)\n    {\n        return Encoding.UTF8.GetString(EncryptData(Convert.FromBase64String(value), privateKey));\n    }\n\n    #endregion\n\n    #region Hybrid File Encryption and Decription\n\n    public static void EncryptFile(string inputFilePath, string outputFilePath, string publicKey)\n    {\n        using (var symmetricCypher = new AesManaged())\n        {\n            // Generate random key and IV for symmetric encryption\n            var key = new byte[symmetricCypher.KeySize / 8];\n            var iv = new byte[symmetricCypher.BlockSize / 8];\n            using (var rng = new RNGCryptoServiceProvider())\n            {\n                rng.GetBytes(key);\n                rng.GetBytes(iv);\n            }\n\n            // Encrypt the symmetric key and IV\n            var buf = new byte[key.Length + iv.Length];\n            Array.Copy(key, buf, key.Length);\n            Array.Copy(iv, 0, buf, key.Length, iv.Length);\n            buf = EncryptData(buf, publicKey);\n\n            var bufLen = BitConverter.GetBytes(buf.Length);\n\n            // Symmetrically encrypt the data and write it to the file, along with the encrypted key and iv\n            using (var cypherKey = symmetricCypher.CreateEncryptor(key, iv))\n            using (var fsIn = new FileStream(inputFilePath, FileMode.Open))\n            using (var fsOut = new FileStream(outputFilePath, FileMode.Create))\n            using (var cs = new CryptoStream(fsOut, cypherKey, CryptoStreamMode.Write))\n            {\n                fsOut.Write(bufLen,0, bufLen.Length);\n                fsOut.Write(buf, 0, buf.Length);\n                fsIn.CopyTo(cs);\n            }\n        }\n    }\n\n    public static void DecryptFile(string inputFilePath, string outputFilePath, string privateKey)\n    {\n        using (var symmetricCypher = new AesManaged())\n        using (var fsIn = new FileStream(inputFilePath, FileMode.Open))\n        {\n            // Determine the length of the encrypted key and IV\n            var buf = new byte[sizeof(int)];\n            fsIn.Read(buf, 0, buf.Length);\n            var bufLen = BitConverter.ToInt32(buf, 0);\n\n            // Read the encrypted key and IV data from the file and decrypt using the asymmetric algorithm\n            buf = new byte[bufLen];\n            fsIn.Read(buf, 0, buf.Length);\n            buf = DecryptData(buf, privateKey);\n\n            var key = new byte[symmetricCypher.KeySize / 8];\n            var iv = new byte[symmetricCypher.BlockSize / 8];\n            Array.Copy(buf, key, key.Length);\n            Array.Copy(buf, key.Length, iv, 0, iv.Length);\n\n            // Decript the file data using the symmetric algorithm\n            using (var cypherKey = symmetricCypher.CreateDecryptor(key, iv))\n            using (var fsOut = new FileStream(outputFilePath, FileMode.Create))\n            using (var cs = new CryptoStream(fsOut, cypherKey, CryptoStreamMode.Write))\n            {\n                fsIn.CopyTo(cs);\n            }\n        }\n    }\n\n    #endregion\n\n    #region Key Storage\n\n    public static void WritePublicKey(string publicKeyFilePath, string publicKey)\n    {\n        File.WriteAllText(publicKeyFilePath, publicKey);\n    }\n    public static string ReadPublicKey(string publicKeyFilePath)\n    {\n        return File.ReadAllText(publicKeyFilePath);\n    }\n\n    private const string SymmetricSalt = \"Stack_Overflow!\"; // Change me!\n\n    public static string ReadPrivateKey(string privateKeyFilePath, string password)\n    {\n        var salt = Encoding.UTF8.GetBytes(SymmetricSalt);\n        var cypherText = File.ReadAllBytes(privateKeyFilePath);\n\n        using (var cypher = new AesManaged())\n        {\n            var pdb = new Rfc2898DeriveBytes(password, salt);\n            var key = pdb.GetBytes(cypher.KeySize / 8);\n            var iv = pdb.GetBytes(cypher.BlockSize / 8);\n\n            using (var decryptor = cypher.CreateDecryptor(key, iv))\n            using (var msDecrypt = new MemoryStream(cypherText))\n            using (var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))\n            using (var srDecrypt = new StreamReader(csDecrypt))\n            {\n                return srDecrypt.ReadToEnd();\n            }\n        }\n    }\n\n    public static void WritePrivateKey(string privateKeyFilePath, string privateKey, string password)\n    {\n        var salt = Encoding.UTF8.GetBytes(SymmetricSalt);\n        using (var cypher = new AesManaged())\n        {\n            var pdb = new Rfc2898DeriveBytes(password, salt);\n            var key = pdb.GetBytes(cypher.KeySize / 8);\n            var iv = pdb.GetBytes(cypher.BlockSize / 8);\n\n            using (var encryptor = cypher.CreateEncryptor(key, iv))\n            using (var fsEncrypt = new FileStream(privateKeyFilePath, FileMode.Create))\n            using (var csEncrypt = new CryptoStream(fsEncrypt, encryptor, CryptoStreamMode.Write))\n            using (var swEncrypt = new StreamWriter(csEncrypt))\n            {\n                swEncrypt.Write(privateKey);\n            }\n        }\n    }\n\n    #endregion\n}",
        "code_language": "C#"
      },
      {
        "id": "684382c9-7420-48d5-8f4f-237d06f98fcf",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1549528668437,
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1549528668437,
        "parent_id": "8b0184ab-afca-426b-9625-8c2fdf6f2529",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Example of use:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Example of use:"
          }
        ]
      },
      {
        "id": "a6bbdcf3-fd54-4a17-bfdf-12dc9dc8bf73",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1549528668437,
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550213700000,
        "parent_id": "8b0184ab-afca-426b-9625-8c2fdf6f2529",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "C#"
            ]
          ],
          "title": [
            [
              "private static void HybridCryptoTest(string privateKeyPath, string privateKeyPassword, string inputPath)\n{\n    // Setup the test\n    var publicKeyPath = Path.ChangeExtension(privateKeyPath, \".public\");\n    var outputPath = Path.Combine(Path.ChangeExtension(inputPath, \".enc\"));\n    var testPath = Path.Combine(Path.ChangeExtension(inputPath, \".test\"));\n\n    if (!File.Exists(privateKeyPath))\n    {\n        var keys = AsymmetricProvider.GenerateNewKeyPair(2048);\n        AsymmetricProvider.WritePublicKey(publicKeyPath, keys.PublicKey);\n        AsymmetricProvider.WritePrivateKey(privateKeyPath, keys.PrivateKey, privateKeyPassword);\n    }\n\n    // Encrypt the file\n    var publicKey = AsymmetricProvider.ReadPublicKey(publicKeyPath);\n    AsymmetricProvider.EncryptFile(inputPath, outputPath, publicKey);\n\n    // Decrypt it again to compare against the source file\n    var privateKey = AsymmetricProvider.ReadPrivateKey(privateKeyPath, privateKeyPassword);\n    AsymmetricProvider.DecryptFile(outputPath, testPath, privateKey);\n\n    // Check that the two files match\n    var source = File.ReadAllBytes(inputPath);\n    var dest = File.ReadAllBytes(testPath);\n\n    if (source.Length != dest.Length)\n        throw new Exception(\"Length does not match\");\n\n    if (source.Where((t, i) =\u003e t != dest[i]).Any())\n        throw new Exception(\"Data mismatch\");\n}"
            ]
          ]
        },
        "type": "code",
        "version": 8,
        "code": "private static void HybridCryptoTest(string privateKeyPath, string privateKeyPassword, string inputPath)\n{\n    // Setup the test\n    var publicKeyPath = Path.ChangeExtension(privateKeyPath, \".public\");\n    var outputPath = Path.Combine(Path.ChangeExtension(inputPath, \".enc\"));\n    var testPath = Path.Combine(Path.ChangeExtension(inputPath, \".test\"));\n\n    if (!File.Exists(privateKeyPath))\n    {\n        var keys = AsymmetricProvider.GenerateNewKeyPair(2048);\n        AsymmetricProvider.WritePublicKey(publicKeyPath, keys.PublicKey);\n        AsymmetricProvider.WritePrivateKey(privateKeyPath, keys.PrivateKey, privateKeyPassword);\n    }\n\n    // Encrypt the file\n    var publicKey = AsymmetricProvider.ReadPublicKey(publicKeyPath);\n    AsymmetricProvider.EncryptFile(inputPath, outputPath, publicKey);\n\n    // Decrypt it again to compare against the source file\n    var privateKey = AsymmetricProvider.ReadPrivateKey(privateKeyPath, privateKeyPassword);\n    AsymmetricProvider.DecryptFile(outputPath, testPath, privateKey);\n\n    // Check that the two files match\n    var source = File.ReadAllBytes(inputPath);\n    var dest = File.ReadAllBytes(testPath);\n\n    if (source.Length != dest.Length)\n        throw new Exception(\"Length does not match\");\n\n    if (source.Where((t, i) =\u003e t != dest[i]).Any())\n        throw new Exception(\"Data mismatch\");\n}",
        "code_language": "C#"
      },
      {
        "id": "d0c7c340-3c24-4d19-abf0-45a2eb47c8b5",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550213700000,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550213700000,
        "parent_id": "8b0184ab-afca-426b-9625-8c2fdf6f2529",
        "parent_table": "block",
        "type": "text",
        "version": 3
      }
    ],
    "title": "Fast Asymmetric File Encryption",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "",
      "version": 94
    }
  ],
  "Tables": null
}