{
  "ID": "dd1ae54d-e995-4540-acd7-c449f020f817",
  "Root": {
    "id": "dd1ae54d-e995-4540-acd7-c449f020f817",
    "alive": true,
    "content": [
      "72038a80-5352-4d5c-9b68-698d033576a0",
      "1f3da12e-b2a1-4f90-a944-6e92724ad8ef",
      "bd45842c-c092-4cb2-add5-ac018df6cce2",
      "f26a0ebc-534c-4521-bb72-1dfe640fb3af",
      "81789f7a-12db-4cd0-b774-51517a766270",
      "65ee84e2-52ea-45cb-b9f1-a44a84b4539b",
      "00ed1acc-0bc5-4b41-aa43-c26c03bcc92d",
      "bdef189f-16eb-4afa-b58f-2a9b414a9969",
      "45a32cec-f24f-4017-bd7e-60e228ee9f7c",
      "82795156-ea7a-4731-aefa-7b0f9b18205c",
      "aac7441b-2c1e-481f-9ff9-454896fc4af9"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1549528663355,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1550213460000,
    "parent_id": "f0c07076-1721-4628-bc3b-9d40618aeb3a",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Modern Examples of Symmetric Authenticated Encryption of a string"
        ]
      ]
    },
    "type": "page",
    "version": 13,
    "content_resolved": [
      {
        "id": "72038a80-5352-4d5c-9b68-698d033576a0",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1549528663347,
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1549528663347,
        "parent_id": "dd1ae54d-e995-4540-acd7-c449f020f817",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Cryptography is something very hard and after spending a lot of time reading different examples and seeing how easy it is to introduce some form of vulnerability I found an answer originally written by @jbtule that I think is very good. Enjoy reading:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Cryptography is something very hard and after spending a lot of time reading different examples and seeing how easy it is to introduce some form of vulnerability I found an answer originally written by @jbtule that I think is very good. Enjoy reading:"
          }
        ]
      },
      {
        "id": "1f3da12e-b2a1-4f90-a944-6e92724ad8ef",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1549528663352,
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1549528663352,
        "parent_id": "dd1ae54d-e995-4540-acd7-c449f020f817",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "“The general best practice for symmetric encryption is to use Authenticated Encryption with Associated Data (AEAD), however this isn’t a part of the standard .net crypto libraries. So the first example uses "
            ],
            [
              "AES256",
              [
                [
                  "a",
                  "http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"
                ]
              ]
            ],
            [
              " and then "
            ],
            [
              "HMAC256",
              [
                [
                  "a",
                  "http://en.wikipedia.org/wiki/HMAC"
                ]
              ]
            ],
            [
              ", a two step "
            ],
            [
              "Encrypt then MAC",
              [
                [
                  "a",
                  "http://crypto.stackexchange.com/a/205/1934"
                ]
              ]
            ],
            [
              ", which requires more overhead and more keys."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "“The general best practice for symmetric encryption is to use Authenticated Encryption with Associated Data (AEAD), however this isn’t a part of the standard .net crypto libraries. So the first example uses "
          },
          {
            "Text": "AES256",
            "Link": "http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"
          },
          {
            "Text": " and then "
          },
          {
            "Text": "HMAC256",
            "Link": "http://en.wikipedia.org/wiki/HMAC"
          },
          {
            "Text": ", a two step "
          },
          {
            "Text": "Encrypt then MAC",
            "Link": "http://crypto.stackexchange.com/a/205/1934"
          },
          {
            "Text": ", which requires more overhead and more keys."
          }
        ]
      },
      {
        "id": "bd45842c-c092-4cb2-add5-ac018df6cce2",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1549528663353,
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1549528663353,
        "parent_id": "dd1ae54d-e995-4540-acd7-c449f020f817",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The second example uses the simpler practice of AES256-"
            ],
            [
              "GCM",
              [
                [
                  "a",
                  "http://en.wikipedia.org/wiki/Galois/Counter_Mode"
                ]
              ]
            ],
            [
              " using the open source Bouncy Castle (via nuget)."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The second example uses the simpler practice of AES256-"
          },
          {
            "Text": "GCM",
            "Link": "http://en.wikipedia.org/wiki/Galois/Counter_Mode"
          },
          {
            "Text": " using the open source Bouncy Castle (via nuget)."
          }
        ]
      },
      {
        "id": "f26a0ebc-534c-4521-bb72-1dfe640fb3af",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1549528663353,
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1549528663353,
        "parent_id": "dd1ae54d-e995-4540-acd7-c449f020f817",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Both examples have a main function that takes secret message string, key(s) and an optional non-secret payload and return and authenticated encrypted string optionally prepended with the non-secret data. Ideally you would use these with 256bit key(s) randomly generated see "
            ],
            [
              "NewKey()",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Both examples have a main function that takes secret message string, key(s) and an optional non-secret payload and return and authenticated encrypted string optionally prepended with the non-secret data. Ideally you would use these with 256bit key(s) randomly generated see "
          },
          {
            "Text": "NewKey()",
            "AttrFlags": 2
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "id": "81789f7a-12db-4cd0-b774-51517a766270",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1549528663353,
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1549528663353,
        "parent_id": "dd1ae54d-e995-4540-acd7-c449f020f817",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Both examples also have a helper methods that use a string password to generate the keys. These helper methods are provided as a convenience to match up with other examples, however they are "
            ],
            [
              "far less secure",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " because the strength of the password is going to be "
            ],
            [
              "far weaker than a 256 bit key",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Both examples also have a helper methods that use a string password to generate the keys. These helper methods are provided as a convenience to match up with other examples, however they are "
          },
          {
            "Text": "far less secure",
            "AttrFlags": 4
          },
          {
            "Text": " because the strength of the password is going to be "
          },
          {
            "Text": "far weaker than a 256 bit key",
            "AttrFlags": 4
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "id": "65ee84e2-52ea-45cb-b9f1-a44a84b4539b",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1549528663353,
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1549528663353,
        "parent_id": "dd1ae54d-e995-4540-acd7-c449f020f817",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Update:",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " Added "
            ],
            [
              "byte[]",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " overloads, and only the "
            ],
            [
              "Gist",
              [
                [
                  "a",
                  "https://gist.github.com/4336842"
                ]
              ]
            ],
            [
              " has the full formatting with 4 spaces indent and api docs due to StackOverflow answer limits.”"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Update:",
            "AttrFlags": 1
          },
          {
            "Text": " Added "
          },
          {
            "Text": "byte[]",
            "AttrFlags": 2
          },
          {
            "Text": " overloads, and only the "
          },
          {
            "Text": "Gist",
            "Link": "https://gist.github.com/4336842"
          },
          {
            "Text": " has the full formatting with 4 spaces indent and api docs due to StackOverflow answer limits.”"
          }
        ]
      },
      {
        "id": "00ed1acc-0bc5-4b41-aa43-c26c03bcc92d",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1549528663354,
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1549528663354,
        "parent_id": "dd1ae54d-e995-4540-acd7-c449f020f817",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              ".NET Built-in Encrypt(AES)-Then-MAC(HMAC) ",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              "[Gist]",
              [
                [
                  "b"
                ],
                [
                  "a",
                  "https://gist.github.com/jbtule/4336842#file-aesthenhmac-cs"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": ".NET Built-in Encrypt(AES)-Then-MAC(HMAC) ",
            "AttrFlags": 1
          },
          {
            "Text": "[Gist]",
            "AttrFlags": 1,
            "Link": "https://gist.github.com/jbtule/4336842#file-aesthenhmac-cs"
          }
        ]
      },
      {
        "id": "bdef189f-16eb-4afa-b58f-2a9b414a9969",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1549528663354,
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550213460000,
        "parent_id": "dd1ae54d-e995-4540-acd7-c449f020f817",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "C#"
            ]
          ],
          "title": [
            [
              "/*\n * This work (Modern Encryption of a String C#, by James Tuley), \n * identified by James Tuley, is free of known copyright restrictions.\n * https://gist.github.com/4336842\n * http://creativecommons.org/publicdomain/mark/1.0/ \n */\n\nusing System;\nusing System.IO;\nusing System.Security.Cryptography;\nusing System.Text;\n\nnamespace Encryption\n{\n  public static class AESThenHMAC\n  {\n    private static readonly RandomNumberGenerator Random = RandomNumberGenerator.Create();\n    \n    //Preconfigured Encryption Parameters\n    public static readonly int BlockBitSize = 128;\n    public static readonly int KeyBitSize = 256;\n\n    //Preconfigured Password Key Derivation Parameters\n    public static readonly int SaltBitSize = 64;\n    public static readonly int Iterations = 10000;\n    public static readonly int MinPasswordLength = 12;\n\n    /// \u003csummary\u003e\n    /// Helper that generates a random key on each call.\n    /// \u003c/summary\u003e\n    /// \u003creturns\u003e\u003c/returns\u003e\n    public static byte[] NewKey()\n    {\n      var key = new byte[KeyBitSize / 8];\n      Random.GetBytes(key);\n      return key;\n    }\n\n    /// \u003csummary\u003e\n    /// Simple Encryption (AES) then Authentication (HMAC) for a UTF8 Message.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"secretMessage\"\u003eThe secret message.\u003c/param\u003e\n    /// \u003cparam name=\"cryptKey\"\u003eThe crypt key.\u003c/param\u003e\n    /// \u003cparam name=\"authKey\"\u003eThe auth key.\u003c/param\u003e\n    /// \u003cparam name=\"nonSecretPayload\"\u003e(Optional) Non-Secret Payload.\u003c/param\u003e\n    /// \u003creturns\u003e\n    /// Encrypted Message\n    /// \u003c/returns\u003e\n    /// \u003cexception cref=\"System.ArgumentException\"\u003eSecret Message Required!;secretMessage\u003c/exception\u003e\n    /// \u003cremarks\u003e\n    /// Adds overhead of (Optional-Payload + BlockSize(16) + Message-Padded-To-Blocksize +  HMac-Tag(32)) * 1.33 Base64\n    /// \u003c/remarks\u003e\n    public static string SimpleEncrypt(string secretMessage, byte[] cryptKey, byte[] authKey,\n                       byte[] nonSecretPayload = null)\n    {\n      if (string.IsNullOrEmpty(secretMessage))\n        throw new ArgumentException(\"Secret Message Required!\", \"secretMessage\");\n\n      var plainText = Encoding.UTF8.GetBytes(secretMessage);\n      var cipherText = SimpleEncrypt(plainText, cryptKey, authKey, nonSecretPayload);\n      return Convert.ToBase64String(cipherText);\n    }\n\n    /// \u003csummary\u003e\n    /// Simple Authentication (HMAC) then Decryption (AES) for a secrets UTF8 Message.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"encryptedMessage\"\u003eThe encrypted message.\u003c/param\u003e\n    /// \u003cparam name=\"cryptKey\"\u003eThe crypt key.\u003c/param\u003e\n    /// \u003cparam name=\"authKey\"\u003eThe auth key.\u003c/param\u003e\n    /// \u003cparam name=\"nonSecretPayloadLength\"\u003eLength of the non secret payload.\u003c/param\u003e\n    /// \u003creturns\u003e\n    /// Decrypted Message\n    /// \u003c/returns\u003e\n    /// \u003cexception cref=\"System.ArgumentException\"\u003eEncrypted Message Required!;encryptedMessage\u003c/exception\u003e\n    public static string SimpleDecrypt(string encryptedMessage, byte[] cryptKey, byte[] authKey,\n                       int nonSecretPayloadLength = 0)\n    {\n      if (string.IsNullOrWhiteSpace(encryptedMessage))\n        throw new ArgumentException(\"Encrypted Message Required!\", \"encryptedMessage\");\n\n      var cipherText = Convert.FromBase64String(encryptedMessage);\n      var plainText = SimpleDecrypt(cipherText, cryptKey, authKey, nonSecretPayloadLength);\n      return plainText == null ? null : Encoding.UTF8.GetString(plainText);\n    }\n\n    /// \u003csummary\u003e\n    /// Simple Encryption (AES) then Authentication (HMAC) of a UTF8 message\n    /// using Keys derived from a Password (PBKDF2).\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"secretMessage\"\u003eThe secret message.\u003c/param\u003e\n    /// \u003cparam name=\"password\"\u003eThe password.\u003c/param\u003e\n    /// \u003cparam name=\"nonSecretPayload\"\u003eThe non secret payload.\u003c/param\u003e\n    /// \u003creturns\u003e\n    /// Encrypted Message\n    /// \u003c/returns\u003e\n    /// \u003cexception cref=\"System.ArgumentException\"\u003epassword\u003c/exception\u003e\n    /// \u003cremarks\u003e\n    /// Significantly less secure than using random binary keys.\n    /// Adds additional non secret payload for key generation parameters.\n    /// \u003c/remarks\u003e\n    public static string SimpleEncryptWithPassword(string secretMessage, string password,\n                             byte[] nonSecretPayload = null)\n    {\n      if (string.IsNullOrEmpty(secretMessage))\n        throw new ArgumentException(\"Secret Message Required!\", \"secretMessage\");\n\n      var plainText = Encoding.UTF8.GetBytes(secretMessage);\n      var cipherText = SimpleEncryptWithPassword(plainText, password, nonSecretPayload);\n      return Convert.ToBase64String(cipherText);\n    }\n\n    /// \u003csummary\u003e\n    /// Simple Authentication (HMAC) and then Descryption (AES) of a UTF8 Message\n    /// using keys derived from a password (PBKDF2). \n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"encryptedMessage\"\u003eThe encrypted message.\u003c/param\u003e\n    /// \u003cparam name=\"password\"\u003eThe password.\u003c/param\u003e\n    /// \u003cparam name=\"nonSecretPayloadLength\"\u003eLength of the non secret payload.\u003c/param\u003e\n    /// \u003creturns\u003e\n    /// Decrypted Message\n    /// \u003c/returns\u003e\n    /// \u003cexception cref=\"System.ArgumentException\"\u003eEncrypted Message Required!;encryptedMessage\u003c/exception\u003e\n    /// \u003cremarks\u003e\n    /// Significantly less secure than using random binary keys.\n    /// \u003c/remarks\u003e\n    public static string SimpleDecryptWithPassword(string encryptedMessage, string password,\n                             int nonSecretPayloadLength = 0)\n    {\n      if (string.IsNullOrWhiteSpace(encryptedMessage))\n        throw new ArgumentException(\"Encrypted Message Required!\", \"encryptedMessage\");\n\n      var cipherText = Convert.FromBase64String(encryptedMessage);\n      var plainText = SimpleDecryptWithPassword(cipherText, password, nonSecretPayloadLength);\n      return plainText == null ? null : Encoding.UTF8.GetString(plainText);\n    }\n\n    public static byte[] SimpleEncrypt(byte[] secretMessage, byte[] cryptKey, byte[] authKey, byte[] nonSecretPayload = null)\n    {\n      //User Error Checks\n      if (cryptKey == null || cryptKey.Length != KeyBitSize / 8)\n        throw new ArgumentException(String.Format(\"Key needs to be {0} bit!\", KeyBitSize), \"cryptKey\");\n\n      if (authKey == null || authKey.Length != KeyBitSize / 8)\n        throw new ArgumentException(String.Format(\"Key needs to be {0} bit!\", KeyBitSize), \"authKey\");\n\n      if (secretMessage == null || secretMessage.Length \u003c 1)\n        throw new ArgumentException(\"Secret Message Required!\", \"secretMessage\");\n\n      //non-secret payload optional\n      nonSecretPayload = nonSecretPayload ?? new byte[] { };\n\n      byte[] cipherText;\n      byte[] iv;\n\n      using (var aes = new AesManaged\n      {\n        KeySize = KeyBitSize,\n        BlockSize = BlockBitSize,\n        Mode = CipherMode.CBC,\n        Padding = PaddingMode.PKCS7\n      })\n      {\n\n        //Use random IV\n        aes.GenerateIV();\n        iv = aes.IV;\n\n        using (var encrypter = aes.CreateEncryptor(cryptKey, iv))\n        using (var cipherStream = new MemoryStream())\n        {\n          using (var cryptoStream = new CryptoStream(cipherStream, encrypter, CryptoStreamMode.Write))\n          using (var binaryWriter = new BinaryWriter(cryptoStream))\n          {\n            //Encrypt Data\n            binaryWriter.Write(secretMessage);\n          }\n\n          cipherText = cipherStream.ToArray();\n        }\n\n      }\n\n      //Assemble encrypted message and add authentication\n      using (var hmac = new HMACSHA256(authKey))\n      using (var encryptedStream = new MemoryStream())\n      {\n        using (var binaryWriter = new BinaryWriter(encryptedStream))\n        {\n          //Prepend non-secret payload if any\n          binaryWriter.Write(nonSecretPayload);\n          //Prepend IV\n          binaryWriter.Write(iv);\n          //Write Ciphertext\n          binaryWriter.Write(cipherText);\n          binaryWriter.Flush();\n\n          //Authenticate all data\n          var tag = hmac.ComputeHash(encryptedStream.ToArray());\n          //Postpend tag\n          binaryWriter.Write(tag);\n        }\n        return encryptedStream.ToArray();\n      }\n\n    }\n\n    public static byte[] SimpleDecrypt(byte[] encryptedMessage, byte[] cryptKey, byte[] authKey, int nonSecretPayloadLength = 0)\n    {\n\n      //Basic Usage Error Checks\n      if (cryptKey == null || cryptKey.Length != KeyBitSize / 8)\n        throw new ArgumentException(String.Format(\"CryptKey needs to be {0} bit!\", KeyBitSize), \"cryptKey\");\n\n      if (authKey == null || authKey.Length != KeyBitSize / 8)\n        throw new ArgumentException(String.Format(\"AuthKey needs to be {0} bit!\", KeyBitSize), \"authKey\");\n\n      if (encryptedMessage == null || encryptedMessage.Length == 0)\n        throw new ArgumentException(\"Encrypted Message Required!\", \"encryptedMessage\");\n\n      using (var hmac = new HMACSHA256(authKey))\n      {\n        var sentTag = new byte[hmac.HashSize / 8];\n        //Calculate Tag\n        var calcTag = hmac.ComputeHash(encryptedMessage, 0, encryptedMessage.Length - sentTag.Length);\n        var ivLength = (BlockBitSize / 8);\n\n        //if message length is to small just return null\n        if (encryptedMessage.Length \u003c sentTag.Length + nonSecretPayloadLength + ivLength)\n          return null;\n\n        //Grab Sent Tag\n        Array.Copy(encryptedMessage, encryptedMessage.Length - sentTag.Length, sentTag, 0, sentTag.Length);\n\n        //Compare Tag with constant time comparison\n        var compare = 0;\n        for (var i = 0; i \u003c sentTag.Length; i++)\n          compare |= sentTag[i] ^ calcTag[i]; \n\n        //if message doesn't authenticate return null\n        if (compare != 0)\n          return null;\n\n        using (var aes = new AesManaged\n        {\n          KeySize = KeyBitSize,\n          BlockSize = BlockBitSize,\n          Mode = CipherMode.CBC,\n          Padding = PaddingMode.PKCS7\n        })\n        {\n\n          //Grab IV from message\n          var iv = new byte[ivLength];\n          Array.Copy(encryptedMessage, nonSecretPayloadLength, iv, 0, iv.Length);\n\n          using (var decrypter = aes.CreateDecryptor(cryptKey, iv))\n          using (var plainTextStream = new MemoryStream())\n          {\n            using (var decrypterStream = new CryptoStream(plainTextStream, decrypter, CryptoStreamMode.Write))\n            using (var binaryWriter = new BinaryWriter(decrypterStream))\n            {\n              //Decrypt Cipher Text from Message\n              binaryWriter.Write(\n                encryptedMessage,\n                nonSecretPayloadLength + iv.Length,\n                encryptedMessage.Length - nonSecretPayloadLength - iv.Length - sentTag.Length\n              );\n            }\n            //Return Plain Text\n            return plainTextStream.ToArray();\n          }\n        }\n      }\n    }\n\n    public static byte[] SimpleEncryptWithPassword(byte[] secretMessage, string password, byte[] nonSecretPayload = null)\n    {\n      nonSecretPayload = nonSecretPayload ?? new byte[] {};\n\n      //User Error Checks\n      if (string.IsNullOrWhiteSpace(password) || password.Length \u003c MinPasswordLength)\n        throw new ArgumentException(String.Format(\"Must have a password of at least {0} characters!\", MinPasswordLength), \"password\");\n\n      if (secretMessage == null || secretMessage.Length ==0)\n        throw new ArgumentException(\"Secret Message Required!\", \"secretMessage\");\n\n      var payload = new byte[((SaltBitSize / 8) * 2) + nonSecretPayload.Length];\n\n      Array.Copy(nonSecretPayload, payload, nonSecretPayload.Length);\n      int payloadIndex = nonSecretPayload.Length;\n\n      byte[] cryptKey;\n      byte[] authKey;\n      //Use Random Salt to prevent pre-generated weak password attacks.\n      using (var generator = new Rfc2898DeriveBytes(password, SaltBitSize / 8, Iterations))\n      {\n        var salt = generator.Salt;\n\n        //Generate Keys\n        cryptKey = generator.GetBytes(KeyBitSize / 8);\n\n        //Create Non Secret Payload\n        Array.Copy(salt, 0, payload, payloadIndex, salt.Length);\n        payloadIndex += salt.Length;\n      }\n\n      //Deriving separate key, might be less efficient than using HKDF, \n      //but now compatible with RNEncryptor which had a very similar wireformat and requires less code than HKDF.\n      using (var generator = new Rfc2898DeriveBytes(password, SaltBitSize / 8, Iterations))\n      {\n        var salt = generator.Salt;\n\n        //Generate Keys\n        authKey = generator.GetBytes(KeyBitSize / 8);\n\n        //Create Rest of Non Secret Payload\n        Array.Copy(salt, 0, payload, payloadIndex, salt.Length);\n      }\n\n      return SimpleEncrypt(secretMessage, cryptKey, authKey, payload);\n    }\n\n    public static byte[] SimpleDecryptWithPassword(byte[] encryptedMessage, string password, int nonSecretPayloadLength = 0)\n    {\n      //User Error Checks\n      if (string.IsNullOrWhiteSpace(password) || password.Length \u003c MinPasswordLength)\n        throw new ArgumentException(String.Format(\"Must have a password of at least {0} characters!\", MinPasswordLength), \"password\");\n\n      if (encryptedMessage == null || encryptedMessage.Length == 0)\n        throw new ArgumentException(\"Encrypted Message Required!\", \"encryptedMessage\");\n\n      var cryptSalt = new byte[SaltBitSize / 8];\n      var authSalt = new byte[SaltBitSize / 8];\n\n      //Grab Salt from Non-Secret Payload\n      Array.Copy(encryptedMessage, nonSecretPayloadLength, cryptSalt, 0, cryptSalt.Length);\n      Array.Copy(encryptedMessage, nonSecretPayloadLength + cryptSalt.Length, authSalt, 0, authSalt.Length);\n\n      byte[] cryptKey;\n      byte[] authKey;\n\n      //Generate crypt key\n      using (var generator = new Rfc2898DeriveBytes(password, cryptSalt, Iterations))\n      {\n        cryptKey = generator.GetBytes(KeyBitSize / 8);\n      }\n      //Generate auth key\n      using (var generator = new Rfc2898DeriveBytes(password, authSalt, Iterations))\n      {\n        authKey = generator.GetBytes(KeyBitSize / 8);\n      }\n\n      return SimpleDecrypt(encryptedMessage, cryptKey, authKey, cryptSalt.Length + authSalt.Length + nonSecretPayloadLength);\n    }\n  }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 3,
        "code": "/*\n * This work (Modern Encryption of a String C#, by James Tuley), \n * identified by James Tuley, is free of known copyright restrictions.\n * https://gist.github.com/4336842\n * http://creativecommons.org/publicdomain/mark/1.0/ \n */\n\nusing System;\nusing System.IO;\nusing System.Security.Cryptography;\nusing System.Text;\n\nnamespace Encryption\n{\n  public static class AESThenHMAC\n  {\n    private static readonly RandomNumberGenerator Random = RandomNumberGenerator.Create();\n    \n    //Preconfigured Encryption Parameters\n    public static readonly int BlockBitSize = 128;\n    public static readonly int KeyBitSize = 256;\n\n    //Preconfigured Password Key Derivation Parameters\n    public static readonly int SaltBitSize = 64;\n    public static readonly int Iterations = 10000;\n    public static readonly int MinPasswordLength = 12;\n\n    /// \u003csummary\u003e\n    /// Helper that generates a random key on each call.\n    /// \u003c/summary\u003e\n    /// \u003creturns\u003e\u003c/returns\u003e\n    public static byte[] NewKey()\n    {\n      var key = new byte[KeyBitSize / 8];\n      Random.GetBytes(key);\n      return key;\n    }\n\n    /// \u003csummary\u003e\n    /// Simple Encryption (AES) then Authentication (HMAC) for a UTF8 Message.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"secretMessage\"\u003eThe secret message.\u003c/param\u003e\n    /// \u003cparam name=\"cryptKey\"\u003eThe crypt key.\u003c/param\u003e\n    /// \u003cparam name=\"authKey\"\u003eThe auth key.\u003c/param\u003e\n    /// \u003cparam name=\"nonSecretPayload\"\u003e(Optional) Non-Secret Payload.\u003c/param\u003e\n    /// \u003creturns\u003e\n    /// Encrypted Message\n    /// \u003c/returns\u003e\n    /// \u003cexception cref=\"System.ArgumentException\"\u003eSecret Message Required!;secretMessage\u003c/exception\u003e\n    /// \u003cremarks\u003e\n    /// Adds overhead of (Optional-Payload + BlockSize(16) + Message-Padded-To-Blocksize +  HMac-Tag(32)) * 1.33 Base64\n    /// \u003c/remarks\u003e\n    public static string SimpleEncrypt(string secretMessage, byte[] cryptKey, byte[] authKey,\n                       byte[] nonSecretPayload = null)\n    {\n      if (string.IsNullOrEmpty(secretMessage))\n        throw new ArgumentException(\"Secret Message Required!\", \"secretMessage\");\n\n      var plainText = Encoding.UTF8.GetBytes(secretMessage);\n      var cipherText = SimpleEncrypt(plainText, cryptKey, authKey, nonSecretPayload);\n      return Convert.ToBase64String(cipherText);\n    }\n\n    /// \u003csummary\u003e\n    /// Simple Authentication (HMAC) then Decryption (AES) for a secrets UTF8 Message.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"encryptedMessage\"\u003eThe encrypted message.\u003c/param\u003e\n    /// \u003cparam name=\"cryptKey\"\u003eThe crypt key.\u003c/param\u003e\n    /// \u003cparam name=\"authKey\"\u003eThe auth key.\u003c/param\u003e\n    /// \u003cparam name=\"nonSecretPayloadLength\"\u003eLength of the non secret payload.\u003c/param\u003e\n    /// \u003creturns\u003e\n    /// Decrypted Message\n    /// \u003c/returns\u003e\n    /// \u003cexception cref=\"System.ArgumentException\"\u003eEncrypted Message Required!;encryptedMessage\u003c/exception\u003e\n    public static string SimpleDecrypt(string encryptedMessage, byte[] cryptKey, byte[] authKey,\n                       int nonSecretPayloadLength = 0)\n    {\n      if (string.IsNullOrWhiteSpace(encryptedMessage))\n        throw new ArgumentException(\"Encrypted Message Required!\", \"encryptedMessage\");\n\n      var cipherText = Convert.FromBase64String(encryptedMessage);\n      var plainText = SimpleDecrypt(cipherText, cryptKey, authKey, nonSecretPayloadLength);\n      return plainText == null ? null : Encoding.UTF8.GetString(plainText);\n    }\n\n    /// \u003csummary\u003e\n    /// Simple Encryption (AES) then Authentication (HMAC) of a UTF8 message\n    /// using Keys derived from a Password (PBKDF2).\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"secretMessage\"\u003eThe secret message.\u003c/param\u003e\n    /// \u003cparam name=\"password\"\u003eThe password.\u003c/param\u003e\n    /// \u003cparam name=\"nonSecretPayload\"\u003eThe non secret payload.\u003c/param\u003e\n    /// \u003creturns\u003e\n    /// Encrypted Message\n    /// \u003c/returns\u003e\n    /// \u003cexception cref=\"System.ArgumentException\"\u003epassword\u003c/exception\u003e\n    /// \u003cremarks\u003e\n    /// Significantly less secure than using random binary keys.\n    /// Adds additional non secret payload for key generation parameters.\n    /// \u003c/remarks\u003e\n    public static string SimpleEncryptWithPassword(string secretMessage, string password,\n                             byte[] nonSecretPayload = null)\n    {\n      if (string.IsNullOrEmpty(secretMessage))\n        throw new ArgumentException(\"Secret Message Required!\", \"secretMessage\");\n\n      var plainText = Encoding.UTF8.GetBytes(secretMessage);\n      var cipherText = SimpleEncryptWithPassword(plainText, password, nonSecretPayload);\n      return Convert.ToBase64String(cipherText);\n    }\n\n    /// \u003csummary\u003e\n    /// Simple Authentication (HMAC) and then Descryption (AES) of a UTF8 Message\n    /// using keys derived from a password (PBKDF2). \n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"encryptedMessage\"\u003eThe encrypted message.\u003c/param\u003e\n    /// \u003cparam name=\"password\"\u003eThe password.\u003c/param\u003e\n    /// \u003cparam name=\"nonSecretPayloadLength\"\u003eLength of the non secret payload.\u003c/param\u003e\n    /// \u003creturns\u003e\n    /// Decrypted Message\n    /// \u003c/returns\u003e\n    /// \u003cexception cref=\"System.ArgumentException\"\u003eEncrypted Message Required!;encryptedMessage\u003c/exception\u003e\n    /// \u003cremarks\u003e\n    /// Significantly less secure than using random binary keys.\n    /// \u003c/remarks\u003e\n    public static string SimpleDecryptWithPassword(string encryptedMessage, string password,\n                             int nonSecretPayloadLength = 0)\n    {\n      if (string.IsNullOrWhiteSpace(encryptedMessage))\n        throw new ArgumentException(\"Encrypted Message Required!\", \"encryptedMessage\");\n\n      var cipherText = Convert.FromBase64String(encryptedMessage);\n      var plainText = SimpleDecryptWithPassword(cipherText, password, nonSecretPayloadLength);\n      return plainText == null ? null : Encoding.UTF8.GetString(plainText);\n    }\n\n    public static byte[] SimpleEncrypt(byte[] secretMessage, byte[] cryptKey, byte[] authKey, byte[] nonSecretPayload = null)\n    {\n      //User Error Checks\n      if (cryptKey == null || cryptKey.Length != KeyBitSize / 8)\n        throw new ArgumentException(String.Format(\"Key needs to be {0} bit!\", KeyBitSize), \"cryptKey\");\n\n      if (authKey == null || authKey.Length != KeyBitSize / 8)\n        throw new ArgumentException(String.Format(\"Key needs to be {0} bit!\", KeyBitSize), \"authKey\");\n\n      if (secretMessage == null || secretMessage.Length \u003c 1)\n        throw new ArgumentException(\"Secret Message Required!\", \"secretMessage\");\n\n      //non-secret payload optional\n      nonSecretPayload = nonSecretPayload ?? new byte[] { };\n\n      byte[] cipherText;\n      byte[] iv;\n\n      using (var aes = new AesManaged\n      {\n        KeySize = KeyBitSize,\n        BlockSize = BlockBitSize,\n        Mode = CipherMode.CBC,\n        Padding = PaddingMode.PKCS7\n      })\n      {\n\n        //Use random IV\n        aes.GenerateIV();\n        iv = aes.IV;\n\n        using (var encrypter = aes.CreateEncryptor(cryptKey, iv))\n        using (var cipherStream = new MemoryStream())\n        {\n          using (var cryptoStream = new CryptoStream(cipherStream, encrypter, CryptoStreamMode.Write))\n          using (var binaryWriter = new BinaryWriter(cryptoStream))\n          {\n            //Encrypt Data\n            binaryWriter.Write(secretMessage);\n          }\n\n          cipherText = cipherStream.ToArray();\n        }\n\n      }\n\n      //Assemble encrypted message and add authentication\n      using (var hmac = new HMACSHA256(authKey))\n      using (var encryptedStream = new MemoryStream())\n      {\n        using (var binaryWriter = new BinaryWriter(encryptedStream))\n        {\n          //Prepend non-secret payload if any\n          binaryWriter.Write(nonSecretPayload);\n          //Prepend IV\n          binaryWriter.Write(iv);\n          //Write Ciphertext\n          binaryWriter.Write(cipherText);\n          binaryWriter.Flush();\n\n          //Authenticate all data\n          var tag = hmac.ComputeHash(encryptedStream.ToArray());\n          //Postpend tag\n          binaryWriter.Write(tag);\n        }\n        return encryptedStream.ToArray();\n      }\n\n    }\n\n    public static byte[] SimpleDecrypt(byte[] encryptedMessage, byte[] cryptKey, byte[] authKey, int nonSecretPayloadLength = 0)\n    {\n\n      //Basic Usage Error Checks\n      if (cryptKey == null || cryptKey.Length != KeyBitSize / 8)\n        throw new ArgumentException(String.Format(\"CryptKey needs to be {0} bit!\", KeyBitSize), \"cryptKey\");\n\n      if (authKey == null || authKey.Length != KeyBitSize / 8)\n        throw new ArgumentException(String.Format(\"AuthKey needs to be {0} bit!\", KeyBitSize), \"authKey\");\n\n      if (encryptedMessage == null || encryptedMessage.Length == 0)\n        throw new ArgumentException(\"Encrypted Message Required!\", \"encryptedMessage\");\n\n      using (var hmac = new HMACSHA256(authKey))\n      {\n        var sentTag = new byte[hmac.HashSize / 8];\n        //Calculate Tag\n        var calcTag = hmac.ComputeHash(encryptedMessage, 0, encryptedMessage.Length - sentTag.Length);\n        var ivLength = (BlockBitSize / 8);\n\n        //if message length is to small just return null\n        if (encryptedMessage.Length \u003c sentTag.Length + nonSecretPayloadLength + ivLength)\n          return null;\n\n        //Grab Sent Tag\n        Array.Copy(encryptedMessage, encryptedMessage.Length - sentTag.Length, sentTag, 0, sentTag.Length);\n\n        //Compare Tag with constant time comparison\n        var compare = 0;\n        for (var i = 0; i \u003c sentTag.Length; i++)\n          compare |= sentTag[i] ^ calcTag[i]; \n\n        //if message doesn't authenticate return null\n        if (compare != 0)\n          return null;\n\n        using (var aes = new AesManaged\n        {\n          KeySize = KeyBitSize,\n          BlockSize = BlockBitSize,\n          Mode = CipherMode.CBC,\n          Padding = PaddingMode.PKCS7\n        })\n        {\n\n          //Grab IV from message\n          var iv = new byte[ivLength];\n          Array.Copy(encryptedMessage, nonSecretPayloadLength, iv, 0, iv.Length);\n\n          using (var decrypter = aes.CreateDecryptor(cryptKey, iv))\n          using (var plainTextStream = new MemoryStream())\n          {\n            using (var decrypterStream = new CryptoStream(plainTextStream, decrypter, CryptoStreamMode.Write))\n            using (var binaryWriter = new BinaryWriter(decrypterStream))\n            {\n              //Decrypt Cipher Text from Message\n              binaryWriter.Write(\n                encryptedMessage,\n                nonSecretPayloadLength + iv.Length,\n                encryptedMessage.Length - nonSecretPayloadLength - iv.Length - sentTag.Length\n              );\n            }\n            //Return Plain Text\n            return plainTextStream.ToArray();\n          }\n        }\n      }\n    }\n\n    public static byte[] SimpleEncryptWithPassword(byte[] secretMessage, string password, byte[] nonSecretPayload = null)\n    {\n      nonSecretPayload = nonSecretPayload ?? new byte[] {};\n\n      //User Error Checks\n      if (string.IsNullOrWhiteSpace(password) || password.Length \u003c MinPasswordLength)\n        throw new ArgumentException(String.Format(\"Must have a password of at least {0} characters!\", MinPasswordLength), \"password\");\n\n      if (secretMessage == null || secretMessage.Length ==0)\n        throw new ArgumentException(\"Secret Message Required!\", \"secretMessage\");\n\n      var payload = new byte[((SaltBitSize / 8) * 2) + nonSecretPayload.Length];\n\n      Array.Copy(nonSecretPayload, payload, nonSecretPayload.Length);\n      int payloadIndex = nonSecretPayload.Length;\n\n      byte[] cryptKey;\n      byte[] authKey;\n      //Use Random Salt to prevent pre-generated weak password attacks.\n      using (var generator = new Rfc2898DeriveBytes(password, SaltBitSize / 8, Iterations))\n      {\n        var salt = generator.Salt;\n\n        //Generate Keys\n        cryptKey = generator.GetBytes(KeyBitSize / 8);\n\n        //Create Non Secret Payload\n        Array.Copy(salt, 0, payload, payloadIndex, salt.Length);\n        payloadIndex += salt.Length;\n      }\n\n      //Deriving separate key, might be less efficient than using HKDF, \n      //but now compatible with RNEncryptor which had a very similar wireformat and requires less code than HKDF.\n      using (var generator = new Rfc2898DeriveBytes(password, SaltBitSize / 8, Iterations))\n      {\n        var salt = generator.Salt;\n\n        //Generate Keys\n        authKey = generator.GetBytes(KeyBitSize / 8);\n\n        //Create Rest of Non Secret Payload\n        Array.Copy(salt, 0, payload, payloadIndex, salt.Length);\n      }\n\n      return SimpleEncrypt(secretMessage, cryptKey, authKey, payload);\n    }\n\n    public static byte[] SimpleDecryptWithPassword(byte[] encryptedMessage, string password, int nonSecretPayloadLength = 0)\n    {\n      //User Error Checks\n      if (string.IsNullOrWhiteSpace(password) || password.Length \u003c MinPasswordLength)\n        throw new ArgumentException(String.Format(\"Must have a password of at least {0} characters!\", MinPasswordLength), \"password\");\n\n      if (encryptedMessage == null || encryptedMessage.Length == 0)\n        throw new ArgumentException(\"Encrypted Message Required!\", \"encryptedMessage\");\n\n      var cryptSalt = new byte[SaltBitSize / 8];\n      var authSalt = new byte[SaltBitSize / 8];\n\n      //Grab Salt from Non-Secret Payload\n      Array.Copy(encryptedMessage, nonSecretPayloadLength, cryptSalt, 0, cryptSalt.Length);\n      Array.Copy(encryptedMessage, nonSecretPayloadLength + cryptSalt.Length, authSalt, 0, authSalt.Length);\n\n      byte[] cryptKey;\n      byte[] authKey;\n\n      //Generate crypt key\n      using (var generator = new Rfc2898DeriveBytes(password, cryptSalt, Iterations))\n      {\n        cryptKey = generator.GetBytes(KeyBitSize / 8);\n      }\n      //Generate auth key\n      using (var generator = new Rfc2898DeriveBytes(password, authSalt, Iterations))\n      {\n        authKey = generator.GetBytes(KeyBitSize / 8);\n      }\n\n      return SimpleDecrypt(encryptedMessage, cryptKey, authKey, cryptSalt.Length + authSalt.Length + nonSecretPayloadLength);\n    }\n  }\n}",
        "code_language": "C#"
      },
      {
        "id": "45a32cec-f24f-4017-bd7e-60e228ee9f7c",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1549528663355,
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1549528663355,
        "parent_id": "dd1ae54d-e995-4540-acd7-c449f020f817",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Bouncy Castle AES-GCM ",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              "[Gist]",
              [
                [
                  "b"
                ],
                [
                  "a",
                  "https://gist.github.com/jbtule/4336842#file-aesgcm-cs"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Bouncy Castle AES-GCM ",
            "AttrFlags": 1
          },
          {
            "Text": "[Gist]",
            "AttrFlags": 1,
            "Link": "https://gist.github.com/jbtule/4336842#file-aesgcm-cs"
          }
        ]
      },
      {
        "id": "82795156-ea7a-4731-aefa-7b0f9b18205c",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1549528663355,
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550213460000,
        "parent_id": "dd1ae54d-e995-4540-acd7-c449f020f817",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "C#"
            ]
          ],
          "title": [
            [
              "/*\n * This work (Modern Encryption of a String C#, by James Tuley), \n * identified by James Tuley, is free of known copyright restrictions.\n * https://gist.github.com/4336842\n * http://creativecommons.org/publicdomain/mark/1.0/ \n */\n\nusing System;\nusing System.IO;\nusing System.Text;\nusing Org.BouncyCastle.Crypto;\nusing Org.BouncyCastle.Crypto.Engines;\nusing Org.BouncyCastle.Crypto.Generators;\nusing Org.BouncyCastle.Crypto.Modes;\nusing Org.BouncyCastle.Crypto.Parameters;\nusing Org.BouncyCastle.Security;\nnamespace Encryption\n{\n\n  public static class AESGCM\n  {\n    private static readonly SecureRandom Random = new SecureRandom();\n\n    //Preconfigured Encryption Parameters\n    public static readonly int NonceBitSize = 128;\n    public static readonly int MacBitSize = 128;\n    public static readonly int KeyBitSize = 256;\n\n    //Preconfigured Password Key Derivation Parameters\n    public static readonly int SaltBitSize = 128;\n    public static readonly int Iterations = 10000;\n    public static readonly int MinPasswordLength = 12;\n\n\n    /// \u003csummary\u003e\n    /// Helper that generates a random new key on each call.\n    /// \u003c/summary\u003e\n    /// \u003creturns\u003e\u003c/returns\u003e\n    public static byte[] NewKey()\n    {\n      var key = new byte[KeyBitSize / 8];\n      Random.NextBytes(key);\n      return key;\n    }\n\n    /// \u003csummary\u003e\n    /// Simple Encryption And Authentication (AES-GCM) of a UTF8 string.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"secretMessage\"\u003eThe secret message.\u003c/param\u003e\n    /// \u003cparam name=\"key\"\u003eThe key.\u003c/param\u003e\n    /// \u003cparam name=\"nonSecretPayload\"\u003eOptional non-secret payload.\u003c/param\u003e\n    /// \u003creturns\u003e\n    /// Encrypted Message\n    /// \u003c/returns\u003e\n    /// \u003cexception cref=\"System.ArgumentException\"\u003eSecret Message Required!;secretMessage\u003c/exception\u003e\n    /// \u003cremarks\u003e\n    /// Adds overhead of (Optional-Payload + BlockSize(16) + Message +  HMac-Tag(16)) * 1.33 Base64\n    /// \u003c/remarks\u003e\n    public static string SimpleEncrypt(string secretMessage, byte[] key, byte[] nonSecretPayload = null)\n    {\n      if (string.IsNullOrEmpty(secretMessage))\n        throw new ArgumentException(\"Secret Message Required!\", \"secretMessage\");\n\n      var plainText = Encoding.UTF8.GetBytes(secretMessage);\n      var cipherText = SimpleEncrypt(plainText, key, nonSecretPayload);\n      return Convert.ToBase64String(cipherText);\n    }\n\n\n    /// \u003csummary\u003e\n    /// Simple Decryption \u0026 Authentication (AES-GCM) of a UTF8 Message\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"encryptedMessage\"\u003eThe encrypted message.\u003c/param\u003e\n    /// \u003cparam name=\"key\"\u003eThe key.\u003c/param\u003e\n    /// \u003cparam name=\"nonSecretPayloadLength\"\u003eLength of the optional non-secret payload.\u003c/param\u003e\n    /// \u003creturns\u003eDecrypted Message\u003c/returns\u003e\n    public static string SimpleDecrypt(string encryptedMessage, byte[] key, int nonSecretPayloadLength = 0)\n    {\n      if (string.IsNullOrEmpty(encryptedMessage))\n        throw new ArgumentException(\"Encrypted Message Required!\", \"encryptedMessage\");\n\n      var cipherText = Convert.FromBase64String(encryptedMessage);\n      var plainText = SimpleDecrypt(cipherText, key, nonSecretPayloadLength);\n      return plainText == null ? null : Encoding.UTF8.GetString(plainText);\n    }\n\n    /// \u003csummary\u003e\n    /// Simple Encryption And Authentication (AES-GCM) of a UTF8 String\n    /// using key derived from a password (PBKDF2).\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"secretMessage\"\u003eThe secret message.\u003c/param\u003e\n    /// \u003cparam name=\"password\"\u003eThe password.\u003c/param\u003e\n    /// \u003cparam name=\"nonSecretPayload\"\u003eThe non secret payload.\u003c/param\u003e\n    /// \u003creturns\u003e\n    /// Encrypted Message\n    /// \u003c/returns\u003e\n    /// \u003cremarks\u003e\n    /// Significantly less secure than using random binary keys.\n    /// Adds additional non secret payload for key generation parameters.\n    /// \u003c/remarks\u003e\n    public static string SimpleEncryptWithPassword(string secretMessage, string password,\n                             byte[] nonSecretPayload = null)\n    {\n      if (string.IsNullOrEmpty(secretMessage))\n        throw new ArgumentException(\"Secret Message Required!\", \"secretMessage\");\n\n      var plainText = Encoding.UTF8.GetBytes(secretMessage);\n      var cipherText = SimpleEncryptWithPassword(plainText, password, nonSecretPayload);\n      return Convert.ToBase64String(cipherText);\n    }\n\n\n    /// \u003csummary\u003e\n    /// Simple Decryption and Authentication (AES-GCM) of a UTF8 message\n    /// using a key derived from a password (PBKDF2)\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"encryptedMessage\"\u003eThe encrypted message.\u003c/param\u003e\n    /// \u003cparam name=\"password\"\u003eThe password.\u003c/param\u003e\n    /// \u003cparam name=\"nonSecretPayloadLength\"\u003eLength of the non secret payload.\u003c/param\u003e\n    /// \u003creturns\u003e\n    /// Decrypted Message\n    /// \u003c/returns\u003e\n    /// \u003cexception cref=\"System.ArgumentException\"\u003eEncrypted Message Required!;encryptedMessage\u003c/exception\u003e\n    /// \u003cremarks\u003e\n    /// Significantly less secure than using random binary keys.\n    /// \u003c/remarks\u003e\n    public static string SimpleDecryptWithPassword(string encryptedMessage, string password,\n                             int nonSecretPayloadLength = 0)\n    {\n      if (string.IsNullOrWhiteSpace(encryptedMessage))\n        throw new ArgumentException(\"Encrypted Message Required!\", \"encryptedMessage\");\n\n      var cipherText = Convert.FromBase64String(encryptedMessage);\n      var plainText = SimpleDecryptWithPassword(cipherText, password, nonSecretPayloadLength);\n      return plainText == null ? null : Encoding.UTF8.GetString(plainText);\n    }\n\n    public static byte[] SimpleEncrypt(byte[] secretMessage, byte[] key, byte[] nonSecretPayload = null)\n    {\n      //User Error Checks\n      if (key == null || key.Length != KeyBitSize / 8)\n        throw new ArgumentException(String.Format(\"Key needs to be {0} bit!\", KeyBitSize), \"key\");\n\n      if (secretMessage == null || secretMessage.Length == 0)\n        throw new ArgumentException(\"Secret Message Required!\", \"secretMessage\");\n\n      //Non-secret Payload Optional\n      nonSecretPayload = nonSecretPayload ?? new byte[] { };\n\n      //Using random nonce large enough not to repeat\n      var nonce = new byte[NonceBitSize / 8];\n      Random.NextBytes(nonce, 0, nonce.Length);\n\n      var cipher = new GcmBlockCipher(new AesFastEngine());\n      var parameters = new AeadParameters(new KeyParameter(key), MacBitSize, nonce, nonSecretPayload);\n      cipher.Init(true, parameters);\n\n      //Generate Cipher Text With Auth Tag\n      var cipherText = new byte[cipher.GetOutputSize(secretMessage.Length)];\n      var len = cipher.ProcessBytes(secretMessage, 0, secretMessage.Length, cipherText, 0);\n      cipher.DoFinal(cipherText, len);\n\n      //Assemble Message\n      using (var combinedStream = new MemoryStream())\n      {\n        using (var binaryWriter = new BinaryWriter(combinedStream))\n        {\n          //Prepend Authenticated Payload\n          binaryWriter.Write(nonSecretPayload);\n          //Prepend Nonce\n          binaryWriter.Write(nonce);\n          //Write Cipher Text\n          binaryWriter.Write(cipherText);\n        }\n        return combinedStream.ToArray();\n      }\n    }\n\n    public static byte[] SimpleDecrypt(byte[] encryptedMessage, byte[] key, int nonSecretPayloadLength = 0)\n    {\n      //User Error Checks\n      if (key == null || key.Length != KeyBitSize / 8)\n        throw new ArgumentException(String.Format(\"Key needs to be {0} bit!\", KeyBitSize), \"key\");\n\n      if (encryptedMessage == null || encryptedMessage.Length == 0)\n        throw new ArgumentException(\"Encrypted Message Required!\", \"encryptedMessage\");\n\n      using (var cipherStream = new MemoryStream(encryptedMessage))\n      using (var cipherReader = new BinaryReader(cipherStream))\n      {\n        //Grab Payload\n        var nonSecretPayload = cipherReader.ReadBytes(nonSecretPayloadLength);\n\n        //Grab Nonce\n        var nonce = cipherReader.ReadBytes(NonceBitSize / 8);\n       \n        var cipher = new GcmBlockCipher(new AesFastEngine());\n        var parameters = new AeadParameters(new KeyParameter(key), MacBitSize, nonce, nonSecretPayload);\n        cipher.Init(false, parameters);\n\n        //Decrypt Cipher Text\n        var cipherText = cipherReader.ReadBytes(encryptedMessage.Length - nonSecretPayloadLength - nonce.Length);\n        var plainText = new byte[cipher.GetOutputSize(cipherText.Length)];  \n\n        try\n        {\n          var len = cipher.ProcessBytes(cipherText, 0, cipherText.Length, plainText, 0);\n          cipher.DoFinal(plainText, len);\n\n        }\n        catch (InvalidCipherTextException)\n        {\n          //Return null if it doesn't authenticate\n          return null;\n        }\n\n        return plainText;\n      }\n\n    }\n\n    public static byte[] SimpleEncryptWithPassword(byte[] secretMessage, string password, byte[] nonSecretPayload = null)\n    {\n      nonSecretPayload = nonSecretPayload ?? new byte[] {};\n\n      //User Error Checks\n      if (string.IsNullOrWhiteSpace(password) || password.Length \u003c MinPasswordLength)\n        throw new ArgumentException(String.Format(\"Must have a password of at least {0} characters!\", MinPasswordLength), \"password\");\n\n      if (secretMessage == null || secretMessage.Length == 0)\n        throw new ArgumentException(\"Secret Message Required!\", \"secretMessage\");\n\n      var generator = new Pkcs5S2ParametersGenerator();\n\n      //Use Random Salt to minimize pre-generated weak password attacks.\n      var salt = new byte[SaltBitSize / 8];\n      Random.NextBytes(salt);\n\n      generator.Init(\n        PbeParametersGenerator.Pkcs5PasswordToBytes(password.ToCharArray()),\n        salt,\n        Iterations);\n\n      //Generate Key\n      var key = (KeyParameter)generator.GenerateDerivedMacParameters(KeyBitSize);\n\n      //Create Full Non Secret Payload\n      var payload = new byte[salt.Length + nonSecretPayload.Length];\n      Array.Copy(nonSecretPayload, payload, nonSecretPayload.Length);\n      Array.Copy(salt,0, payload,nonSecretPayload.Length, salt.Length);\n\n      return SimpleEncrypt(secretMessage, key.GetKey(), payload);\n    }\n\n    public static byte[] SimpleDecryptWithPassword(byte[] encryptedMessage, string password, int nonSecretPayloadLength = 0)\n    {\n      //User Error Checks\n      if (string.IsNullOrWhiteSpace(password) || password.Length \u003c MinPasswordLength)\n        throw new ArgumentException(String.Format(\"Must have a password of at least {0} characters!\", MinPasswordLength), \"password\");\n\n      if (encryptedMessage == null || encryptedMessage.Length == 0)\n        throw new ArgumentException(\"Encrypted Message Required!\", \"encryptedMessage\");\n\n      var generator = new Pkcs5S2ParametersGenerator();\n\n      //Grab Salt from Payload\n      var salt = new byte[SaltBitSize / 8];\n      Array.Copy(encryptedMessage, nonSecretPayloadLength, salt, 0, salt.Length);\n\n      generator.Init(\n        PbeParametersGenerator.Pkcs5PasswordToBytes(password.ToCharArray()),\n        salt,\n        Iterations);\n\n      //Generate Key\n      var key = (KeyParameter)generator.GenerateDerivedMacParameters(KeyBitSize);\n\n      return SimpleDecrypt(encryptedMessage, key.GetKey(), salt.Length + nonSecretPayloadLength);\n    }\n  }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 3,
        "code": "/*\n * This work (Modern Encryption of a String C#, by James Tuley), \n * identified by James Tuley, is free of known copyright restrictions.\n * https://gist.github.com/4336842\n * http://creativecommons.org/publicdomain/mark/1.0/ \n */\n\nusing System;\nusing System.IO;\nusing System.Text;\nusing Org.BouncyCastle.Crypto;\nusing Org.BouncyCastle.Crypto.Engines;\nusing Org.BouncyCastle.Crypto.Generators;\nusing Org.BouncyCastle.Crypto.Modes;\nusing Org.BouncyCastle.Crypto.Parameters;\nusing Org.BouncyCastle.Security;\nnamespace Encryption\n{\n\n  public static class AESGCM\n  {\n    private static readonly SecureRandom Random = new SecureRandom();\n\n    //Preconfigured Encryption Parameters\n    public static readonly int NonceBitSize = 128;\n    public static readonly int MacBitSize = 128;\n    public static readonly int KeyBitSize = 256;\n\n    //Preconfigured Password Key Derivation Parameters\n    public static readonly int SaltBitSize = 128;\n    public static readonly int Iterations = 10000;\n    public static readonly int MinPasswordLength = 12;\n\n\n    /// \u003csummary\u003e\n    /// Helper that generates a random new key on each call.\n    /// \u003c/summary\u003e\n    /// \u003creturns\u003e\u003c/returns\u003e\n    public static byte[] NewKey()\n    {\n      var key = new byte[KeyBitSize / 8];\n      Random.NextBytes(key);\n      return key;\n    }\n\n    /// \u003csummary\u003e\n    /// Simple Encryption And Authentication (AES-GCM) of a UTF8 string.\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"secretMessage\"\u003eThe secret message.\u003c/param\u003e\n    /// \u003cparam name=\"key\"\u003eThe key.\u003c/param\u003e\n    /// \u003cparam name=\"nonSecretPayload\"\u003eOptional non-secret payload.\u003c/param\u003e\n    /// \u003creturns\u003e\n    /// Encrypted Message\n    /// \u003c/returns\u003e\n    /// \u003cexception cref=\"System.ArgumentException\"\u003eSecret Message Required!;secretMessage\u003c/exception\u003e\n    /// \u003cremarks\u003e\n    /// Adds overhead of (Optional-Payload + BlockSize(16) + Message +  HMac-Tag(16)) * 1.33 Base64\n    /// \u003c/remarks\u003e\n    public static string SimpleEncrypt(string secretMessage, byte[] key, byte[] nonSecretPayload = null)\n    {\n      if (string.IsNullOrEmpty(secretMessage))\n        throw new ArgumentException(\"Secret Message Required!\", \"secretMessage\");\n\n      var plainText = Encoding.UTF8.GetBytes(secretMessage);\n      var cipherText = SimpleEncrypt(plainText, key, nonSecretPayload);\n      return Convert.ToBase64String(cipherText);\n    }\n\n\n    /// \u003csummary\u003e\n    /// Simple Decryption \u0026 Authentication (AES-GCM) of a UTF8 Message\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"encryptedMessage\"\u003eThe encrypted message.\u003c/param\u003e\n    /// \u003cparam name=\"key\"\u003eThe key.\u003c/param\u003e\n    /// \u003cparam name=\"nonSecretPayloadLength\"\u003eLength of the optional non-secret payload.\u003c/param\u003e\n    /// \u003creturns\u003eDecrypted Message\u003c/returns\u003e\n    public static string SimpleDecrypt(string encryptedMessage, byte[] key, int nonSecretPayloadLength = 0)\n    {\n      if (string.IsNullOrEmpty(encryptedMessage))\n        throw new ArgumentException(\"Encrypted Message Required!\", \"encryptedMessage\");\n\n      var cipherText = Convert.FromBase64String(encryptedMessage);\n      var plainText = SimpleDecrypt(cipherText, key, nonSecretPayloadLength);\n      return plainText == null ? null : Encoding.UTF8.GetString(plainText);\n    }\n\n    /// \u003csummary\u003e\n    /// Simple Encryption And Authentication (AES-GCM) of a UTF8 String\n    /// using key derived from a password (PBKDF2).\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"secretMessage\"\u003eThe secret message.\u003c/param\u003e\n    /// \u003cparam name=\"password\"\u003eThe password.\u003c/param\u003e\n    /// \u003cparam name=\"nonSecretPayload\"\u003eThe non secret payload.\u003c/param\u003e\n    /// \u003creturns\u003e\n    /// Encrypted Message\n    /// \u003c/returns\u003e\n    /// \u003cremarks\u003e\n    /// Significantly less secure than using random binary keys.\n    /// Adds additional non secret payload for key generation parameters.\n    /// \u003c/remarks\u003e\n    public static string SimpleEncryptWithPassword(string secretMessage, string password,\n                             byte[] nonSecretPayload = null)\n    {\n      if (string.IsNullOrEmpty(secretMessage))\n        throw new ArgumentException(\"Secret Message Required!\", \"secretMessage\");\n\n      var plainText = Encoding.UTF8.GetBytes(secretMessage);\n      var cipherText = SimpleEncryptWithPassword(plainText, password, nonSecretPayload);\n      return Convert.ToBase64String(cipherText);\n    }\n\n\n    /// \u003csummary\u003e\n    /// Simple Decryption and Authentication (AES-GCM) of a UTF8 message\n    /// using a key derived from a password (PBKDF2)\n    /// \u003c/summary\u003e\n    /// \u003cparam name=\"encryptedMessage\"\u003eThe encrypted message.\u003c/param\u003e\n    /// \u003cparam name=\"password\"\u003eThe password.\u003c/param\u003e\n    /// \u003cparam name=\"nonSecretPayloadLength\"\u003eLength of the non secret payload.\u003c/param\u003e\n    /// \u003creturns\u003e\n    /// Decrypted Message\n    /// \u003c/returns\u003e\n    /// \u003cexception cref=\"System.ArgumentException\"\u003eEncrypted Message Required!;encryptedMessage\u003c/exception\u003e\n    /// \u003cremarks\u003e\n    /// Significantly less secure than using random binary keys.\n    /// \u003c/remarks\u003e\n    public static string SimpleDecryptWithPassword(string encryptedMessage, string password,\n                             int nonSecretPayloadLength = 0)\n    {\n      if (string.IsNullOrWhiteSpace(encryptedMessage))\n        throw new ArgumentException(\"Encrypted Message Required!\", \"encryptedMessage\");\n\n      var cipherText = Convert.FromBase64String(encryptedMessage);\n      var plainText = SimpleDecryptWithPassword(cipherText, password, nonSecretPayloadLength);\n      return plainText == null ? null : Encoding.UTF8.GetString(plainText);\n    }\n\n    public static byte[] SimpleEncrypt(byte[] secretMessage, byte[] key, byte[] nonSecretPayload = null)\n    {\n      //User Error Checks\n      if (key == null || key.Length != KeyBitSize / 8)\n        throw new ArgumentException(String.Format(\"Key needs to be {0} bit!\", KeyBitSize), \"key\");\n\n      if (secretMessage == null || secretMessage.Length == 0)\n        throw new ArgumentException(\"Secret Message Required!\", \"secretMessage\");\n\n      //Non-secret Payload Optional\n      nonSecretPayload = nonSecretPayload ?? new byte[] { };\n\n      //Using random nonce large enough not to repeat\n      var nonce = new byte[NonceBitSize / 8];\n      Random.NextBytes(nonce, 0, nonce.Length);\n\n      var cipher = new GcmBlockCipher(new AesFastEngine());\n      var parameters = new AeadParameters(new KeyParameter(key), MacBitSize, nonce, nonSecretPayload);\n      cipher.Init(true, parameters);\n\n      //Generate Cipher Text With Auth Tag\n      var cipherText = new byte[cipher.GetOutputSize(secretMessage.Length)];\n      var len = cipher.ProcessBytes(secretMessage, 0, secretMessage.Length, cipherText, 0);\n      cipher.DoFinal(cipherText, len);\n\n      //Assemble Message\n      using (var combinedStream = new MemoryStream())\n      {\n        using (var binaryWriter = new BinaryWriter(combinedStream))\n        {\n          //Prepend Authenticated Payload\n          binaryWriter.Write(nonSecretPayload);\n          //Prepend Nonce\n          binaryWriter.Write(nonce);\n          //Write Cipher Text\n          binaryWriter.Write(cipherText);\n        }\n        return combinedStream.ToArray();\n      }\n    }\n\n    public static byte[] SimpleDecrypt(byte[] encryptedMessage, byte[] key, int nonSecretPayloadLength = 0)\n    {\n      //User Error Checks\n      if (key == null || key.Length != KeyBitSize / 8)\n        throw new ArgumentException(String.Format(\"Key needs to be {0} bit!\", KeyBitSize), \"key\");\n\n      if (encryptedMessage == null || encryptedMessage.Length == 0)\n        throw new ArgumentException(\"Encrypted Message Required!\", \"encryptedMessage\");\n\n      using (var cipherStream = new MemoryStream(encryptedMessage))\n      using (var cipherReader = new BinaryReader(cipherStream))\n      {\n        //Grab Payload\n        var nonSecretPayload = cipherReader.ReadBytes(nonSecretPayloadLength);\n\n        //Grab Nonce\n        var nonce = cipherReader.ReadBytes(NonceBitSize / 8);\n       \n        var cipher = new GcmBlockCipher(new AesFastEngine());\n        var parameters = new AeadParameters(new KeyParameter(key), MacBitSize, nonce, nonSecretPayload);\n        cipher.Init(false, parameters);\n\n        //Decrypt Cipher Text\n        var cipherText = cipherReader.ReadBytes(encryptedMessage.Length - nonSecretPayloadLength - nonce.Length);\n        var plainText = new byte[cipher.GetOutputSize(cipherText.Length)];  \n\n        try\n        {\n          var len = cipher.ProcessBytes(cipherText, 0, cipherText.Length, plainText, 0);\n          cipher.DoFinal(plainText, len);\n\n        }\n        catch (InvalidCipherTextException)\n        {\n          //Return null if it doesn't authenticate\n          return null;\n        }\n\n        return plainText;\n      }\n\n    }\n\n    public static byte[] SimpleEncryptWithPassword(byte[] secretMessage, string password, byte[] nonSecretPayload = null)\n    {\n      nonSecretPayload = nonSecretPayload ?? new byte[] {};\n\n      //User Error Checks\n      if (string.IsNullOrWhiteSpace(password) || password.Length \u003c MinPasswordLength)\n        throw new ArgumentException(String.Format(\"Must have a password of at least {0} characters!\", MinPasswordLength), \"password\");\n\n      if (secretMessage == null || secretMessage.Length == 0)\n        throw new ArgumentException(\"Secret Message Required!\", \"secretMessage\");\n\n      var generator = new Pkcs5S2ParametersGenerator();\n\n      //Use Random Salt to minimize pre-generated weak password attacks.\n      var salt = new byte[SaltBitSize / 8];\n      Random.NextBytes(salt);\n\n      generator.Init(\n        PbeParametersGenerator.Pkcs5PasswordToBytes(password.ToCharArray()),\n        salt,\n        Iterations);\n\n      //Generate Key\n      var key = (KeyParameter)generator.GenerateDerivedMacParameters(KeyBitSize);\n\n      //Create Full Non Secret Payload\n      var payload = new byte[salt.Length + nonSecretPayload.Length];\n      Array.Copy(nonSecretPayload, payload, nonSecretPayload.Length);\n      Array.Copy(salt,0, payload,nonSecretPayload.Length, salt.Length);\n\n      return SimpleEncrypt(secretMessage, key.GetKey(), payload);\n    }\n\n    public static byte[] SimpleDecryptWithPassword(byte[] encryptedMessage, string password, int nonSecretPayloadLength = 0)\n    {\n      //User Error Checks\n      if (string.IsNullOrWhiteSpace(password) || password.Length \u003c MinPasswordLength)\n        throw new ArgumentException(String.Format(\"Must have a password of at least {0} characters!\", MinPasswordLength), \"password\");\n\n      if (encryptedMessage == null || encryptedMessage.Length == 0)\n        throw new ArgumentException(\"Encrypted Message Required!\", \"encryptedMessage\");\n\n      var generator = new Pkcs5S2ParametersGenerator();\n\n      //Grab Salt from Payload\n      var salt = new byte[SaltBitSize / 8];\n      Array.Copy(encryptedMessage, nonSecretPayloadLength, salt, 0, salt.Length);\n\n      generator.Init(\n        PbeParametersGenerator.Pkcs5PasswordToBytes(password.ToCharArray()),\n        salt,\n        Iterations);\n\n      //Generate Key\n      var key = (KeyParameter)generator.GenerateDerivedMacParameters(KeyBitSize);\n\n      return SimpleDecrypt(encryptedMessage, key.GetKey(), salt.Length + nonSecretPayloadLength);\n    }\n  }\n}",
        "code_language": "C#"
      },
      {
        "id": "aac7441b-2c1e-481f-9ff9-454896fc4af9",
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550213460000,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550213460000,
        "parent_id": "dd1ae54d-e995-4540-acd7-c449f020f817",
        "parent_table": "block",
        "type": "text",
        "version": 3
      }
    ],
    "title": "Modern Examples of Symmetric Authenticated Encryption of a string",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "",
      "version": 94
    }
  ],
  "Tables": null
}