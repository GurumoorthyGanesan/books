{
  "ID": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
  "Root": {
    "alive": true,
    "content": [
      "55742996-585d-483a-81f6-d12fa91d71f1",
      "91a7cd0f-4ee6-4117-b19c-30917145d74b",
      "7a4aef7d-ef5a-45fc-90cd-a8d2f1855e4d",
      "82edbcc1-fab6-4eff-abbf-5c104d086ee0",
      "1418c264-981e-47fe-91b0-4a5cc7007d9a",
      "ef985c0a-b083-47c9-9b86-db57f733926a",
      "5a132292-4f45-480e-8337-53d6d87522c0",
      "bcbcd72a-8847-4a36-b7a9-16a3369d29c7",
      "b20f0530-302f-402b-a187-de5156c7aae6",
      "3001e29b-2e15-4879-88c0-284a679abe8c",
      "7e2fddc8-2820-4286-bb71-2bf5dac1503f",
      "52fbfbe8-76a8-4dab-9b5f-897e6fc63aba",
      "6511e884-7b3a-4773-8c4d-c2d36cc3264d",
      "9946ffe9-1d81-468b-8501-e8e83ada3159",
      "69a9cb8b-7426-4237-a872-f928fc3ff624",
      "f5533485-ba7a-4c10-b73c-a8d73e974b3a",
      "8e8ce87a-857d-4a41-a742-5c41652cf0af",
      "8b572415-b814-46a4-b956-80e56ac35135"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1550441714057,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1550713320000,
    "parent_id": "468b0602-725a-4cb6-810e-ca88f35bd501",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Shade Transition with Real-World Physics Using UIDynamicBehaviors"
        ]
      ]
    },
    "type": "page",
    "version": 8,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550441714042,
        "id": "55742996-585d-483a-81f6-d12fa91d71f1",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550441714042,
        "parent_id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "This example shows how to make an interactive presentation transition with “real-world” physics similar to iOS’s notifications screen."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "This example shows how to make an interactive presentation transition with “real-world” physics similar to iOS’s notifications screen."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550441714044,
        "id": "91a7cd0f-4ee6-4117-b19c-30917145d74b",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550441714044,
        "parent_id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
        "parent_table": "block",
        "properties": {
          "source": [
            [
              "https://i.stack.imgur.com/j0oBa.gif"
            ]
          ]
        },
        "type": "image",
        "version": 1,
        "source": "https://i.stack.imgur.com/j0oBa.gif",
        "image_url": "https://www.notion.so/image/https:%2F%2Fi.stack.imgur.com%2Fj0oBa.gif"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550441714044,
        "id": "7a4aef7d-ef5a-45fc-90cd-a8d2f1855e4d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550441714044,
        "parent_id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "To start with, we need a presenting view controller that the shade will appear over. This view controller will also act as our "
            ],
            [
              "UIViewControllerTransitioningDelegate",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " for our presented view controller and will vend animators for our transition. So we’ll create instances of our interactive animators (one for presenting, one for dismissing). We’ll also create an instance of the shade view controller, which, in this example, is just a view controller with a label. Because we want the same pan gesture to drive the entire interaction we pass references to the presenting view controller and the shade into our interactive animators."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "To start with, we need a presenting view controller that the shade will appear over. This view controller will also act as our "
          },
          {
            "Text": "UIViewControllerTransitioningDelegate",
            "AttrFlags": 2
          },
          {
            "Text": " for our presented view controller and will vend animators for our transition. So we’ll create instances of our interactive animators (one for presenting, one for dismissing). We’ll also create an instance of the shade view controller, which, in this example, is just a view controller with a label. Because we want the same pan gesture to drive the entire interaction we pass references to the presenting view controller and the shade into our interactive animators."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550441714044,
        "id": "82edbcc1-fab6-4eff-abbf-5c104d086ee0",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550441714044,
        "parent_id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Swift"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Swift"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550441714045,
        "id": "1418c264-981e-47fe-91b0-4a5cc7007d9a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550441714045,
        "parent_id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "class ViewController: UIViewController\n{\n    var presentingAnimator: ShadeAnimator!\n    var dismissingAnimator: ShadeAnimator!\n    let shadeVC = ShadeViewController()\n    \n    lazy var label: UILabel =\n    {\n        let label = UILabel()\n        label.textColor = .blue\n        label.translatesAutoresizingMaskIntoConstraints = false\n        self.view.addSubview(label)\n        label.centerXAnchor.constraint(equalTo: self.view.centerXAnchor).isActive = true\n        label.centerYAnchor.constraint(equalTo: self.view.centerYAnchor).isActive = true\n        return label\n    }()\n    \n    override func viewDidLoad()\n    {\n        super.viewDidLoad()\n        label.text = \"Swipe Down From Top\"\n        presentingAnimator = ShadeAnimator(isAppearing: true, presentingVC: self, presentedVC: shadeVC, transitionDelegate: self)\n        dismissingAnimator = ShadeAnimator(isAppearing: false, presentingVC: self, presentedVC: shadeVC, transitionDelegate: self)\n    }\n}\nextension ViewController: UIViewControllerTransitioningDelegate\n{\n    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -\u003e UIViewControllerAnimatedTransitioning?\n    {\n        return EmptyAnimator()\n    }\n    \n    func animationController(forDismissed dismissed: UIViewController) -\u003e UIViewControllerAnimatedTransitioning?\n    {\n        return EmptyAnimator()\n    }\n    \n    func interactionControllerForPresentation(using animator: UIViewControllerAnimatedTransitioning) -\u003e UIViewControllerInteractiveTransitioning?\n    {\n        return presentingAnimator\n    }\n    \n    func interactionControllerForDismissal(using animator: UIViewControllerAnimatedTransitioning) -\u003e UIViewControllerInteractiveTransitioning?\n    {\n        return dismissingAnimator\n    }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "class ViewController: UIViewController\n{\n    var presentingAnimator: ShadeAnimator!\n    var dismissingAnimator: ShadeAnimator!\n    let shadeVC = ShadeViewController()\n    \n    lazy var label: UILabel =\n    {\n        let label = UILabel()\n        label.textColor = .blue\n        label.translatesAutoresizingMaskIntoConstraints = false\n        self.view.addSubview(label)\n        label.centerXAnchor.constraint(equalTo: self.view.centerXAnchor).isActive = true\n        label.centerYAnchor.constraint(equalTo: self.view.centerYAnchor).isActive = true\n        return label\n    }()\n    \n    override func viewDidLoad()\n    {\n        super.viewDidLoad()\n        label.text = \"Swipe Down From Top\"\n        presentingAnimator = ShadeAnimator(isAppearing: true, presentingVC: self, presentedVC: shadeVC, transitionDelegate: self)\n        dismissingAnimator = ShadeAnimator(isAppearing: false, presentingVC: self, presentedVC: shadeVC, transitionDelegate: self)\n    }\n}\nextension ViewController: UIViewControllerTransitioningDelegate\n{\n    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -\u003e UIViewControllerAnimatedTransitioning?\n    {\n        return EmptyAnimator()\n    }\n    \n    func animationController(forDismissed dismissed: UIViewController) -\u003e UIViewControllerAnimatedTransitioning?\n    {\n        return EmptyAnimator()\n    }\n    \n    func interactionControllerForPresentation(using animator: UIViewControllerAnimatedTransitioning) -\u003e UIViewControllerInteractiveTransitioning?\n    {\n        return presentingAnimator\n    }\n    \n    func interactionControllerForDismissal(using animator: UIViewControllerAnimatedTransitioning) -\u003e UIViewControllerInteractiveTransitioning?\n    {\n        return dismissingAnimator\n    }\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550441714045,
        "id": "ef985c0a-b083-47c9-9b86-db57f733926a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550441714045,
        "parent_id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Objective-C"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Objective-C"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550441714045,
        "id": "5a132292-4f45-480e-8337-53d6d87522c0",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550441714045,
        "parent_id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "@interface ObjCViewController () \u003cUIViewControllerTransitioningDelegate\u003e\n@property (nonatomic, strong) ShadeAnimator *presentingAnimator;\n@property (nonatomic, strong) ShadeAnimator *dismissingAnimator;\n@property (nonatomic, strong) UILabel *label;\n@property (nonatomic, strong) ShadeViewController *shadeVC;\n@end\n\n@implementation ObjCViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    self.label.text = @\"Swipe Down From Top\";\n    self.shadeVC = [[ShadeViewController alloc] init];\n    self.presentingAnimator = [[ShadeAnimator alloc] initWithIsAppearing:YES presentingVC:self presentedVC:self.shadeVC transitionDelegate:self];\n    self.dismissingAnimator = [[ShadeAnimator alloc] initWithIsAppearing:NO presentingVC:self presentedVC:self.shadeVC transitionDelegate:self];\n}\n\n- (UILabel *)label\n{\n    if (!_label)\n    {\n        _label = [[UILabel alloc] init];\n        _label.textColor = [UIColor blueColor];\n        _label.translatesAutoresizingMaskIntoConstraints = NO;\n        [self.view addSubview:_label];\n        [_label.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor].active = YES;\n        [_label.centerYAnchor constraintEqualToAnchor:self.view.centerYAnchor].active = YES;\n    }\n    return _label;\n}\n\n#pragma mark - UIViewControllerTransitioningDelegate\n\n- (id\u003cUIViewControllerAnimatedTransitioning\u003e)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source\n{\n    return [[EmptyAnimator alloc] init];\n}\n\n- (id\u003cUIViewControllerAnimatedTransitioning\u003e)animationControllerForDismissedController:(UIViewController *)dismissed\n{\n    return [[EmptyAnimator alloc] init];\n}\n\n- (id\u003cUIViewControllerInteractiveTransitioning\u003e)interactionControllerForPresentation:(id\u003cUIViewControllerAnimatedTransitioning\u003e)animator\n{\n    return self.presentingAnimator;\n}\n\n- (id\u003cUIViewControllerInteractiveTransitioning\u003e)interactionControllerForDismissal:(id\u003cUIViewControllerAnimatedTransitioning\u003e)animator\n{\n    return self.dismissingAnimator;\n}\n\n@end"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "@interface ObjCViewController () \u003cUIViewControllerTransitioningDelegate\u003e\n@property (nonatomic, strong) ShadeAnimator *presentingAnimator;\n@property (nonatomic, strong) ShadeAnimator *dismissingAnimator;\n@property (nonatomic, strong) UILabel *label;\n@property (nonatomic, strong) ShadeViewController *shadeVC;\n@end\n\n@implementation ObjCViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    self.label.text = @\"Swipe Down From Top\";\n    self.shadeVC = [[ShadeViewController alloc] init];\n    self.presentingAnimator = [[ShadeAnimator alloc] initWithIsAppearing:YES presentingVC:self presentedVC:self.shadeVC transitionDelegate:self];\n    self.dismissingAnimator = [[ShadeAnimator alloc] initWithIsAppearing:NO presentingVC:self presentedVC:self.shadeVC transitionDelegate:self];\n}\n\n- (UILabel *)label\n{\n    if (!_label)\n    {\n        _label = [[UILabel alloc] init];\n        _label.textColor = [UIColor blueColor];\n        _label.translatesAutoresizingMaskIntoConstraints = NO;\n        [self.view addSubview:_label];\n        [_label.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor].active = YES;\n        [_label.centerYAnchor constraintEqualToAnchor:self.view.centerYAnchor].active = YES;\n    }\n    return _label;\n}\n\n#pragma mark - UIViewControllerTransitioningDelegate\n\n- (id\u003cUIViewControllerAnimatedTransitioning\u003e)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source\n{\n    return [[EmptyAnimator alloc] init];\n}\n\n- (id\u003cUIViewControllerAnimatedTransitioning\u003e)animationControllerForDismissedController:(UIViewController *)dismissed\n{\n    return [[EmptyAnimator alloc] init];\n}\n\n- (id\u003cUIViewControllerInteractiveTransitioning\u003e)interactionControllerForPresentation:(id\u003cUIViewControllerAnimatedTransitioning\u003e)animator\n{\n    return self.presentingAnimator;\n}\n\n- (id\u003cUIViewControllerInteractiveTransitioning\u003e)interactionControllerForDismissal:(id\u003cUIViewControllerAnimatedTransitioning\u003e)animator\n{\n    return self.dismissingAnimator;\n}\n\n@end",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550441714045,
        "id": "bcbcd72a-8847-4a36-b7a9-16a3369d29c7",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550441714045,
        "parent_id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "We want really only ever want to present our shade through an interactive transition but because of how "
            ],
            [
              "UIViewControllerTransitioningDelegate",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " works if we don’t return a regular animation controller our interactive controller will never be used. Because of that we create an "
            ],
            [
              "EmptyAnimator",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " class that conforms to "
            ],
            [
              "UIViewControllerAnimatedTransitioning",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "We want really only ever want to present our shade through an interactive transition but because of how "
          },
          {
            "Text": "UIViewControllerTransitioningDelegate",
            "AttrFlags": 2
          },
          {
            "Text": " works if we don’t return a regular animation controller our interactive controller will never be used. Because of that we create an "
          },
          {
            "Text": "EmptyAnimator",
            "AttrFlags": 2
          },
          {
            "Text": " class that conforms to "
          },
          {
            "Text": "UIViewControllerAnimatedTransitioning",
            "AttrFlags": 2
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550441714045,
        "id": "b20f0530-302f-402b-a187-de5156c7aae6",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550441714045,
        "parent_id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Swift"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Swift"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550441714045,
        "id": "3001e29b-2e15-4879-88c0-284a679abe8c",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550441714045,
        "parent_id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "class EmptyAnimator: NSObject\n{\n\n}\n\nextension EmptyAnimator: UIViewControllerAnimatedTransitioning\n{\n    func animateTransition(using transitionContext: UIViewControllerContextTransitioning)\n    {\n        \n    }\n    \n    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -\u003e TimeInterval\n    {\n        return 0.0\n    }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "class EmptyAnimator: NSObject\n{\n\n}\n\nextension EmptyAnimator: UIViewControllerAnimatedTransitioning\n{\n    func animateTransition(using transitionContext: UIViewControllerContextTransitioning)\n    {\n        \n    }\n    \n    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -\u003e TimeInterval\n    {\n        return 0.0\n    }\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550441714045,
        "id": "7e2fddc8-2820-4286-bb71-2bf5dac1503f",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550441714045,
        "parent_id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Objective-C"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Objective-C"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550441714045,
        "id": "52fbfbe8-76a8-4dab-9b5f-897e6fc63aba",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550441714045,
        "parent_id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "@implementation EmptyAnimator\n\n- (void)animateTransition:(id\u003cUIViewControllerContextTransitioning\u003e)transitionContext\n{\n    \n}\n\n- (NSTimeInterval)transitionDuration:(id\u003cUIViewControllerContextTransitioning\u003e)transitionContext\n{\n    return 0.0;\n}\n\n@end"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "@implementation EmptyAnimator\n\n- (void)animateTransition:(id\u003cUIViewControllerContextTransitioning\u003e)transitionContext\n{\n    \n}\n\n- (NSTimeInterval)transitionDuration:(id\u003cUIViewControllerContextTransitioning\u003e)transitionContext\n{\n    return 0.0;\n}\n\n@end",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550441714046,
        "id": "6511e884-7b3a-4773-8c4d-c2d36cc3264d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550441714046,
        "parent_id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Finally we need to actually create the "
            ],
            [
              "ShadeAnimator",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " which is a subclass of "
            ],
            [
              "UIDynamicBehavior",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " which conforms to "
            ],
            [
              "UIViewControllerInteractiveTransitioning",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Finally we need to actually create the "
          },
          {
            "Text": "ShadeAnimator",
            "AttrFlags": 2
          },
          {
            "Text": " which is a subclass of "
          },
          {
            "Text": "UIDynamicBehavior",
            "AttrFlags": 2
          },
          {
            "Text": " which conforms to "
          },
          {
            "Text": "UIViewControllerInteractiveTransitioning",
            "AttrFlags": 2
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550441714046,
        "id": "9946ffe9-1d81-468b-8501-e8e83ada3159",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550441714046,
        "parent_id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Swift"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Swift"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550441714046,
        "id": "69a9cb8b-7426-4237-a872-f928fc3ff624",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550441714046,
        "parent_id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "class ShadeAnimator: UIDynamicBehavior\n{\n    // Whether we are presenting or dismissing\n    let isAppearing: Bool\n\n    // The view controller that is not the shade\n    weak var presentingVC: UIViewController?\n\n    // The view controller that is the shade\n    weak var presentedVC: UIViewController?\n\n    // The delegate will vend the animator\n    weak var transitionDelegate: UIViewControllerTransitioningDelegate?\n    \n    // Feedback generator for haptics on collisions\n    let impactFeedbackGenerator = UIImpactFeedbackGenerator(style: .light)\n    \n    // The context given to the animator at the start of the transition\n    var transitionContext: UIViewControllerContextTransitioning?\n    \n    // Time limit of the dynamic part of the animation\n    var finishTime: TimeInterval = 4.0\n    \n    // The Pan Gesture that drives the transition. Not using EdgePan because triggers Notifications screen\n    lazy var pan: UIPanGestureRecognizer =\n    {\n        let pan = UIPanGestureRecognizer(target: self, action: #selector(self.handlePan(sender:)))\n        return pan\n    }()\n    \n    // The dynamic animator that we add `ShadeAnimator` to\n    lazy var animator: UIDynamicAnimator! =\n    {\n        let animator = UIDynamicAnimator(referenceView: self.transitionContext!.containerView)\n        return animator\n    }()\n    \n    // init with all of our dependencies\n    init(isAppearing: Bool, presentingVC: UIViewController, presentedVC: UIViewController, transitionDelegate: UIViewControllerTransitioningDelegate)\n    {\n        self.isAppearing = isAppearing\n        self.presentingVC = presentingVC\n        self.presentedVC = presentedVC\n        self.transitionDelegate = transitionDelegate\n        super.init()\n        self.impactFeedbackGenerator.prepare()\n        \n        if isAppearing\n        {\n            self.presentingVC?.view.addGestureRecognizer(pan)\n        }\n        else\n        {\n            self.presentedVC?.view.addGestureRecognizer(pan)\n        }\n        \n    }\n    \n    // Setup and moves shade view controller to just above screen if appearing\n    func setupViewsForTransition(with transitionContext: UIViewControllerContextTransitioning)\n    {\n        // Get relevant views and view controllers from transitionContext\n        guard let fromVC = transitionContext.viewController(forKey: .from),\n            let toVC = transitionContext.viewController(forKey: .to),\n            let toView = toVC.view else { return }\n        \n        let containerView = transitionContext.containerView\n        \n        // Hold refrence to transitionContext to notify it of completion\n        self.transitionContext = transitionContext\n        if isAppearing\n        {\n            // Position toView  just off-screen\n            let fromViewInitialFrame = transitionContext.initialFrame(for: fromVC)\n            var toViewInitialFrame = toView.frame\n            toViewInitialFrame.origin.y -= toViewInitialFrame.height\n            toViewInitialFrame.origin.x = fromViewInitialFrame.width * 0.5 - toViewInitialFrame.width * 0.5\n            toView.frame = toViewInitialFrame\n            \n            containerView.addSubview(toView)\n        }\n        else\n        {\n            fromVC.view.addGestureRecognizer(pan)\n        }\n    }\n    \n    // Handles the entire interaction from presenting/dismissing to completion\n    func handlePan(sender: UIPanGestureRecognizer)\n    {\n        let location = sender.location(in: transitionContext?.containerView)\n        let velocity = sender.velocity(in: transitionContext?.containerView)\n        let fromVC = transitionContext?.viewController(forKey: .from)\n        let toVC = transitionContext?.viewController(forKey: .to)\n        \n        let touchStartHeight: CGFloat = 90.0\n        let touchLocationFromBottom: CGFloat = 20.0\n        \n        switch sender.state\n        {\n        case .began:\n            let beginLocation = sender.location(in: sender.view)\n            if isAppearing\n            {\n                guard beginLocation.y \u003c= touchStartHeight,\n                      let presentedVC = self.presentedVC else { break }\n                presentedVC.modalPresentationStyle = .custom\n                presentedVC.transitioningDelegate = transitionDelegate\n                presentingVC?.present(presentedVC, animated: true)\n            }\n            else\n            {\n                guard beginLocation.y \u003e= (sender.view?.frame.height ?? 0.0) - touchStartHeight else { break }\n                presentedVC?.dismiss(animated: true)\n            }\n        case .changed:\n            guard let view = isAppearing ? toVC?.view : fromVC?.view else { return }\n            UIView.animate(withDuration: 0.2)\n            {\n                view.frame.origin.y = location.y - view.bounds.height + touchLocationFromBottom\n            }\n            \n            transitionContext?.updateInteractiveTransition(view.frame.maxY / view.frame.height\n            )\n        case .ended, .cancelled:\n            guard let view = isAppearing ? toVC?.view : fromVC?.view else { return }\n            let isCancelled = isAppearing ? (velocity.y \u003c 0.5 || view.center.y \u003c 0.0) : (velocity.y \u003e 0.5 || view.center.y \u003e 0.0)\n            addAttachmentBehavior(with: view, isCancelled: isCancelled)\n            addCollisionBehavior(with: view)\n            addItemBehavior(with: view)\n            \n            animator.addBehavior(self)\n            animator.delegate = self\n            \n            self.action =\n            { [weak self] in\n                guard let strongSelf = self else { return }\n                if strongSelf.animator.elapsedTime \u003e strongSelf.finishTime\n                {\n                    strongSelf.animator.removeAllBehaviors()\n                }\n                else\n                {\n                    strongSelf.transitionContext?.updateInteractiveTransition(view.frame.maxY / view.frame.height\n                    )\n                }\n            }\n        default:\n            break\n        }\n    }\n    \n    // Add collision behavior that causes bounce when finished\n    func addCollisionBehavior(with view: UIView)\n    {\n        let collisionBehavior = UICollisionBehavior(items: [view])\n        let insets = UIEdgeInsets(top: -view.bounds.height, left: 0.0, bottom: 0.0, right: 0.0)\n        collisionBehavior.setTranslatesReferenceBoundsIntoBoundary(with: insets)\n        collisionBehavior.collisionDelegate = self\n        self.addChildBehavior(collisionBehavior)\n    }\n    \n    // Add attachment behavior that pulls shade either to top or bottom\n    func addAttachmentBehavior(with view: UIView, isCancelled: Bool)\n    {\n        let anchor: CGPoint\n        switch (isAppearing, isCancelled)\n        {\n        case (true, true), (false, false):\n            anchor = CGPoint(x: view.center.x, y: -view.frame.height)\n        case (true, false), (false, true):\n            anchor = CGPoint(x: view.center.x, y: view.frame.height)\n        }\n        let attachmentBehavior = UIAttachmentBehavior(item: view, attachedToAnchor: anchor)\n        attachmentBehavior.damping = 0.1\n        attachmentBehavior.frequency = 3.0\n        attachmentBehavior.length = 0.5 * view.frame.height\n        self.addChildBehavior(attachmentBehavior)\n    }\n    \n    // Makes view more bouncy \n    func addItemBehavior(with view: UIView)\n    {\n        let itemBehavior = UIDynamicItemBehavior(items: [view])\n        itemBehavior.allowsRotation = false\n        itemBehavior.elasticity = 0.6\n        self.addChildBehavior(itemBehavior)\n    }\n    \n}\nextension ShadeAnimator: UIDynamicAnimatorDelegate\n{\n    // Determines transition has ended\n    func dynamicAnimatorDidPause(_ animator: UIDynamicAnimator)\n    {\n        guard let transitionContext = self.transitionContext else { return }\n        let fromVC = transitionContext.viewController(forKey: .from)\n        let toVC = transitionContext.viewController(forKey: .to)\n        guard let view = isAppearing ? toVC?.view : fromVC?.view else { return }\n        switch (view.center.y \u003c 0.0, isAppearing)\n        {\n        case (true, true), (true, false):\n            view.removeFromSuperview()\n            transitionContext.finishInteractiveTransition()\n            transitionContext.completeTransition(!isAppearing)\n        case (false, true):\n            toVC?.view.frame = transitionContext.finalFrame(for: toVC!)\n            transitionContext.finishInteractiveTransition()\n            transitionContext.completeTransition(true)\n        case (false, false):\n            fromVC?.view.frame = transitionContext.initialFrame(for: fromVC!)\n            transitionContext.cancelInteractiveTransition()\n            transitionContext.completeTransition(false)\n        }\n        childBehaviors.forEach { removeChildBehavior($0) }\n        animator.removeAllBehaviors()\n        self.animator = nil\n        self.transitionContext = nil\n    }\n}\nextension ShadeAnimator: UICollisionBehaviorDelegate\n{\n    // Triggers haptics\n    func collisionBehavior(_ behavior: UICollisionBehavior, beganContactFor item: UIDynamicItem, withBoundaryIdentifier identifier: NSCopying?, at p: CGPoint)\n    {\n        guard p.y \u003e 0.0 else { return }\n        impactFeedbackGenerator.impactOccurred()\n    }\n}\nextension ShadeAnimator: UIViewControllerInteractiveTransitioning\n{\n    // Starts transition\n    func startInteractiveTransition(_ transitionContext: UIViewControllerContextTransitioning)\n    {\n        setupViewsForTransition(with: transitionContext)\n    }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "class ShadeAnimator: UIDynamicBehavior\n{\n    // Whether we are presenting or dismissing\n    let isAppearing: Bool\n\n    // The view controller that is not the shade\n    weak var presentingVC: UIViewController?\n\n    // The view controller that is the shade\n    weak var presentedVC: UIViewController?\n\n    // The delegate will vend the animator\n    weak var transitionDelegate: UIViewControllerTransitioningDelegate?\n    \n    // Feedback generator for haptics on collisions\n    let impactFeedbackGenerator = UIImpactFeedbackGenerator(style: .light)\n    \n    // The context given to the animator at the start of the transition\n    var transitionContext: UIViewControllerContextTransitioning?\n    \n    // Time limit of the dynamic part of the animation\n    var finishTime: TimeInterval = 4.0\n    \n    // The Pan Gesture that drives the transition. Not using EdgePan because triggers Notifications screen\n    lazy var pan: UIPanGestureRecognizer =\n    {\n        let pan = UIPanGestureRecognizer(target: self, action: #selector(self.handlePan(sender:)))\n        return pan\n    }()\n    \n    // The dynamic animator that we add `ShadeAnimator` to\n    lazy var animator: UIDynamicAnimator! =\n    {\n        let animator = UIDynamicAnimator(referenceView: self.transitionContext!.containerView)\n        return animator\n    }()\n    \n    // init with all of our dependencies\n    init(isAppearing: Bool, presentingVC: UIViewController, presentedVC: UIViewController, transitionDelegate: UIViewControllerTransitioningDelegate)\n    {\n        self.isAppearing = isAppearing\n        self.presentingVC = presentingVC\n        self.presentedVC = presentedVC\n        self.transitionDelegate = transitionDelegate\n        super.init()\n        self.impactFeedbackGenerator.prepare()\n        \n        if isAppearing\n        {\n            self.presentingVC?.view.addGestureRecognizer(pan)\n        }\n        else\n        {\n            self.presentedVC?.view.addGestureRecognizer(pan)\n        }\n        \n    }\n    \n    // Setup and moves shade view controller to just above screen if appearing\n    func setupViewsForTransition(with transitionContext: UIViewControllerContextTransitioning)\n    {\n        // Get relevant views and view controllers from transitionContext\n        guard let fromVC = transitionContext.viewController(forKey: .from),\n            let toVC = transitionContext.viewController(forKey: .to),\n            let toView = toVC.view else { return }\n        \n        let containerView = transitionContext.containerView\n        \n        // Hold refrence to transitionContext to notify it of completion\n        self.transitionContext = transitionContext\n        if isAppearing\n        {\n            // Position toView  just off-screen\n            let fromViewInitialFrame = transitionContext.initialFrame(for: fromVC)\n            var toViewInitialFrame = toView.frame\n            toViewInitialFrame.origin.y -= toViewInitialFrame.height\n            toViewInitialFrame.origin.x = fromViewInitialFrame.width * 0.5 - toViewInitialFrame.width * 0.5\n            toView.frame = toViewInitialFrame\n            \n            containerView.addSubview(toView)\n        }\n        else\n        {\n            fromVC.view.addGestureRecognizer(pan)\n        }\n    }\n    \n    // Handles the entire interaction from presenting/dismissing to completion\n    func handlePan(sender: UIPanGestureRecognizer)\n    {\n        let location = sender.location(in: transitionContext?.containerView)\n        let velocity = sender.velocity(in: transitionContext?.containerView)\n        let fromVC = transitionContext?.viewController(forKey: .from)\n        let toVC = transitionContext?.viewController(forKey: .to)\n        \n        let touchStartHeight: CGFloat = 90.0\n        let touchLocationFromBottom: CGFloat = 20.0\n        \n        switch sender.state\n        {\n        case .began:\n            let beginLocation = sender.location(in: sender.view)\n            if isAppearing\n            {\n                guard beginLocation.y \u003c= touchStartHeight,\n                      let presentedVC = self.presentedVC else { break }\n                presentedVC.modalPresentationStyle = .custom\n                presentedVC.transitioningDelegate = transitionDelegate\n                presentingVC?.present(presentedVC, animated: true)\n            }\n            else\n            {\n                guard beginLocation.y \u003e= (sender.view?.frame.height ?? 0.0) - touchStartHeight else { break }\n                presentedVC?.dismiss(animated: true)\n            }\n        case .changed:\n            guard let view = isAppearing ? toVC?.view : fromVC?.view else { return }\n            UIView.animate(withDuration: 0.2)\n            {\n                view.frame.origin.y = location.y - view.bounds.height + touchLocationFromBottom\n            }\n            \n            transitionContext?.updateInteractiveTransition(view.frame.maxY / view.frame.height\n            )\n        case .ended, .cancelled:\n            guard let view = isAppearing ? toVC?.view : fromVC?.view else { return }\n            let isCancelled = isAppearing ? (velocity.y \u003c 0.5 || view.center.y \u003c 0.0) : (velocity.y \u003e 0.5 || view.center.y \u003e 0.0)\n            addAttachmentBehavior(with: view, isCancelled: isCancelled)\n            addCollisionBehavior(with: view)\n            addItemBehavior(with: view)\n            \n            animator.addBehavior(self)\n            animator.delegate = self\n            \n            self.action =\n            { [weak self] in\n                guard let strongSelf = self else { return }\n                if strongSelf.animator.elapsedTime \u003e strongSelf.finishTime\n                {\n                    strongSelf.animator.removeAllBehaviors()\n                }\n                else\n                {\n                    strongSelf.transitionContext?.updateInteractiveTransition(view.frame.maxY / view.frame.height\n                    )\n                }\n            }\n        default:\n            break\n        }\n    }\n    \n    // Add collision behavior that causes bounce when finished\n    func addCollisionBehavior(with view: UIView)\n    {\n        let collisionBehavior = UICollisionBehavior(items: [view])\n        let insets = UIEdgeInsets(top: -view.bounds.height, left: 0.0, bottom: 0.0, right: 0.0)\n        collisionBehavior.setTranslatesReferenceBoundsIntoBoundary(with: insets)\n        collisionBehavior.collisionDelegate = self\n        self.addChildBehavior(collisionBehavior)\n    }\n    \n    // Add attachment behavior that pulls shade either to top or bottom\n    func addAttachmentBehavior(with view: UIView, isCancelled: Bool)\n    {\n        let anchor: CGPoint\n        switch (isAppearing, isCancelled)\n        {\n        case (true, true), (false, false):\n            anchor = CGPoint(x: view.center.x, y: -view.frame.height)\n        case (true, false), (false, true):\n            anchor = CGPoint(x: view.center.x, y: view.frame.height)\n        }\n        let attachmentBehavior = UIAttachmentBehavior(item: view, attachedToAnchor: anchor)\n        attachmentBehavior.damping = 0.1\n        attachmentBehavior.frequency = 3.0\n        attachmentBehavior.length = 0.5 * view.frame.height\n        self.addChildBehavior(attachmentBehavior)\n    }\n    \n    // Makes view more bouncy \n    func addItemBehavior(with view: UIView)\n    {\n        let itemBehavior = UIDynamicItemBehavior(items: [view])\n        itemBehavior.allowsRotation = false\n        itemBehavior.elasticity = 0.6\n        self.addChildBehavior(itemBehavior)\n    }\n    \n}\nextension ShadeAnimator: UIDynamicAnimatorDelegate\n{\n    // Determines transition has ended\n    func dynamicAnimatorDidPause(_ animator: UIDynamicAnimator)\n    {\n        guard let transitionContext = self.transitionContext else { return }\n        let fromVC = transitionContext.viewController(forKey: .from)\n        let toVC = transitionContext.viewController(forKey: .to)\n        guard let view = isAppearing ? toVC?.view : fromVC?.view else { return }\n        switch (view.center.y \u003c 0.0, isAppearing)\n        {\n        case (true, true), (true, false):\n            view.removeFromSuperview()\n            transitionContext.finishInteractiveTransition()\n            transitionContext.completeTransition(!isAppearing)\n        case (false, true):\n            toVC?.view.frame = transitionContext.finalFrame(for: toVC!)\n            transitionContext.finishInteractiveTransition()\n            transitionContext.completeTransition(true)\n        case (false, false):\n            fromVC?.view.frame = transitionContext.initialFrame(for: fromVC!)\n            transitionContext.cancelInteractiveTransition()\n            transitionContext.completeTransition(false)\n        }\n        childBehaviors.forEach { removeChildBehavior($0) }\n        animator.removeAllBehaviors()\n        self.animator = nil\n        self.transitionContext = nil\n    }\n}\nextension ShadeAnimator: UICollisionBehaviorDelegate\n{\n    // Triggers haptics\n    func collisionBehavior(_ behavior: UICollisionBehavior, beganContactFor item: UIDynamicItem, withBoundaryIdentifier identifier: NSCopying?, at p: CGPoint)\n    {\n        guard p.y \u003e 0.0 else { return }\n        impactFeedbackGenerator.impactOccurred()\n    }\n}\nextension ShadeAnimator: UIViewControllerInteractiveTransitioning\n{\n    // Starts transition\n    func startInteractiveTransition(_ transitionContext: UIViewControllerContextTransitioning)\n    {\n        setupViewsForTransition(with: transitionContext)\n    }\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550441714046,
        "id": "f5533485-ba7a-4c10-b73c-a8d73e974b3a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550441714046,
        "parent_id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Objective-C"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Objective-C"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550441714046,
        "id": "8e8ce87a-857d-4a41-a742-5c41652cf0af",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550441714046,
        "parent_id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "@interface ShadeAnimator() \u003cUIDynamicAnimatorDelegate, UICollisionBehaviorDelegate\u003e\n@property (nonatomic, assign) BOOL isAppearing;\n@property (nonatomic, weak) UIViewController *presentingVC;\n@property (nonatomic, weak) UIViewController *presentedVC;\n@property (nonatomic, weak) NSObject\u003cUIViewControllerTransitioningDelegate\u003e *transitionDelegate;\n@property (nonatomic, strong) UIImpactFeedbackGenerator *impactFeedbackGenerator;\n@property (nonatomic, strong) id\u003cUIViewControllerContextTransitioning\u003e transitionContext;\n@property (nonatomic, assign) NSTimeInterval finishTime;\n@property (nonatomic, strong) UIPanGestureRecognizer *pan;\n@property (nonatomic, strong) UIDynamicAnimator *animator;\n@end\n\n@implementation ShadeAnimator\n\n- (instancetype)initWithIsAppearing:(BOOL)isAppearing presentingVC:(UIViewController *)presentingVC presentedVC:(UIViewController *)presentedVC transitionDelegate:(id\u003cUIViewControllerTransitioningDelegate\u003e)transitionDelegate\n{\n    self = [super init];\n    if (self)\n    {\n        _isAppearing = isAppearing;\n        _presentingVC = presentingVC;\n        _presentedVC = presentedVC;\n        _transitionDelegate = transitionDelegate;\n        _impactFeedbackGenerator = [[UIImpactFeedbackGenerator alloc]initWithStyle:UIImpactFeedbackStyleLight];\n        [_impactFeedbackGenerator prepare];\n        if (_isAppearing)\n        {\n            [_presentingVC.view addGestureRecognizer:self.pan];\n        }\n        else\n        {\n            [_presentedVC.view addGestureRecognizer:self.pan];\n        }\n    }\n    return self;\n}\n\n#pragma mark - Lazy Init\n- (UIPanGestureRecognizer *)pan\n{\n    if (!_pan)\n    {\n        _pan = [[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(handlePan:)];\n    }\n    return _pan;\n}\n\n- (UIDynamicAnimator *)animator\n{\n    if (!_animator)\n    {\n        _animator = [[UIDynamicAnimator alloc]initWithReferenceView:self.transitionContext.containerView];\n    }\n    return _animator;\n}\n\n#pragma mark - Setup\n- (void)setupViewForTransitionWithContext:(id\u003cUIViewControllerContextTransitioning\u003e)transitionContext\n{\n    UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];\n    UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];\n    UIView *toView = toVC.view;\n    UIView *containerView = transitionContext.containerView;\n    self.transitionContext = transitionContext;\n    if (self.isAppearing)\n    {\n        CGRect fromViewInitialFrame = [transitionContext initialFrameForViewController:fromVC];\n        CGRect toViewInitialFrame = toView.frame;\n        toViewInitialFrame.origin.y -= CGRectGetHeight(toViewInitialFrame);\n        toViewInitialFrame.origin.x = CGRectGetWidth(fromViewInitialFrame) * 0.5 - CGRectGetWidth(toViewInitialFrame) * 0.5;\n        \n        [containerView addSubview:toView];\n    }\n    else\n    {\n        [fromVC.view addGestureRecognizer:self.pan];\n    }\n}\n\n#pragma mark - Gesture\n- (void)handlePan:(UIPanGestureRecognizer *)sender\n{\n    CGPoint location = [sender locationInView:self.transitionContext.containerView];\n    CGPoint velocity = [sender velocityInView:self.transitionContext.containerView];\n    UIViewController *fromVC = [self.transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];\n    UIViewController *toVC = [self.transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];\n    \n    CGFloat touchStartHeight = 90.0;\n    CGFloat touchLocationFromBottom = 20.0;\n    \n    if (sender.state == UIGestureRecognizerStateBegan)\n    {\n        CGPoint beginLocation = [sender locationInView:sender.view];\n        if (self.isAppearing)\n        {\n            if (beginLocation.y \u003c= touchStartHeight)\n            {\n                self.presentedVC.modalPresentationStyle = UIModalPresentationCustom;\n                self.presentedVC.transitioningDelegate = self.transitionDelegate;\n                [self.presentingVC presentViewController:self.presentedVC animated:YES completion:nil];\n            }\n        }\n        else\n        {\n            if (beginLocation.y \u003e= [sender locationInView:sender.view].y - touchStartHeight)\n            {\n                [self.presentedVC dismissViewControllerAnimated:true completion:nil];\n            }\n        }\n    }\n    else if (sender.state == UIGestureRecognizerStateChanged)\n    {\n        UIView *view = self.isAppearing ? toVC.view : fromVC.view;\n        [UIView animateWithDuration:0.2 animations:^{\n            CGRect frame = view.frame;\n            frame.origin.y = location.y - CGRectGetHeight(view.bounds) + touchLocationFromBottom;\n            view.frame = frame;\n        }];\n        [self.transitionContext updateInteractiveTransition:CGRectGetMaxY(view.frame) / CGRectGetHeight(view.frame)];\n    }\n    else if (sender.state == UIGestureRecognizerStateEnded || sender.state == UIGestureRecognizerStateCancelled)\n    {\n        UIView *view = self.isAppearing ? toVC.view : fromVC.view;\n        BOOL isCancelled = self.isAppearing ? (velocity.y \u003c 0.5 || view.center.y \u003c 0.0) : (velocity.y \u003e 0.5 || view.center.y \u003e 0.0);\n        [self addAttachmentBehaviorWithView:view isCancelled:isCancelled];\n        [self addCollisionBehaviorWithView:view];\n        [self addItemBehaviorWithView:view];\n        \n        [self.animator addBehavior:self];\n        self.animator.delegate = self;\n        \n        __weak ShadeAnimator *weakSelf = self;\n        self.action =\n        ^{\n            if (weakSelf.animator.elapsedTime \u003e weakSelf.finishTime)\n            {\n                [weakSelf.animator removeAllBehaviors];\n            }\n            else\n            {\n                [weakSelf.transitionContext updateInteractiveTransition:CGRectGetMaxY(view.frame) / CGRectGetHeight(view.frame)];\n            }\n        };\n    }\n}\n\n#pragma mark - UIViewControllerInteractiveTransitioning\n- (void)startInteractiveTransition:(id\u003cUIViewControllerContextTransitioning\u003e)transitionContext\n{\n    [self setupViewForTransitionWithContext:transitionContext];\n}\n\n#pragma mark - Behaviors\n- (void)addCollisionBehaviorWithView:(UIView *)view\n{\n    UICollisionBehavior *collisionBehavior = [[UICollisionBehavior alloc]initWithItems:@[view]];\n    UIEdgeInsets insets = UIEdgeInsetsMake(-CGRectGetHeight(view.bounds), 0.0, 0.0, 0.0);\n    [collisionBehavior setTranslatesReferenceBoundsIntoBoundaryWithInsets:insets];\n    collisionBehavior.collisionDelegate = self;\n    [self addChildBehavior:collisionBehavior];\n}\n\n- (void)addItemBehaviorWithView:(UIView *)view\n{\n    UIDynamicItemBehavior *itemBehavior = [[UIDynamicItemBehavior alloc]initWithItems:@[view]];\n    itemBehavior.allowsRotation = NO;\n    itemBehavior.elasticity = 0.6;\n    [self addChildBehavior:itemBehavior];\n}\n\n- (void)addAttachmentBehaviorWithView:(UIView *)view isCancelled:(BOOL)isCancelled\n{\n    CGPoint anchor;\n    if ((self.isAppearing \u0026\u0026 isCancelled) || (!self.isAppearing \u0026\u0026 isCancelled))\n    {\n        anchor = CGPointMake(view.center.x, -CGRectGetHeight(view.frame));\n    }\n    else\n    {\n        anchor = CGPointMake(view.center.x, -CGRectGetHeight(view.frame));\n    }\n    UIAttachmentBehavior *attachmentBehavior = [[UIAttachmentBehavior alloc]initWithItem:view attachedToAnchor:anchor];\n    attachmentBehavior.damping = 0.1;\n    attachmentBehavior.frequency = 3.0;\n    attachmentBehavior.length = 0.5 * CGRectGetHeight(view.frame);\n    [self addChildBehavior:attachmentBehavior];\n}\n\n#pragma mark - UICollisionBehaviorDelegate\n- (void)collisionBehavior:(UICollisionBehavior *)behavior beganContactForItem:(id\u003cUIDynamicItem\u003e)item withBoundaryIdentifier:(id\u003cNSCopying\u003e)identifier atPoint:(CGPoint)p\n{\n    if (p.y \u003e 0.0)\n    {\n        [self.impactFeedbackGenerator impactOccurred];\n    }\n}\n\n#pragma mark - UIDynamicAnimatorDelegate\n- (void)dynamicAnimatorDidPause:(UIDynamicAnimator *)animator\n{\n    UIViewController *fromVC = [self.transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];\n    UIViewController *toVC = [self.transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];\n    UIView *view = self.isAppearing ? toVC.view : fromVC.view;\n    if (view.center.y \u003c 0.0 \u0026\u0026 (self.isAppearing ||  !self.isAppearing))\n    {\n        [view removeFromSuperview];\n        [self.transitionContext finishInteractiveTransition];\n        [self.transitionContext completeTransition:!self.isAppearing];\n    }\n    else if (view.center.y \u003e= 0.0 \u0026\u0026 self.isAppearing)\n    {\n        toVC.view.frame = [self.transitionContext finalFrameForViewController:toVC];\n        [self.transitionContext finishInteractiveTransition];\n        [self.transitionContext completeTransition:YES];\n    }\n    else\n    {\n        fromVC.view.frame = [self.transitionContext initialFrameForViewController:fromVC];\n        [self.transitionContext cancelInteractiveTransition];\n        [self.transitionContext completeTransition:NO];\n    }\n    for (UIDynamicBehavior *behavior in self.childBehaviors)\n    {\n        [self removeChildBehavior:behavior];\n    }\n    [animator removeAllBehaviors];\n    self.animator = nil;\n    self.transitionContext = nil;\n}\n\n@end"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "@interface ShadeAnimator() \u003cUIDynamicAnimatorDelegate, UICollisionBehaviorDelegate\u003e\n@property (nonatomic, assign) BOOL isAppearing;\n@property (nonatomic, weak) UIViewController *presentingVC;\n@property (nonatomic, weak) UIViewController *presentedVC;\n@property (nonatomic, weak) NSObject\u003cUIViewControllerTransitioningDelegate\u003e *transitionDelegate;\n@property (nonatomic, strong) UIImpactFeedbackGenerator *impactFeedbackGenerator;\n@property (nonatomic, strong) id\u003cUIViewControllerContextTransitioning\u003e transitionContext;\n@property (nonatomic, assign) NSTimeInterval finishTime;\n@property (nonatomic, strong) UIPanGestureRecognizer *pan;\n@property (nonatomic, strong) UIDynamicAnimator *animator;\n@end\n\n@implementation ShadeAnimator\n\n- (instancetype)initWithIsAppearing:(BOOL)isAppearing presentingVC:(UIViewController *)presentingVC presentedVC:(UIViewController *)presentedVC transitionDelegate:(id\u003cUIViewControllerTransitioningDelegate\u003e)transitionDelegate\n{\n    self = [super init];\n    if (self)\n    {\n        _isAppearing = isAppearing;\n        _presentingVC = presentingVC;\n        _presentedVC = presentedVC;\n        _transitionDelegate = transitionDelegate;\n        _impactFeedbackGenerator = [[UIImpactFeedbackGenerator alloc]initWithStyle:UIImpactFeedbackStyleLight];\n        [_impactFeedbackGenerator prepare];\n        if (_isAppearing)\n        {\n            [_presentingVC.view addGestureRecognizer:self.pan];\n        }\n        else\n        {\n            [_presentedVC.view addGestureRecognizer:self.pan];\n        }\n    }\n    return self;\n}\n\n#pragma mark - Lazy Init\n- (UIPanGestureRecognizer *)pan\n{\n    if (!_pan)\n    {\n        _pan = [[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(handlePan:)];\n    }\n    return _pan;\n}\n\n- (UIDynamicAnimator *)animator\n{\n    if (!_animator)\n    {\n        _animator = [[UIDynamicAnimator alloc]initWithReferenceView:self.transitionContext.containerView];\n    }\n    return _animator;\n}\n\n#pragma mark - Setup\n- (void)setupViewForTransitionWithContext:(id\u003cUIViewControllerContextTransitioning\u003e)transitionContext\n{\n    UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];\n    UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];\n    UIView *toView = toVC.view;\n    UIView *containerView = transitionContext.containerView;\n    self.transitionContext = transitionContext;\n    if (self.isAppearing)\n    {\n        CGRect fromViewInitialFrame = [transitionContext initialFrameForViewController:fromVC];\n        CGRect toViewInitialFrame = toView.frame;\n        toViewInitialFrame.origin.y -= CGRectGetHeight(toViewInitialFrame);\n        toViewInitialFrame.origin.x = CGRectGetWidth(fromViewInitialFrame) * 0.5 - CGRectGetWidth(toViewInitialFrame) * 0.5;\n        \n        [containerView addSubview:toView];\n    }\n    else\n    {\n        [fromVC.view addGestureRecognizer:self.pan];\n    }\n}\n\n#pragma mark - Gesture\n- (void)handlePan:(UIPanGestureRecognizer *)sender\n{\n    CGPoint location = [sender locationInView:self.transitionContext.containerView];\n    CGPoint velocity = [sender velocityInView:self.transitionContext.containerView];\n    UIViewController *fromVC = [self.transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];\n    UIViewController *toVC = [self.transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];\n    \n    CGFloat touchStartHeight = 90.0;\n    CGFloat touchLocationFromBottom = 20.0;\n    \n    if (sender.state == UIGestureRecognizerStateBegan)\n    {\n        CGPoint beginLocation = [sender locationInView:sender.view];\n        if (self.isAppearing)\n        {\n            if (beginLocation.y \u003c= touchStartHeight)\n            {\n                self.presentedVC.modalPresentationStyle = UIModalPresentationCustom;\n                self.presentedVC.transitioningDelegate = self.transitionDelegate;\n                [self.presentingVC presentViewController:self.presentedVC animated:YES completion:nil];\n            }\n        }\n        else\n        {\n            if (beginLocation.y \u003e= [sender locationInView:sender.view].y - touchStartHeight)\n            {\n                [self.presentedVC dismissViewControllerAnimated:true completion:nil];\n            }\n        }\n    }\n    else if (sender.state == UIGestureRecognizerStateChanged)\n    {\n        UIView *view = self.isAppearing ? toVC.view : fromVC.view;\n        [UIView animateWithDuration:0.2 animations:^{\n            CGRect frame = view.frame;\n            frame.origin.y = location.y - CGRectGetHeight(view.bounds) + touchLocationFromBottom;\n            view.frame = frame;\n        }];\n        [self.transitionContext updateInteractiveTransition:CGRectGetMaxY(view.frame) / CGRectGetHeight(view.frame)];\n    }\n    else if (sender.state == UIGestureRecognizerStateEnded || sender.state == UIGestureRecognizerStateCancelled)\n    {\n        UIView *view = self.isAppearing ? toVC.view : fromVC.view;\n        BOOL isCancelled = self.isAppearing ? (velocity.y \u003c 0.5 || view.center.y \u003c 0.0) : (velocity.y \u003e 0.5 || view.center.y \u003e 0.0);\n        [self addAttachmentBehaviorWithView:view isCancelled:isCancelled];\n        [self addCollisionBehaviorWithView:view];\n        [self addItemBehaviorWithView:view];\n        \n        [self.animator addBehavior:self];\n        self.animator.delegate = self;\n        \n        __weak ShadeAnimator *weakSelf = self;\n        self.action =\n        ^{\n            if (weakSelf.animator.elapsedTime \u003e weakSelf.finishTime)\n            {\n                [weakSelf.animator removeAllBehaviors];\n            }\n            else\n            {\n                [weakSelf.transitionContext updateInteractiveTransition:CGRectGetMaxY(view.frame) / CGRectGetHeight(view.frame)];\n            }\n        };\n    }\n}\n\n#pragma mark - UIViewControllerInteractiveTransitioning\n- (void)startInteractiveTransition:(id\u003cUIViewControllerContextTransitioning\u003e)transitionContext\n{\n    [self setupViewForTransitionWithContext:transitionContext];\n}\n\n#pragma mark - Behaviors\n- (void)addCollisionBehaviorWithView:(UIView *)view\n{\n    UICollisionBehavior *collisionBehavior = [[UICollisionBehavior alloc]initWithItems:@[view]];\n    UIEdgeInsets insets = UIEdgeInsetsMake(-CGRectGetHeight(view.bounds), 0.0, 0.0, 0.0);\n    [collisionBehavior setTranslatesReferenceBoundsIntoBoundaryWithInsets:insets];\n    collisionBehavior.collisionDelegate = self;\n    [self addChildBehavior:collisionBehavior];\n}\n\n- (void)addItemBehaviorWithView:(UIView *)view\n{\n    UIDynamicItemBehavior *itemBehavior = [[UIDynamicItemBehavior alloc]initWithItems:@[view]];\n    itemBehavior.allowsRotation = NO;\n    itemBehavior.elasticity = 0.6;\n    [self addChildBehavior:itemBehavior];\n}\n\n- (void)addAttachmentBehaviorWithView:(UIView *)view isCancelled:(BOOL)isCancelled\n{\n    CGPoint anchor;\n    if ((self.isAppearing \u0026\u0026 isCancelled) || (!self.isAppearing \u0026\u0026 isCancelled))\n    {\n        anchor = CGPointMake(view.center.x, -CGRectGetHeight(view.frame));\n    }\n    else\n    {\n        anchor = CGPointMake(view.center.x, -CGRectGetHeight(view.frame));\n    }\n    UIAttachmentBehavior *attachmentBehavior = [[UIAttachmentBehavior alloc]initWithItem:view attachedToAnchor:anchor];\n    attachmentBehavior.damping = 0.1;\n    attachmentBehavior.frequency = 3.0;\n    attachmentBehavior.length = 0.5 * CGRectGetHeight(view.frame);\n    [self addChildBehavior:attachmentBehavior];\n}\n\n#pragma mark - UICollisionBehaviorDelegate\n- (void)collisionBehavior:(UICollisionBehavior *)behavior beganContactForItem:(id\u003cUIDynamicItem\u003e)item withBoundaryIdentifier:(id\u003cNSCopying\u003e)identifier atPoint:(CGPoint)p\n{\n    if (p.y \u003e 0.0)\n    {\n        [self.impactFeedbackGenerator impactOccurred];\n    }\n}\n\n#pragma mark - UIDynamicAnimatorDelegate\n- (void)dynamicAnimatorDidPause:(UIDynamicAnimator *)animator\n{\n    UIViewController *fromVC = [self.transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];\n    UIViewController *toVC = [self.transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];\n    UIView *view = self.isAppearing ? toVC.view : fromVC.view;\n    if (view.center.y \u003c 0.0 \u0026\u0026 (self.isAppearing ||  !self.isAppearing))\n    {\n        [view removeFromSuperview];\n        [self.transitionContext finishInteractiveTransition];\n        [self.transitionContext completeTransition:!self.isAppearing];\n    }\n    else if (view.center.y \u003e= 0.0 \u0026\u0026 self.isAppearing)\n    {\n        toVC.view.frame = [self.transitionContext finalFrameForViewController:toVC];\n        [self.transitionContext finishInteractiveTransition];\n        [self.transitionContext completeTransition:YES];\n    }\n    else\n    {\n        fromVC.view.frame = [self.transitionContext initialFrameForViewController:fromVC];\n        [self.transitionContext cancelInteractiveTransition];\n        [self.transitionContext completeTransition:NO];\n    }\n    for (UIDynamicBehavior *behavior in self.childBehaviors)\n    {\n        [self removeChildBehavior:behavior];\n    }\n    [animator removeAllBehaviors];\n    self.animator = nil;\n    self.transitionContext = nil;\n}\n\n@end",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550441714047,
        "id": "8b572415-b814-46a4-b956-80e56ac35135",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550441714047,
        "parent_id": "aefb61c8-d1b7-472c-b81c-80a805ff78c6",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The animator triggers the start of the transition when the pan gesture begins. And simply moves the view as the gesture changes. But when the gesture ends that is when "
            ],
            [
              "UIDynamicBehaviors",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " determines if the transition should be completed or cancelled. To do so it uses an attachment and collision behavior. For more information see the "
            ],
            [
              "2013 WWDC Session “Advanced Techniques with UIKit Dynamics",
              [
                [
                  "a",
                  "https://developer.apple.com/videos/play/wwdc2013/221/"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The animator triggers the start of the transition when the pan gesture begins. And simply moves the view as the gesture changes. But when the gesture ends that is when "
          },
          {
            "Text": "UIDynamicBehaviors",
            "AttrFlags": 2
          },
          {
            "Text": " determines if the transition should be completed or cancelled. To do so it uses an attachment and collision behavior. For more information see the "
          },
          {
            "Text": "2013 WWDC Session “Advanced Techniques with UIKit Dynamics",
            "Link": "https://developer.apple.com/videos/play/wwdc2013/221/"
          },
          {
            "Text": "."
          }
        ]
      }
    ],
    "title": "Shade Transition with Real-World Physics Using UIDynamicBehaviors",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}