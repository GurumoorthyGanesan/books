{
  "ID": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
  "Root": {
    "alive": true,
    "content": [
      "59375cd4-a18f-4513-b574-f4d5162446c1",
      "e0f46734-30d8-4a6b-98ae-7792c9789f03",
      "37f03dea-1e1d-4de7-87c4-85872ffb37a2",
      "9e7d1f47-2007-4466-bc4d-279367b75cbd",
      "1018f3ef-bcba-4f64-a8e5-358a154568f0",
      "d27bd733-4ff7-4d1f-9a75-225fa57b38c8",
      "e387d5b1-44a7-49c3-a872-64995ba94e3e",
      "08b88e45-dbbb-41a5-b5aa-79d8bd024e0b",
      "98128b91-c86d-4b54-8876-6d7cdd36d074",
      "9ee4bdb5-f840-4579-a063-93dbc8e05177",
      "783795c3-d17b-4c73-8988-910103a6b3f5",
      "b59ace52-dbb0-424e-840e-8c76f7fffc92",
      "682f6373-a6b2-44b4-ac1a-6021554c7a63",
      "139b4af4-45f0-4f99-b1d8-68ef796b9fde",
      "0cb6552a-f94c-4b6c-98b6-e54c7d8622f2",
      "0c5a62e0-79f6-479c-a362-61d4c4463560",
      "e1f399d1-7435-4fff-b467-bc3747f766b5",
      "7054d2b3-e5c1-4a85-926e-22dbb80a7b55",
      "b942a8c1-ed90-4039-ba95-24bdaddac694",
      "fbff58b6-9b06-4a9f-9e4b-f11c33ae3bde",
      "cf57cd5f-ae9b-4325-9d7e-e9b77fa0c75a",
      "36626e62-c177-4a37-961c-29a9b37082d0",
      "fa4b049e-5699-43c9-bffb-9dda4ade6b8b",
      "1bc8c17d-58cd-47c2-a1e2-5198b88fa138"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1550442432011,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1550713860000,
    "parent_id": "9dda7a1a-881c-4c8e-9319-248534575bdb",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Creating a Custom Dragging Behavior with UIDynamicAnimator"
        ]
      ]
    },
    "type": "page",
    "version": 8,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432005,
        "id": "59375cd4-a18f-4513-b574-f4d5162446c1",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432005,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "This example shows how to create a custom dragging behavior by Subclassing "
            ],
            [
              "UIDynamicBehavior",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " and subclassing "
            ],
            [
              "UICollectionViewFlowLayout",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ". In the example, we have "
            ],
            [
              "UICollectionView",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " that allows for the selection of multiple items. Then with a long press gesture those items can be dragged in an elastic, “springy” animation driven by a "
            ],
            [
              "UIDynamicAnimator",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "This example shows how to create a custom dragging behavior by Subclassing "
          },
          {
            "Text": "UIDynamicBehavior",
            "AttrFlags": 2
          },
          {
            "Text": " and subclassing "
          },
          {
            "Text": "UICollectionViewFlowLayout",
            "AttrFlags": 2
          },
          {
            "Text": ". In the example, we have "
          },
          {
            "Text": "UICollectionView",
            "AttrFlags": 2
          },
          {
            "Text": " that allows for the selection of multiple items. Then with a long press gesture those items can be dragged in an elastic, “springy” animation driven by a "
          },
          {
            "Text": "UIDynamicAnimator",
            "AttrFlags": 2
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432007,
        "id": "e0f46734-30d8-4a6b-98ae-7792c9789f03",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432007,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "source": [
            [
              "https://i.stack.imgur.com/gIzQu.gif"
            ]
          ]
        },
        "type": "image",
        "version": 1,
        "source": "https://i.stack.imgur.com/gIzQu.gif",
        "image_url": "https://www.notion.so/image/https:%2F%2Fi.stack.imgur.com%2FgIzQu.gif"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432007,
        "id": "37f03dea-1e1d-4de7-87c4-85872ffb37a2",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432007,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The dragging behavior is produced by combining a low-level behavior that adds a "
            ],
            [
              "UIAttachmentBehavior",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " to the for corners of a "
            ],
            [
              "UIDynamicItem",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " and a high-level behavior that manages the low-level behavior for a number of "
            ],
            [
              "UIDynamicItems",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The dragging behavior is produced by combining a low-level behavior that adds a "
          },
          {
            "Text": "UIAttachmentBehavior",
            "AttrFlags": 2
          },
          {
            "Text": " to the for corners of a "
          },
          {
            "Text": "UIDynamicItem",
            "AttrFlags": 2
          },
          {
            "Text": " and a high-level behavior that manages the low-level behavior for a number of "
          },
          {
            "Text": "UIDynamicItems",
            "AttrFlags": 2
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432008,
        "id": "9e7d1f47-2007-4466-bc4d-279367b75cbd",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432008,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "We can begin by creating this low-level behavior, we’ll call "
            ],
            [
              "RectangleAttachmentBehavior",
              [
                [
                  "c"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "We can begin by creating this low-level behavior, we’ll call "
          },
          {
            "Text": "RectangleAttachmentBehavior",
            "AttrFlags": 2
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432008,
        "id": "1018f3ef-bcba-4f64-a8e5-358a154568f0",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432008,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Swift"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Swift"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432008,
        "id": "d27bd733-4ff7-4d1f-9a75-225fa57b38c8",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432008,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "final class RectangleAttachmentBehavior: UIDynamicBehavior\n{\n    init(item: UIDynamicItem, point: CGPoint)\n    {\n        // Higher frequency more \"ridged\" formation\n        let frequency: CGFloat = 8.0\n        \n        // Lower damping longer animation takes to come to rest\n        let damping: CGFloat = 0.6\n        \n        super.init()\n        \n        // Attachment points are four corners of item\n        let points = self.attachmentPoints(for: point)\n        \n        let attachmentBehaviors: [UIAttachmentBehavior] = points.map\n        {\n            let attachmentBehavior = UIAttachmentBehavior(item: item, attachedToAnchor: $0)\n            attachmentBehavior.frequency = frequency\n            attachmentBehavior.damping = damping\n            return attachmentBehavior\n        }\n        \n        attachmentBehaviors.forEach\n        {\n            addChildBehavior($0)\n        }\n    }\n    \n    func updateAttachmentLocation(with point: CGPoint)\n    {\n        // Update anchor points to new attachment points\n        let points = self.attachmentPoints(for: point)\n        let attachments = self.childBehaviors.flatMap { $0 as? UIAttachmentBehavior }\n        let pairs = zip(points, attachments)\n        pairs.forEach { $0.1.anchorPoint = $0.0 }\n    }\n    \n    func attachmentPoints(for point: CGPoint) -\u003e [CGPoint]\n    {\n        // Width and height should be close to the width and height of the item\n        let width: CGFloat = 40.0\n        let height: CGFloat = 40.0\n        \n        let topLeft = CGPoint(x: point.x - width * 0.5, y: point.y - height * 0.5)\n        let topRight = CGPoint(x: point.x + width * 0.5, y: point.y - height * 0.5)\n        let bottomLeft = CGPoint(x: point.x - width * 0.5, y: point.y + height * 0.5)\n        let bottomRight = CGPoint(x: point.x + width * 0.5, y: point.y + height * 0.5)\n        let points = [topLeft, topRight, bottomLeft, bottomRight]\n        return points\n    }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "final class RectangleAttachmentBehavior: UIDynamicBehavior\n{\n    init(item: UIDynamicItem, point: CGPoint)\n    {\n        // Higher frequency more \"ridged\" formation\n        let frequency: CGFloat = 8.0\n        \n        // Lower damping longer animation takes to come to rest\n        let damping: CGFloat = 0.6\n        \n        super.init()\n        \n        // Attachment points are four corners of item\n        let points = self.attachmentPoints(for: point)\n        \n        let attachmentBehaviors: [UIAttachmentBehavior] = points.map\n        {\n            let attachmentBehavior = UIAttachmentBehavior(item: item, attachedToAnchor: $0)\n            attachmentBehavior.frequency = frequency\n            attachmentBehavior.damping = damping\n            return attachmentBehavior\n        }\n        \n        attachmentBehaviors.forEach\n        {\n            addChildBehavior($0)\n        }\n    }\n    \n    func updateAttachmentLocation(with point: CGPoint)\n    {\n        // Update anchor points to new attachment points\n        let points = self.attachmentPoints(for: point)\n        let attachments = self.childBehaviors.flatMap { $0 as? UIAttachmentBehavior }\n        let pairs = zip(points, attachments)\n        pairs.forEach { $0.1.anchorPoint = $0.0 }\n    }\n    \n    func attachmentPoints(for point: CGPoint) -\u003e [CGPoint]\n    {\n        // Width and height should be close to the width and height of the item\n        let width: CGFloat = 40.0\n        let height: CGFloat = 40.0\n        \n        let topLeft = CGPoint(x: point.x - width * 0.5, y: point.y - height * 0.5)\n        let topRight = CGPoint(x: point.x + width * 0.5, y: point.y - height * 0.5)\n        let bottomLeft = CGPoint(x: point.x - width * 0.5, y: point.y + height * 0.5)\n        let bottomRight = CGPoint(x: point.x + width * 0.5, y: point.y + height * 0.5)\n        let points = [topLeft, topRight, bottomLeft, bottomRight]\n        return points\n    }\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432008,
        "id": "e387d5b1-44a7-49c3-a872-64995ba94e3e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432008,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Objective-C"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Objective-C"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432008,
        "id": "08b88e45-dbbb-41a5-b5aa-79d8bd024e0b",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432008,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "@implementation RectangleAttachmentBehavior\n\n- (instancetype)initWithItem:(id\u003cUIDynamicItem\u003e)item point:(CGPoint)point\n{\n    CGFloat frequency = 8.0f;\n    CGFloat damping = 0.6f;\n    self = [super init];\n    if (self)\n    {\n        NSArray \u003cNSValue *\u003e *pointValues = [self attachmentPointValuesForPoint:point];\n        for (NSValue *value in pointValues)\n        {\n            UIAttachmentBehavior *attachment = [[UIAttachmentBehavior alloc]initWithItem:item attachedToAnchor:[value CGPointValue]];\n            attachment.frequency = frequency;\n            attachment.damping = damping;\n            [self addChildBehavior:attachment];\n        }\n    }\n    return self;\n}\n\n- (void)updateAttachmentLocationWithPoint:(CGPoint)point\n{\n    NSArray \u003cNSValue *\u003e *pointValues = [self attachmentPointValuesForPoint:point];\n    for (NSInteger i = 0; i \u003c pointValues.count; i++)\n    {\n        NSValue *pointValue = pointValues[i];\n        UIAttachmentBehavior *attachment = self.childBehaviors[i];\n        attachment.anchorPoint = [pointValue CGPointValue];\n    }\n}\n\n- (NSArray \u003cNSValue *\u003e *)attachmentPointValuesForPoint:(CGPoint)point\n{\n    CGFloat width = 40.0f;\n    CGFloat height = 40.0f;\n    \n    CGPoint topLeft = CGPointMake(point.x - width * 0.5, point.y - height * 0.5);\n    CGPoint topRight = CGPointMake(point.x + width * 0.5, point.y - height * 0.5);\n    CGPoint bottomLeft = CGPointMake(point.x - width * 0.5, point.y + height * 0.5);\n    CGPoint bottomRight = CGPointMake(point.x + width * 0.5, point.y + height * 0.5);\n    \n    NSArray \u003cNSValue *\u003e *pointValues = @[[NSValue valueWithCGPoint:topLeft], [NSValue valueWithCGPoint:topRight], [NSValue valueWithCGPoint:bottomLeft], [NSValue valueWithCGPoint:bottomRight]];\n    return pointValues;\n}\n\n@end"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "@implementation RectangleAttachmentBehavior\n\n- (instancetype)initWithItem:(id\u003cUIDynamicItem\u003e)item point:(CGPoint)point\n{\n    CGFloat frequency = 8.0f;\n    CGFloat damping = 0.6f;\n    self = [super init];\n    if (self)\n    {\n        NSArray \u003cNSValue *\u003e *pointValues = [self attachmentPointValuesForPoint:point];\n        for (NSValue *value in pointValues)\n        {\n            UIAttachmentBehavior *attachment = [[UIAttachmentBehavior alloc]initWithItem:item attachedToAnchor:[value CGPointValue]];\n            attachment.frequency = frequency;\n            attachment.damping = damping;\n            [self addChildBehavior:attachment];\n        }\n    }\n    return self;\n}\n\n- (void)updateAttachmentLocationWithPoint:(CGPoint)point\n{\n    NSArray \u003cNSValue *\u003e *pointValues = [self attachmentPointValuesForPoint:point];\n    for (NSInteger i = 0; i \u003c pointValues.count; i++)\n    {\n        NSValue *pointValue = pointValues[i];\n        UIAttachmentBehavior *attachment = self.childBehaviors[i];\n        attachment.anchorPoint = [pointValue CGPointValue];\n    }\n}\n\n- (NSArray \u003cNSValue *\u003e *)attachmentPointValuesForPoint:(CGPoint)point\n{\n    CGFloat width = 40.0f;\n    CGFloat height = 40.0f;\n    \n    CGPoint topLeft = CGPointMake(point.x - width * 0.5, point.y - height * 0.5);\n    CGPoint topRight = CGPointMake(point.x + width * 0.5, point.y - height * 0.5);\n    CGPoint bottomLeft = CGPointMake(point.x - width * 0.5, point.y + height * 0.5);\n    CGPoint bottomRight = CGPointMake(point.x + width * 0.5, point.y + height * 0.5);\n    \n    NSArray \u003cNSValue *\u003e *pointValues = @[[NSValue valueWithCGPoint:topLeft], [NSValue valueWithCGPoint:topRight], [NSValue valueWithCGPoint:bottomLeft], [NSValue valueWithCGPoint:bottomRight]];\n    return pointValues;\n}\n\n@end",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432008,
        "id": "98128b91-c86d-4b54-8876-6d7cdd36d074",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432008,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Next we can create the high-level behavior that will combine a number of "
            ],
            [
              "RectangleAttachmentBehavior",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Next we can create the high-level behavior that will combine a number of "
          },
          {
            "Text": "RectangleAttachmentBehavior",
            "AttrFlags": 2
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432008,
        "id": "9ee4bdb5-f840-4579-a063-93dbc8e05177",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432008,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Swift"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Swift"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432008,
        "id": "783795c3-d17b-4c73-8988-910103a6b3f5",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432008,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "final class DragBehavior: UIDynamicBehavior\n{\n    init(items: [UIDynamicItem], point: CGPoint)\n    {\n        super.init()\n        items.forEach\n        {\n            let rectAttachment = RectangleAttachmentBehavior(item: $0, point: point)\n            self.addChildBehavior(rectAttachment)\n        }\n    }\n    \n    func updateDragLocation(with point: CGPoint)\n    {\n        // Tell low-level behaviors location has changed\n        self.childBehaviors.flatMap { $0 as? RectangleAttachmentBehavior }.forEach { $0.updateAttachmentLocation(with: point) }\n    }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "final class DragBehavior: UIDynamicBehavior\n{\n    init(items: [UIDynamicItem], point: CGPoint)\n    {\n        super.init()\n        items.forEach\n        {\n            let rectAttachment = RectangleAttachmentBehavior(item: $0, point: point)\n            self.addChildBehavior(rectAttachment)\n        }\n    }\n    \n    func updateDragLocation(with point: CGPoint)\n    {\n        // Tell low-level behaviors location has changed\n        self.childBehaviors.flatMap { $0 as? RectangleAttachmentBehavior }.forEach { $0.updateAttachmentLocation(with: point) }\n    }\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432008,
        "id": "b59ace52-dbb0-424e-840e-8c76f7fffc92",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432008,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Objective-C"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Objective-C"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432008,
        "id": "682f6373-a6b2-44b4-ac1a-6021554c7a63",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432008,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "@implementation DragBehavior\n\n- (instancetype)initWithItems:(NSArray \u003cid\u003cUIDynamicItem\u003e\u003e *)items point: (CGPoint)point\n{\n    self = [super init];\n    if (self)\n    {\n        for (id\u003cUIDynamicItem\u003e item in items)\n        {\n            RectangleAttachmentBehavior *rectAttachment = [[RectangleAttachmentBehavior alloc]initWithItem:item point:point];\n            [self addChildBehavior:rectAttachment];\n        }\n    }\n    return self;\n}\n\n- (void)updateDragLocationWithPoint:(CGPoint)point\n{\n    for (RectangleAttachmentBehavior *rectAttachment in self.childBehaviors)\n    {\n        [rectAttachment updateAttachmentLocationWithPoint:point];\n    }\n}\n\n@end"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "@implementation DragBehavior\n\n- (instancetype)initWithItems:(NSArray \u003cid\u003cUIDynamicItem\u003e\u003e *)items point: (CGPoint)point\n{\n    self = [super init];\n    if (self)\n    {\n        for (id\u003cUIDynamicItem\u003e item in items)\n        {\n            RectangleAttachmentBehavior *rectAttachment = [[RectangleAttachmentBehavior alloc]initWithItem:item point:point];\n            [self addChildBehavior:rectAttachment];\n        }\n    }\n    return self;\n}\n\n- (void)updateDragLocationWithPoint:(CGPoint)point\n{\n    for (RectangleAttachmentBehavior *rectAttachment in self.childBehaviors)\n    {\n        [rectAttachment updateAttachmentLocationWithPoint:point];\n    }\n}\n\n@end",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432009,
        "id": "139b4af4-45f0-4f99-b1d8-68ef796b9fde",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432009,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Now with our behaviors in place, the next step is to add them to our collection view when. Because normally we want a standard grid layout we can subclass "
            ],
            [
              "UICollectionViewFlowLayout",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " and only change attributes when dragging. We do this mainly through overriding "
            ],
            [
              "layoutAttributesForElementsInRect",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " and using the "
            ],
            [
              "UIDynamicAnimator's",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " convenience method "
            ],
            [
              "itemsInRect",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Now with our behaviors in place, the next step is to add them to our collection view when. Because normally we want a standard grid layout we can subclass "
          },
          {
            "Text": "UICollectionViewFlowLayout",
            "AttrFlags": 2
          },
          {
            "Text": " and only change attributes when dragging. We do this mainly through overriding "
          },
          {
            "Text": "layoutAttributesForElementsInRect",
            "AttrFlags": 2
          },
          {
            "Text": " and using the "
          },
          {
            "Text": "UIDynamicAnimator's",
            "AttrFlags": 2
          },
          {
            "Text": " convenience method "
          },
          {
            "Text": "itemsInRect",
            "AttrFlags": 2
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432009,
        "id": "0cb6552a-f94c-4b6c-98b6-e54c7d8622f2",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432009,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Swift"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Swift"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432009,
        "id": "0c5a62e0-79f6-479c-a362-61d4c4463560",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432009,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "final class DraggableLayout: UICollectionViewFlowLayout\n{\n    // Array that holds dragged index paths\n    var indexPathsForDraggingElements: [IndexPath]?\n    \n    // The dynamic animator that will animate drag behavior\n    var animator: UIDynamicAnimator?\n    \n    // Custom high-level behavior that dictates drag animation\n    var dragBehavior: DragBehavior?\n    \n    // Where dragging starts so can return there once dragging ends\n    var startDragPoint = CGPoint.zero\n    \n    // Bool to keep track if dragging has ended\n    var isFinishedDragging = false\n    \n    \n    // Method to inform layout that dragging has started\n    func startDragging(indexPaths selectedIndexPaths: [IndexPath], from point: CGPoint)\n    {\n        indexPathsForDraggingElements = selectedIndexPaths\n        animator = UIDynamicAnimator(collectionViewLayout: self)\n        animator?.delegate = self\n        \n        // Get all of the draggable attributes but change zIndex so above other cells\n        let draggableAttributes: [UICollectionViewLayoutAttributes] = selectedIndexPaths.flatMap {\n            let attribute = super.layoutAttributesForItem(at: $0)\n            attribute?.zIndex = 1\n            return attribute\n        }\n        \n        startDragPoint = point\n        \n        // Add them to high-level behavior\n        dragBehavior = DragBehavior(items: draggableAttributes, point: point)\n        \n        // Add high-level behavior to animator\n        animator?.addBehavior(dragBehavior!)\n    }\n    \n    func updateDragLocation(_ point: CGPoint)\n    {\n        // Tell high-level behavior that point has updated\n        dragBehavior?.updateDragLocation(with: point)\n    }\n    \n    func endDragging()\n    {\n        isFinishedDragging = true\n        \n        // Return high-level behavior to starting point\n        dragBehavior?.updateDragLocation(with: startDragPoint)\n    }\n    \n    func clearDraggedIndexPaths()\n    {\n        // Reset state for next drag event\n        animator = nil\n        indexPathsForDraggingElements = nil\n        isFinishedDragging = false\n    }\n    \n    override func layoutAttributesForElements(in rect: CGRect) -\u003e [UICollectionViewLayoutAttributes]?\n    {\n        let existingAttributes: [UICollectionViewLayoutAttributes] = super.layoutAttributesForElements(in: rect) ?? []\n        var allAttributes = [UICollectionViewLayoutAttributes]()\n        \n        // Get normal flow layout attributes for non-drag items\n        for attributes in existingAttributes\n        {\n            if (indexPathsForDraggingElements?.contains(attributes.indexPath) ?? false) == false\n            {\n                allAttributes.append(attributes)\n            }\n        }\n        \n        // Add dragged item attributes by asking animator for them\n        if let animator = self.animator\n        {\n            let animatorAttributes: [UICollectionViewLayoutAttributes] = animator.items(in: rect).flatMap { $0 as? UICollectionViewLayoutAttributes }\n            allAttributes.append(contentsOf: animatorAttributes)\n        }\n        return allAttributes\n    }\n}\nextension DraggableLayout: UIDynamicAnimatorDelegate\n{\n    func dynamicAnimatorDidPause(_ animator: UIDynamicAnimator)\n    {\n        // Animator has paused and done dragging; reset state\n        guard isFinishedDragging else { return }\n        clearDraggedIndexPaths()\n    }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "final class DraggableLayout: UICollectionViewFlowLayout\n{\n    // Array that holds dragged index paths\n    var indexPathsForDraggingElements: [IndexPath]?\n    \n    // The dynamic animator that will animate drag behavior\n    var animator: UIDynamicAnimator?\n    \n    // Custom high-level behavior that dictates drag animation\n    var dragBehavior: DragBehavior?\n    \n    // Where dragging starts so can return there once dragging ends\n    var startDragPoint = CGPoint.zero\n    \n    // Bool to keep track if dragging has ended\n    var isFinishedDragging = false\n    \n    \n    // Method to inform layout that dragging has started\n    func startDragging(indexPaths selectedIndexPaths: [IndexPath], from point: CGPoint)\n    {\n        indexPathsForDraggingElements = selectedIndexPaths\n        animator = UIDynamicAnimator(collectionViewLayout: self)\n        animator?.delegate = self\n        \n        // Get all of the draggable attributes but change zIndex so above other cells\n        let draggableAttributes: [UICollectionViewLayoutAttributes] = selectedIndexPaths.flatMap {\n            let attribute = super.layoutAttributesForItem(at: $0)\n            attribute?.zIndex = 1\n            return attribute\n        }\n        \n        startDragPoint = point\n        \n        // Add them to high-level behavior\n        dragBehavior = DragBehavior(items: draggableAttributes, point: point)\n        \n        // Add high-level behavior to animator\n        animator?.addBehavior(dragBehavior!)\n    }\n    \n    func updateDragLocation(_ point: CGPoint)\n    {\n        // Tell high-level behavior that point has updated\n        dragBehavior?.updateDragLocation(with: point)\n    }\n    \n    func endDragging()\n    {\n        isFinishedDragging = true\n        \n        // Return high-level behavior to starting point\n        dragBehavior?.updateDragLocation(with: startDragPoint)\n    }\n    \n    func clearDraggedIndexPaths()\n    {\n        // Reset state for next drag event\n        animator = nil\n        indexPathsForDraggingElements = nil\n        isFinishedDragging = false\n    }\n    \n    override func layoutAttributesForElements(in rect: CGRect) -\u003e [UICollectionViewLayoutAttributes]?\n    {\n        let existingAttributes: [UICollectionViewLayoutAttributes] = super.layoutAttributesForElements(in: rect) ?? []\n        var allAttributes = [UICollectionViewLayoutAttributes]()\n        \n        // Get normal flow layout attributes for non-drag items\n        for attributes in existingAttributes\n        {\n            if (indexPathsForDraggingElements?.contains(attributes.indexPath) ?? false) == false\n            {\n                allAttributes.append(attributes)\n            }\n        }\n        \n        // Add dragged item attributes by asking animator for them\n        if let animator = self.animator\n        {\n            let animatorAttributes: [UICollectionViewLayoutAttributes] = animator.items(in: rect).flatMap { $0 as? UICollectionViewLayoutAttributes }\n            allAttributes.append(contentsOf: animatorAttributes)\n        }\n        return allAttributes\n    }\n}\nextension DraggableLayout: UIDynamicAnimatorDelegate\n{\n    func dynamicAnimatorDidPause(_ animator: UIDynamicAnimator)\n    {\n        // Animator has paused and done dragging; reset state\n        guard isFinishedDragging else { return }\n        clearDraggedIndexPaths()\n    }\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432009,
        "id": "e1f399d1-7435-4fff-b467-bc3747f766b5",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432009,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Objective-C"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Objective-C"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432009,
        "id": "7054d2b3-e5c1-4a85-926e-22dbb80a7b55",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432009,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "@interface DraggableLayout () \u003cUIDynamicAnimatorDelegate\u003e\n@property (nonatomic, strong) NSArray \u003cNSIndexPath *\u003e *indexPathsForDraggingElements;\n@property (nonatomic, strong) UIDynamicAnimator *animator;\n@property (nonatomic, assign) CGPoint startDragPoint;\n@property (nonatomic, assign) BOOL finishedDragging;\n@property (nonatomic, strong) DragBehavior *dragBehavior;\n@end\n\n@implementation DraggableLayout\n\n- (void)startDraggingWithIndexPaths:(NSArray \u003cNSIndexPath *\u003e *)selectedIndexPaths fromPoint:(CGPoint)point\n{\n    self.indexPathsForDraggingElements = selectedIndexPaths;\n    self.animator = [[UIDynamicAnimator alloc]initWithCollectionViewLayout:self];\n    self.animator.delegate = self;\n    NSMutableArray *draggableAttributes = [[NSMutableArray alloc]initWithCapacity:selectedIndexPaths.count];\n    for (NSIndexPath *indexPath in selectedIndexPaths)\n    {\n        UICollectionViewLayoutAttributes *attributes = [super layoutAttributesForItemAtIndexPath:indexPath];\n        attributes.zIndex = 1;\n        [draggableAttributes addObject:attributes];\n    }\n    self.startDragPoint = point;\n    self.dragBehavior = [[DragBehavior alloc]initWithItems:draggableAttributes point:point];\n    [self.animator addBehavior:self.dragBehavior];\n}\n\n- (void)updateDragLoactionWithPoint:(CGPoint)point\n{\n    [self.dragBehavior updateDragLocationWithPoint:point];\n}\n\n- (void)endDragging\n{\n    self.finishedDragging = YES;\n    [self.dragBehavior updateDragLocationWithPoint:self.startDragPoint];\n}\n\n- (void)clearDraggedIndexPath\n{\n    self.animator = nil;\n    self.indexPathsForDraggingElements = nil;\n    self.finishedDragging = NO;\n}\n\n- (void)dynamicAnimatorDidPause:(UIDynamicAnimator *)animator\n{\n    if (self.finishedDragging)\n    {\n        [self clearDraggedIndexPath];\n    }\n}\n\n- (NSArray\u003cUICollectionViewLayoutAttributes *\u003e *)layoutAttributesForElementsInRect:(CGRect)rect\n{\n    NSArray *existingAttributes = [super layoutAttributesForElementsInRect:rect];\n    NSMutableArray *allAttributes = [[NSMutableArray alloc]initWithCapacity:existingAttributes.count];\n    for (UICollectionViewLayoutAttributes *attributes in existingAttributes)\n    {\n        if (![self.indexPathsForDraggingElements containsObject:attributes.indexPath])\n        {\n            [allAttributes addObject:attributes];\n        }\n    }\n    [allAttributes addObjectsFromArray:[self.animator itemsInRect:rect]];\n    return allAttributes;\n}\n\n@end"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "@interface DraggableLayout () \u003cUIDynamicAnimatorDelegate\u003e\n@property (nonatomic, strong) NSArray \u003cNSIndexPath *\u003e *indexPathsForDraggingElements;\n@property (nonatomic, strong) UIDynamicAnimator *animator;\n@property (nonatomic, assign) CGPoint startDragPoint;\n@property (nonatomic, assign) BOOL finishedDragging;\n@property (nonatomic, strong) DragBehavior *dragBehavior;\n@end\n\n@implementation DraggableLayout\n\n- (void)startDraggingWithIndexPaths:(NSArray \u003cNSIndexPath *\u003e *)selectedIndexPaths fromPoint:(CGPoint)point\n{\n    self.indexPathsForDraggingElements = selectedIndexPaths;\n    self.animator = [[UIDynamicAnimator alloc]initWithCollectionViewLayout:self];\n    self.animator.delegate = self;\n    NSMutableArray *draggableAttributes = [[NSMutableArray alloc]initWithCapacity:selectedIndexPaths.count];\n    for (NSIndexPath *indexPath in selectedIndexPaths)\n    {\n        UICollectionViewLayoutAttributes *attributes = [super layoutAttributesForItemAtIndexPath:indexPath];\n        attributes.zIndex = 1;\n        [draggableAttributes addObject:attributes];\n    }\n    self.startDragPoint = point;\n    self.dragBehavior = [[DragBehavior alloc]initWithItems:draggableAttributes point:point];\n    [self.animator addBehavior:self.dragBehavior];\n}\n\n- (void)updateDragLoactionWithPoint:(CGPoint)point\n{\n    [self.dragBehavior updateDragLocationWithPoint:point];\n}\n\n- (void)endDragging\n{\n    self.finishedDragging = YES;\n    [self.dragBehavior updateDragLocationWithPoint:self.startDragPoint];\n}\n\n- (void)clearDraggedIndexPath\n{\n    self.animator = nil;\n    self.indexPathsForDraggingElements = nil;\n    self.finishedDragging = NO;\n}\n\n- (void)dynamicAnimatorDidPause:(UIDynamicAnimator *)animator\n{\n    if (self.finishedDragging)\n    {\n        [self clearDraggedIndexPath];\n    }\n}\n\n- (NSArray\u003cUICollectionViewLayoutAttributes *\u003e *)layoutAttributesForElementsInRect:(CGRect)rect\n{\n    NSArray *existingAttributes = [super layoutAttributesForElementsInRect:rect];\n    NSMutableArray *allAttributes = [[NSMutableArray alloc]initWithCapacity:existingAttributes.count];\n    for (UICollectionViewLayoutAttributes *attributes in existingAttributes)\n    {\n        if (![self.indexPathsForDraggingElements containsObject:attributes.indexPath])\n        {\n            [allAttributes addObject:attributes];\n        }\n    }\n    [allAttributes addObjectsFromArray:[self.animator itemsInRect:rect]];\n    return allAttributes;\n}\n\n@end",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432009,
        "id": "b942a8c1-ed90-4039-ba95-24bdaddac694",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432009,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Finally, we’ll create a view controller that will create our "
            ],
            [
              "UICollectionView",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " and handle our long press gesture."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Finally, we’ll create a view controller that will create our "
          },
          {
            "Text": "UICollectionView",
            "AttrFlags": 2
          },
          {
            "Text": " and handle our long press gesture."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432009,
        "id": "fbff58b6-9b06-4a9f-9e4b-f11c33ae3bde",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432009,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Swift"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Swift"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432009,
        "id": "cf57cd5f-ae9b-4325-9d7e-e9b77fa0c75a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432009,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "final class ViewController: UIViewController\n{\n    // Collection view that displays cells\n    lazy var collectionView: UICollectionView =\n    {\n        let collectionView = UICollectionView(frame: .zero, collectionViewLayout: DraggableLayout())\n        collectionView.backgroundColor = .white\n        collectionView.translatesAutoresizingMaskIntoConstraints = false\n        self.view.addSubview(collectionView)\n        collectionView.topAnchor.constraint(equalTo: self.topLayoutGuide.bottomAnchor).isActive = true\n        collectionView.leadingAnchor.constraint(equalTo: self.view.leadingAnchor).isActive = true\n        collectionView.trailingAnchor.constraint(equalTo: self.view.trailingAnchor).isActive = true\n        collectionView.bottomAnchor.constraint(equalTo: self.bottomLayoutGuide.topAnchor).isActive = true\n        \n        return collectionView\n    }()\n    \n    // Gesture that drives dragging\n    lazy var longPress: UILongPressGestureRecognizer =\n    {\n        let longPress = UILongPressGestureRecognizer(target: self, action: #selector(self.handleLongPress(sender:)))\n        return longPress\n    }()\n    \n    // Array that holds selected index paths\n    var selectedIndexPaths = [IndexPath]()\n    \n    override func viewDidLoad()\n    {\n        super.viewDidLoad()\n        collectionView.delegate = self\n        collectionView.dataSource = self\n        collectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: \"Cell\")\n        collectionView.addGestureRecognizer(longPress)\n    }\n    \n    func handleLongPress(sender: UILongPressGestureRecognizer)\n    {\n        guard let draggableLayout = collectionView.collectionViewLayout as? DraggableLayout else { return }\n        let location = sender.location(in: collectionView)\n        switch sender.state\n        {\n        case .began:\n            draggableLayout.startDragging(indexPaths: selectedIndexPaths, from: location)\n        case .changed:\n            draggableLayout.updateDragLocation(location)\n        case .ended, .failed, .cancelled:\n            draggableLayout.endDragging()\n        case .possible:\n            break\n        }\n    }\n}\nextension ViewController: UICollectionViewDelegate, UICollectionViewDataSource\n{\n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -\u003e Int\n    {\n        return 1000\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -\u003e UICollectionViewCell\n    {\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"Cell\", for: indexPath)\n        cell.backgroundColor = .gray\n        if selectedIndexPaths.contains(indexPath) == true\n        {\n            cell.backgroundColor = .red\n        }\n        return cell\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)\n    {\n        // Bool that determines if cell is being selected or unselected\n        let isSelected = !selectedIndexPaths.contains(indexPath)\n        let cell = collectionView.cellForItem(at: indexPath)\n        cell?.backgroundColor = isSelected ? .red : .gray\n        if isSelected\n        {\n            selectedIndexPaths.append(indexPath)\n        }\n        else\n        {\n            selectedIndexPaths.remove(at: selectedIndexPaths.index(of: indexPath)!)\n        }\n    }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "final class ViewController: UIViewController\n{\n    // Collection view that displays cells\n    lazy var collectionView: UICollectionView =\n    {\n        let collectionView = UICollectionView(frame: .zero, collectionViewLayout: DraggableLayout())\n        collectionView.backgroundColor = .white\n        collectionView.translatesAutoresizingMaskIntoConstraints = false\n        self.view.addSubview(collectionView)\n        collectionView.topAnchor.constraint(equalTo: self.topLayoutGuide.bottomAnchor).isActive = true\n        collectionView.leadingAnchor.constraint(equalTo: self.view.leadingAnchor).isActive = true\n        collectionView.trailingAnchor.constraint(equalTo: self.view.trailingAnchor).isActive = true\n        collectionView.bottomAnchor.constraint(equalTo: self.bottomLayoutGuide.topAnchor).isActive = true\n        \n        return collectionView\n    }()\n    \n    // Gesture that drives dragging\n    lazy var longPress: UILongPressGestureRecognizer =\n    {\n        let longPress = UILongPressGestureRecognizer(target: self, action: #selector(self.handleLongPress(sender:)))\n        return longPress\n    }()\n    \n    // Array that holds selected index paths\n    var selectedIndexPaths = [IndexPath]()\n    \n    override func viewDidLoad()\n    {\n        super.viewDidLoad()\n        collectionView.delegate = self\n        collectionView.dataSource = self\n        collectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: \"Cell\")\n        collectionView.addGestureRecognizer(longPress)\n    }\n    \n    func handleLongPress(sender: UILongPressGestureRecognizer)\n    {\n        guard let draggableLayout = collectionView.collectionViewLayout as? DraggableLayout else { return }\n        let location = sender.location(in: collectionView)\n        switch sender.state\n        {\n        case .began:\n            draggableLayout.startDragging(indexPaths: selectedIndexPaths, from: location)\n        case .changed:\n            draggableLayout.updateDragLocation(location)\n        case .ended, .failed, .cancelled:\n            draggableLayout.endDragging()\n        case .possible:\n            break\n        }\n    }\n}\nextension ViewController: UICollectionViewDelegate, UICollectionViewDataSource\n{\n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -\u003e Int\n    {\n        return 1000\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -\u003e UICollectionViewCell\n    {\n        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"Cell\", for: indexPath)\n        cell.backgroundColor = .gray\n        if selectedIndexPaths.contains(indexPath) == true\n        {\n            cell.backgroundColor = .red\n        }\n        return cell\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)\n    {\n        // Bool that determines if cell is being selected or unselected\n        let isSelected = !selectedIndexPaths.contains(indexPath)\n        let cell = collectionView.cellForItem(at: indexPath)\n        cell?.backgroundColor = isSelected ? .red : .gray\n        if isSelected\n        {\n            selectedIndexPaths.append(indexPath)\n        }\n        else\n        {\n            selectedIndexPaths.remove(at: selectedIndexPaths.index(of: indexPath)!)\n        }\n    }\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432009,
        "id": "36626e62-c177-4a37-961c-29a9b37082d0",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432009,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Objective-C"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Objective-C"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432009,
        "id": "fa4b049e-5699-43c9-bffb-9dda4ade6b8b",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432009,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "@interface ViewController () \u003cUICollectionViewDelegate, UICollectionViewDataSource\u003e\n@property (nonatomic, strong) UICollectionView *collectionView;\n@property (nonatomic, strong) UILongPressGestureRecognizer *longPress;\n@property (nonatomic, strong) NSMutableArray \u003cNSIndexPath *\u003e *selectedIndexPaths;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    self.collectionView.delegate = self;\n    self.collectionView.dataSource = self;\n    [self.collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@\"Cell\"];\n    [self.collectionView addGestureRecognizer:self.longPress];\n    self.selectedIndexPaths = [[NSMutableArray alloc]init];\n}\n\n- (UICollectionView *)collectionView\n{\n    if (!_collectionView)\n    {\n        _collectionView = [[UICollectionView alloc]initWithFrame:CGRectZero collectionViewLayout:[[DraggableLayout alloc]init]];\n        _collectionView.backgroundColor = [UIColor whiteColor];\n        _collectionView.translatesAutoresizingMaskIntoConstraints = NO;\n        [self.view addSubview:_collectionView];\n        [_collectionView.topAnchor constraintEqualToAnchor:self.topLayoutGuide.bottomAnchor].active = YES;\n        [_collectionView.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor].active = YES;\n        [_collectionView.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor].active = YES;\n        [_collectionView.bottomAnchor constraintEqualToAnchor:self.bottomLayoutGuide.topAnchor].active = YES;\n    }\n    return _collectionView;\n}\n\n- (UILongPressGestureRecognizer *)longPress\n{\n    if (!_longPress)\n    {\n        _longPress = [[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(handleLongPress:)];\n    }\n    return _longPress;\n}\n\n- (void)handleLongPress:(UILongPressGestureRecognizer *)sender\n{\n    DraggableLayout *draggableLayout = (DraggableLayout *)self.collectionView.collectionViewLayout;\n    CGPoint location = [sender locationInView:self.collectionView];\n    if (sender.state == UIGestureRecognizerStateBegan)\n    {\n        [draggableLayout startDraggingWithIndexPaths:self.selectedIndexPaths fromPoint:location];\n    }\n    else if(sender.state == UIGestureRecognizerStateChanged)\n    {\n        [draggableLayout updateDragLoactionWithPoint:location];\n    }\n    else if(sender.state == UIGestureRecognizerStateEnded ||  sender.state == UIGestureRecognizerStateCancelled || sender.state == UIGestureRecognizerStateFailed)\n    {\n        [draggableLayout endDragging];\n    }\n}\n\n- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section\n{\n    return 1000;\n}\n\n- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@\"Cell\" forIndexPath:indexPath];\n    cell.backgroundColor = [UIColor grayColor];\n    if ([self.selectedIndexPaths containsObject:indexPath])\n    {\n        cell.backgroundColor = [UIColor redColor];\n    }\n    return cell;\n}\n\n- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    BOOL isSelected = ![self.selectedIndexPaths containsObject:indexPath];\n    UICollectionViewCell *cell = [collectionView cellForItemAtIndexPath:indexPath];\n    if (isSelected)\n    {\n        cell.backgroundColor = [UIColor redColor];\n        [self.selectedIndexPaths addObject:indexPath];\n    }\n    else\n    {\n        cell.backgroundColor = [UIColor grayColor];\n        [self.selectedIndexPaths removeObject:indexPath];\n    }\n}\n\n@end"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "@interface ViewController () \u003cUICollectionViewDelegate, UICollectionViewDataSource\u003e\n@property (nonatomic, strong) UICollectionView *collectionView;\n@property (nonatomic, strong) UILongPressGestureRecognizer *longPress;\n@property (nonatomic, strong) NSMutableArray \u003cNSIndexPath *\u003e *selectedIndexPaths;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    self.collectionView.delegate = self;\n    self.collectionView.dataSource = self;\n    [self.collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@\"Cell\"];\n    [self.collectionView addGestureRecognizer:self.longPress];\n    self.selectedIndexPaths = [[NSMutableArray alloc]init];\n}\n\n- (UICollectionView *)collectionView\n{\n    if (!_collectionView)\n    {\n        _collectionView = [[UICollectionView alloc]initWithFrame:CGRectZero collectionViewLayout:[[DraggableLayout alloc]init]];\n        _collectionView.backgroundColor = [UIColor whiteColor];\n        _collectionView.translatesAutoresizingMaskIntoConstraints = NO;\n        [self.view addSubview:_collectionView];\n        [_collectionView.topAnchor constraintEqualToAnchor:self.topLayoutGuide.bottomAnchor].active = YES;\n        [_collectionView.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor].active = YES;\n        [_collectionView.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor].active = YES;\n        [_collectionView.bottomAnchor constraintEqualToAnchor:self.bottomLayoutGuide.topAnchor].active = YES;\n    }\n    return _collectionView;\n}\n\n- (UILongPressGestureRecognizer *)longPress\n{\n    if (!_longPress)\n    {\n        _longPress = [[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(handleLongPress:)];\n    }\n    return _longPress;\n}\n\n- (void)handleLongPress:(UILongPressGestureRecognizer *)sender\n{\n    DraggableLayout *draggableLayout = (DraggableLayout *)self.collectionView.collectionViewLayout;\n    CGPoint location = [sender locationInView:self.collectionView];\n    if (sender.state == UIGestureRecognizerStateBegan)\n    {\n        [draggableLayout startDraggingWithIndexPaths:self.selectedIndexPaths fromPoint:location];\n    }\n    else if(sender.state == UIGestureRecognizerStateChanged)\n    {\n        [draggableLayout updateDragLoactionWithPoint:location];\n    }\n    else if(sender.state == UIGestureRecognizerStateEnded ||  sender.state == UIGestureRecognizerStateCancelled || sender.state == UIGestureRecognizerStateFailed)\n    {\n        [draggableLayout endDragging];\n    }\n}\n\n- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section\n{\n    return 1000;\n}\n\n- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@\"Cell\" forIndexPath:indexPath];\n    cell.backgroundColor = [UIColor grayColor];\n    if ([self.selectedIndexPaths containsObject:indexPath])\n    {\n        cell.backgroundColor = [UIColor redColor];\n    }\n    return cell;\n}\n\n- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    BOOL isSelected = ![self.selectedIndexPaths containsObject:indexPath];\n    UICollectionViewCell *cell = [collectionView cellForItemAtIndexPath:indexPath];\n    if (isSelected)\n    {\n        cell.backgroundColor = [UIColor redColor];\n        [self.selectedIndexPaths addObject:indexPath];\n    }\n    else\n    {\n        cell.backgroundColor = [UIColor grayColor];\n        [self.selectedIndexPaths removeObject:indexPath];\n    }\n}\n\n@end",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550442432011,
        "id": "1bc8c17d-58cd-47c2-a1e2-5198b88fa138",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550442432011,
        "parent_id": "f8374e53-6d99-4a40-bac9-1bd872d8eb60",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "For more information "
            ],
            [
              "2013 WWDC Session “Advanced Techniques with UIKit Dynamics”",
              [
                [
                  "a",
                  "https://developer.apple.com/videos/play/wwdc2013/221/"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "For more information "
          },
          {
            "Text": "2013 WWDC Session “Advanced Techniques with UIKit Dynamics”",
            "Link": "https://developer.apple.com/videos/play/wwdc2013/221/"
          }
        ]
      }
    ],
    "title": "Creating a Custom Dragging Behavior with UIDynamicAnimator",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}