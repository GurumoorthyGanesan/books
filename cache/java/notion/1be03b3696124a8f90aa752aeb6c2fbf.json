{
  "ID": "1be03b36-9612-4a8f-90aa-752aeb6c2fbf",
  "Root": {
    "alive": true,
    "content": [
      "39f735eb-76a0-4652-84f8-0a66de4b6f82",
      "3f67d171-c9f7-4b2d-9006-59c4e84eab8d",
      "64935e6d-fa80-45dc-a827-8245445aaea7",
      "cca82360-4972-414a-a866-9c3569bb8613",
      "a463daed-1171-4c65-985f-c4d36db8691b",
      "92f43744-fa6b-4c09-99ac-74aa36ef3244",
      "c63d11ae-b243-4485-9ccd-7aae324b38c0",
      "423ad708-c07d-4423-82d3-b91b832886e0",
      "2c7bf8fd-8de4-4307-b677-31f1fe6411f4",
      "35a8c6be-7163-4c27-9fc7-5abdab4d3f48",
      "e5074f71-395a-45c4-9dd6-e33a9048583f",
      "47ee7923-f7a6-4fa1-ab56-aa7e27b4a1bb",
      "6d7b310a-0341-4aff-b6d4-a63662f6436d",
      "e643d48a-9f05-479a-9b14-47e1e6443fd5"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1550518713541,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "1be03b36-9612-4a8f-90aa-752aeb6c2fbf",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1551768751252,
    "parent_id": "7d132e6d-be71-4378-97d7-6e67b266d858",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Implementing policy deny rules"
        ]
      ]
    },
    "type": "page",
    "version": 5,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518713538,
        "id": "39f735eb-76a0-4652-84f8-0a66de4b6f82",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518713538,
        "parent_id": "1be03b36-9612-4a8f-90aa-752aeb6c2fbf",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "It is occasionally desirable to "
            ],
            [
              "deny",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " a certain "
            ],
            [
              "Permission",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " to some "
            ],
            [
              "ProtectionDomain",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "regardless",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " of any other permissions that domain accrues. This example demonstrates just one of all the possible approaches for satisfying this kind of requirement. It introduces a “negative” permission class, along with a wrapper that enables the default "
            ],
            [
              "Policy",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " to be reused as a repository of such permissions."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "It is occasionally desirable to "
          },
          {
            "Text": "deny",
            "AttrFlags": 4
          },
          {
            "Text": " a certain "
          },
          {
            "Text": "Permission",
            "AttrFlags": 2
          },
          {
            "Text": " to some "
          },
          {
            "Text": "ProtectionDomain",
            "AttrFlags": 2
          },
          {
            "Text": ", "
          },
          {
            "Text": "regardless",
            "AttrFlags": 4
          },
          {
            "Text": " of any other permissions that domain accrues. This example demonstrates just one of all the possible approaches for satisfying this kind of requirement. It introduces a “negative” permission class, along with a wrapper that enables the default "
          },
          {
            "Text": "Policy",
            "AttrFlags": 2
          },
          {
            "Text": " to be reused as a repository of such permissions."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518713538,
        "id": "3f67d171-c9f7-4b2d-9006-59c4e84eab8d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518713538,
        "parent_id": "1be03b36-9612-4a8f-90aa-752aeb6c2fbf",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Notes:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Notes:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518713539,
        "id": "64935e6d-fa80-45dc-a827-8245445aaea7",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518713539,
        "parent_id": "1be03b36-9612-4a8f-90aa-752aeb6c2fbf",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The standard policy file syntax and mechanism for permission assignment in general remain unaffected. This means that "
            ],
            [
              "deny",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " rules within policy files are still expressed as "
            ],
            [
              "grants",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "The standard policy file syntax and mechanism for permission assignment in general remain unaffected. This means that "
          },
          {
            "Text": "deny",
            "AttrFlags": 4
          },
          {
            "Text": " rules within policy files are still expressed as "
          },
          {
            "Text": "grants",
            "AttrFlags": 4
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518713540,
        "id": "cca82360-4972-414a-a866-9c3569bb8613",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518713540,
        "parent_id": "1be03b36-9612-4a8f-90aa-752aeb6c2fbf",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The policy wrapper is meant to specifically encapsulate the default file-backed "
            ],
            [
              "Policy",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " (assumed to be "
            ],
            [
              "com.sun.security.provider.PolicyFile",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ")."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "The policy wrapper is meant to specifically encapsulate the default file-backed "
          },
          {
            "Text": "Policy",
            "AttrFlags": 2
          },
          {
            "Text": " (assumed to be "
          },
          {
            "Text": "com.sun.security.provider.PolicyFile",
            "AttrFlags": 2
          },
          {
            "Text": ")."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518713540,
        "id": "a463daed-1171-4c65-985f-c4d36db8691b",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518713540,
        "parent_id": "1be03b36-9612-4a8f-90aa-752aeb6c2fbf",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Denied permissions are only processed as such at the policy level. If statically assigned to a domain, they will by default be treated by that domain as ordinary “positive” permissions."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Denied permissions are only processed as such at the policy level. If statically assigned to a domain, they will by default be treated by that domain as ordinary “positive” permissions."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518713540,
        "id": "92f43744-fa6b-4c09-99ac-74aa36ef3244",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518713540,
        "parent_id": "1be03b36-9612-4a8f-90aa-752aeb6c2fbf",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The "
            ],
            [
              "DeniedPermission",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " class"
            ]
          ]
        },
        "type": "sub_sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "The "
          },
          {
            "Text": "DeniedPermission",
            "AttrFlags": 2
          },
          {
            "Text": " class"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518713540,
        "id": "c63d11ae-b243-4485-9ccd-7aae324b38c0",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518713540,
        "parent_id": "1be03b36-9612-4a8f-90aa-752aeb6c2fbf",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "package com.example;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Modifier;\nimport java.security.BasicPermission;\nimport java.security.Permission;\nimport java.security.UnresolvedPermission;\nimport java.text.MessageFormat;\n\n/**\n * A representation of a \"negative\" privilege.\n * \u003cp\u003e\n * A \u003ccode\u003eDeniedPermission\u003c/code\u003e, when \"granted\" (to some \u003ccode\u003eProtectionDomain\u003c/code\u003e and/or\n * \u003ccode\u003ePrincipal\u003c/code\u003e), represents a privilege which \u003cem\u003ecannot\u003c/em\u003e be exercised, regardless of\n * any positive permissions (\u003ccode\u003eAllPermission\u003c/code\u003e included) possessed. In other words, if a\n * set of granted permissions, \u003cem\u003eP\u003c/em\u003e, contains a permission of this class, \u003cem\u003eD\u003c/em\u003e, then the\n * set of effectively granted permissions is\u003cbr/\u003e\n * \u003cbr/\u003e\n * \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cem\u003e{ P\u003csub\u003eimplied\u003c/sub\u003e - D\u003csub\u003eimplied\u003c/sub\u003e }\u003c/em\u003e.\n * \u003c/p\u003e\n * \u003cp\u003e\n * Each instance of this class encapsulates a \u003cem\u003etarget permission\u003c/em\u003e, representing the\n * \"positive\" permission being denied.\n * \u003c/p\u003e\n * Denied permissions employ the following naming scheme:\u003cbr/\u003e\n * \u003cbr/\u003e\n * \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cem\u003e\u0026lt;target_class_name\u0026gt;:\u0026lt;target_name\u0026gt;(:\u0026lt;target_actions\u0026gt;)\u003c/em\u003e\u003cbr/\u003e\n * \u003cbr/\u003e\n * where:\n * \u003cul\u003e\n * \u003cli\u003e\u003cem\u003etarget_class_name\u003c/em\u003e is the name of the target permission's class,\u003c/li\u003e\n * \u003cli\u003e\u003cem\u003etarget_name\u003c/em\u003e is the name of the target permission, and\u003c/li\u003e\n * \u003cli\u003e\u003cem\u003etarget_actions\u003c/em\u003e is, optionally, the actions string of the target permission.\u003c/li\u003e\n * \u003c/ul\u003e\n * A denied permission, having a target permission \u003cem\u003et\u003c/em\u003e, is said to \u003cem\u003eimply\u003c/em\u003e another\n * permission \u003cem\u003ep\u003c/em\u003e, if:\n * \u003cul\u003e\n * \u003cli\u003ep \u003cem\u003eis not\u003c/em\u003e itself a denied permission, and \u003ccode\u003e(t.implies(p) == true)\u003c/code\u003e,\n * or\u003c/li\u003e\n * \u003cli\u003ep \u003cem\u003eis\u003c/em\u003e a denied permission, with a target \u003cem\u003et1\u003c/em\u003e, and\n * \u003ccode\u003e(t.implies(t1) == true)\u003c/code\u003e.\n * \u003c/ul\u003e\n * \u003cp\u003e\n * It is the responsibility of the policy decision point (e.g., the \u003ccode\u003ePolicy\u003c/code\u003e provider) to\n * take denied permission semantics into account when issuing authorization statements.\n * \u003c/p\u003e\n */\npublic final class DeniedPermission extends BasicPermission {\n\n    private final Permission target;\n    private static final long serialVersionUID = 473625163869800679L;\n\n    /**\n     * Instantiates a \u003ccode\u003eDeniedPermission\u003c/code\u003e that encapsulates a target permission of the\n     * indicated class, specified name and, optionally, actions.\n     * \n     * @throws IllegalArgumentException\n     *             if:\n     *             \u003cul\u003e\n     *             \u003cli\u003e\u003ccode\u003etargetClassName\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e, the empty string, does not\n     *             refer to a concrete \u003ccode\u003ePermission\u003c/code\u003e descendant, or refers to\n     *             \u003ccode\u003eDeniedPermission.class\u003c/code\u003e or \u003ccode\u003eUnresolvedPermission.class\u003c/code\u003e.\u003c/li\u003e\n     *             \u003cli\u003e\u003ccode\u003etargetName\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e.\u003c/li\u003e\n     *             \u003cli\u003e\u003ccode\u003etargetClassName\u003c/code\u003e cannot be instantiated, and it's the caller's fault;\n     *             e.g., because \u003ccode\u003etargetName\u003c/code\u003e and/or \u003ccode\u003etargetActions\u003c/code\u003e do not adhere\n     *             to the naming constraints of the target class; or due to the target class not\n     *             exposing a \u003ccode\u003e(String name)\u003c/code\u003e, or \u003ccode\u003e(String name, String actions)\u003c/code\u003e\n     *             constructor, depending on whether \u003ccode\u003etargetActions\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e or\n     *             not.\u003c/li\u003e\n     *             \u003c/ul\u003e\n     */\n    public static DeniedPermission newDeniedPermission(String targetClassName, String targetName,\n            String targetActions) {\n        if (targetClassName == null || targetClassName.trim().isEmpty() || targetName == null) {\n            throw new IllegalArgumentException(\n                    \"Null or empty [targetClassName], or null [targetName] argument was supplied.\");\n        }\n        StringBuilder sb = new StringBuilder(targetClassName).append(\":\").append(targetName);\n        if (targetName != null) {\n            sb.append(\":\").append(targetName);\n        }\n        return new DeniedPermission(sb.toString());\n    }\n\n    /**\n     * Instantiates a \u003ccode\u003eDeniedPermission\u003c/code\u003e that encapsulates a target permission of the class,\n     * name and, optionally, actions, collectively provided as the \u003ccode\u003ename\u003c/code\u003e argument.\n     * \n     * @throws IllegalArgumentException\n     *             if:\n     *             \u003cul\u003e\n     *             \u003cli\u003e\u003ccode\u003ename\u003c/code\u003e's target permission class name component is empty, does not\n     *             refer to a concrete \u003ccode\u003ePermission\u003c/code\u003e descendant, or refers to\n     *             \u003ccode\u003eDeniedPermission.class\u003c/code\u003e or \u003ccode\u003eUnresolvedPermission.class\u003c/code\u003e.\u003c/li\u003e\n     *             \u003cli\u003e\u003ccode\u003ename\u003c/code\u003e's target name component is \u003ccode\u003eempty\u003c/code\u003e\u003c/li\u003e\n     *             \u003cli\u003ethe target permission class cannot be instantiated, and it's the caller's fault;\n     *             e.g., because \u003ccode\u003ename\u003c/code\u003e's target name and/or target actions component(s) do\n     *             not adhere to the naming constraints of the target class; or due to the target class\n     *             not exposing a \u003ccode\u003e(String name)\u003c/code\u003e, or\n     *             \u003ccode\u003e(String name, String actions)\u003c/code\u003e constructor, depending on whether the\n     *             target actions component is empty or not.\u003c/li\u003e\n     *             \u003c/ul\u003e\n     */\n    public DeniedPermission(String name) {\n        super(name);\n        String[] comps = name.split(\":\");\n        if (comps.length \u003c 2) {\n            throw new IllegalArgumentException(MessageFormat.format(\"Malformed name [{0}] argument.\", name));\n        }\n        this.target = initTarget(comps[0], comps[1], ((comps.length \u003c 3) ? null : comps[2]));\n    }\n\n    /**\n     * Instantiates a \u003ccode\u003eDeniedPermission\u003c/code\u003e that encapsulates the given target permission.\n     * \n     * @throws IllegalArgumentException\n     *             if \u003ccode\u003etarget\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e, a \u003ccode\u003eDeniedPermission\u003c/code\u003e, or an\n     *             \u003ccode\u003eUnresolvedPermission\u003c/code\u003e.\n     */\n    public static DeniedPermission newDeniedPermission(Permission target) {\n        if (target == null) {\n            throw new IllegalArgumentException(\"Null [target] argument.\");\n        }\n        if (target instanceof DeniedPermission || target instanceof UnresolvedPermission) {\n            throw new IllegalArgumentException(\"[target] must not be a DeniedPermission or an UnresolvedPermission.\");\n        }\n        StringBuilder sb = new StringBuilder(target.getClass().getName()).append(\":\").append(target.getName());\n        String targetActions = target.getActions();\n        if (targetActions != null) {\n            sb.append(\":\").append(targetActions);\n        }\n        return new DeniedPermission(sb.toString(), target);\n    }\n\n    private DeniedPermission(String name, Permission target) {\n        super(name);\n        this.target = target;\n    }\n\n    private Permission initTarget(String targetClassName, String targetName, String targetActions) {\n        Class\u003c?\u003e targetClass;\n        try {\n            targetClass = Class.forName(targetClassName);\n        }\n        catch (ClassNotFoundException cnfe) {\n            if (targetClassName.trim().isEmpty()) {\n                targetClassName = \"\u003cempty\u003e\";\n            }\n            throw new IllegalArgumentException(\n                    MessageFormat.format(\"Target Permission class [{0}] not found.\", targetClassName));\n        }\n        if (!Permission.class.isAssignableFrom(targetClass) || Modifier.isAbstract(targetClass.getModifiers())) {\n            throw new IllegalArgumentException(MessageFormat\n                    .format(\"Target Permission class [{0}] is not a (concrete) Permission.\", targetClassName));\n        }\n        if (targetClass == DeniedPermission.class || targetClass == UnresolvedPermission.class) {\n            throw new IllegalArgumentException(\"Target Permission class cannot be a DeniedPermission itself.\");\n        }\n        Constructor\u003c?\u003e targetCtor;\n        try {\n            if (targetActions == null) {\n                targetCtor = targetClass.getConstructor(String.class);\n            }\n            else {\n                targetCtor = targetClass.getConstructor(String.class, String.class);\n            }\n        }\n        catch (NoSuchMethodException nsme) {\n            throw new IllegalArgumentException(MessageFormat.format(\n                    \"Target Permission class [{0}] does not provide or expose a (String name) or (String name, String actions) constructor.\",\n                    targetClassName));\n        }\n        try {\n            return (Permission) targetCtor\n                    .newInstance(((targetCtor.getParameterCount() == 1) ? new Object[] { targetName }\n                            : new Object[] { targetName, targetActions }));\n        }\n        catch (ReflectiveOperationException roe) {\n            if (roe instanceof InvocationTargetException) {\n                if (targetName == null) {\n                    targetName = \"\u003cnull\u003e\";\n                }\n                else if (targetName.trim().isEmpty()) {\n                    targetName = \"\u003cempty\u003e\";\n                }\n                if (targetActions == null) {\n                    targetActions = \"\u003cnull\u003e\";\n                }\n                else if (targetActions.trim().isEmpty()) {\n                    targetActions = \"\u003cempty\u003e\";\n                }\n                throw new IllegalArgumentException(MessageFormat.format(\n                        \"Could not instantiate target Permission class [{0}]; provided target name [{1}] and/or target actions [{2}] potentially erroneous.\",\n                        targetClassName, targetName, targetActions), roe);\n            }\n            throw new RuntimeException(\n                    \"Could not instantiate target Permission class [{0}]; an unforeseen error occurred - see attached cause for details\",\n                    roe);\n        }\n    }\n\n    /**\n     * Checks whether the given permission is implied by this one, as per the {@link DeniedPermission\n     * overview}.\n     */\n    @Override\n    public boolean implies(Permission p) {\n        if (p instanceof DeniedPermission) {\n            return target.implies(((DeniedPermission) p).target);\n        }\n        return target.implies(p);\n    }\n\n    /**\n     * Returns this denied permission's target permission (the actual positive permission which is not\n     * to be granted).\n     */\n    public Permission getTargetPermission() {\n        return target;\n    }\n\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "package com.example;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Modifier;\nimport java.security.BasicPermission;\nimport java.security.Permission;\nimport java.security.UnresolvedPermission;\nimport java.text.MessageFormat;\n\n/**\n * A representation of a \"negative\" privilege.\n * \u003cp\u003e\n * A \u003ccode\u003eDeniedPermission\u003c/code\u003e, when \"granted\" (to some \u003ccode\u003eProtectionDomain\u003c/code\u003e and/or\n * \u003ccode\u003ePrincipal\u003c/code\u003e), represents a privilege which \u003cem\u003ecannot\u003c/em\u003e be exercised, regardless of\n * any positive permissions (\u003ccode\u003eAllPermission\u003c/code\u003e included) possessed. In other words, if a\n * set of granted permissions, \u003cem\u003eP\u003c/em\u003e, contains a permission of this class, \u003cem\u003eD\u003c/em\u003e, then the\n * set of effectively granted permissions is\u003cbr/\u003e\n * \u003cbr/\u003e\n * \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cem\u003e{ P\u003csub\u003eimplied\u003c/sub\u003e - D\u003csub\u003eimplied\u003c/sub\u003e }\u003c/em\u003e.\n * \u003c/p\u003e\n * \u003cp\u003e\n * Each instance of this class encapsulates a \u003cem\u003etarget permission\u003c/em\u003e, representing the\n * \"positive\" permission being denied.\n * \u003c/p\u003e\n * Denied permissions employ the following naming scheme:\u003cbr/\u003e\n * \u003cbr/\u003e\n * \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cem\u003e\u0026lt;target_class_name\u0026gt;:\u0026lt;target_name\u0026gt;(:\u0026lt;target_actions\u0026gt;)\u003c/em\u003e\u003cbr/\u003e\n * \u003cbr/\u003e\n * where:\n * \u003cul\u003e\n * \u003cli\u003e\u003cem\u003etarget_class_name\u003c/em\u003e is the name of the target permission's class,\u003c/li\u003e\n * \u003cli\u003e\u003cem\u003etarget_name\u003c/em\u003e is the name of the target permission, and\u003c/li\u003e\n * \u003cli\u003e\u003cem\u003etarget_actions\u003c/em\u003e is, optionally, the actions string of the target permission.\u003c/li\u003e\n * \u003c/ul\u003e\n * A denied permission, having a target permission \u003cem\u003et\u003c/em\u003e, is said to \u003cem\u003eimply\u003c/em\u003e another\n * permission \u003cem\u003ep\u003c/em\u003e, if:\n * \u003cul\u003e\n * \u003cli\u003ep \u003cem\u003eis not\u003c/em\u003e itself a denied permission, and \u003ccode\u003e(t.implies(p) == true)\u003c/code\u003e,\n * or\u003c/li\u003e\n * \u003cli\u003ep \u003cem\u003eis\u003c/em\u003e a denied permission, with a target \u003cem\u003et1\u003c/em\u003e, and\n * \u003ccode\u003e(t.implies(t1) == true)\u003c/code\u003e.\n * \u003c/ul\u003e\n * \u003cp\u003e\n * It is the responsibility of the policy decision point (e.g., the \u003ccode\u003ePolicy\u003c/code\u003e provider) to\n * take denied permission semantics into account when issuing authorization statements.\n * \u003c/p\u003e\n */\npublic final class DeniedPermission extends BasicPermission {\n\n    private final Permission target;\n    private static final long serialVersionUID = 473625163869800679L;\n\n    /**\n     * Instantiates a \u003ccode\u003eDeniedPermission\u003c/code\u003e that encapsulates a target permission of the\n     * indicated class, specified name and, optionally, actions.\n     * \n     * @throws IllegalArgumentException\n     *             if:\n     *             \u003cul\u003e\n     *             \u003cli\u003e\u003ccode\u003etargetClassName\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e, the empty string, does not\n     *             refer to a concrete \u003ccode\u003ePermission\u003c/code\u003e descendant, or refers to\n     *             \u003ccode\u003eDeniedPermission.class\u003c/code\u003e or \u003ccode\u003eUnresolvedPermission.class\u003c/code\u003e.\u003c/li\u003e\n     *             \u003cli\u003e\u003ccode\u003etargetName\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e.\u003c/li\u003e\n     *             \u003cli\u003e\u003ccode\u003etargetClassName\u003c/code\u003e cannot be instantiated, and it's the caller's fault;\n     *             e.g., because \u003ccode\u003etargetName\u003c/code\u003e and/or \u003ccode\u003etargetActions\u003c/code\u003e do not adhere\n     *             to the naming constraints of the target class; or due to the target class not\n     *             exposing a \u003ccode\u003e(String name)\u003c/code\u003e, or \u003ccode\u003e(String name, String actions)\u003c/code\u003e\n     *             constructor, depending on whether \u003ccode\u003etargetActions\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e or\n     *             not.\u003c/li\u003e\n     *             \u003c/ul\u003e\n     */\n    public static DeniedPermission newDeniedPermission(String targetClassName, String targetName,\n            String targetActions) {\n        if (targetClassName == null || targetClassName.trim().isEmpty() || targetName == null) {\n            throw new IllegalArgumentException(\n                    \"Null or empty [targetClassName], or null [targetName] argument was supplied.\");\n        }\n        StringBuilder sb = new StringBuilder(targetClassName).append(\":\").append(targetName);\n        if (targetName != null) {\n            sb.append(\":\").append(targetName);\n        }\n        return new DeniedPermission(sb.toString());\n    }\n\n    /**\n     * Instantiates a \u003ccode\u003eDeniedPermission\u003c/code\u003e that encapsulates a target permission of the class,\n     * name and, optionally, actions, collectively provided as the \u003ccode\u003ename\u003c/code\u003e argument.\n     * \n     * @throws IllegalArgumentException\n     *             if:\n     *             \u003cul\u003e\n     *             \u003cli\u003e\u003ccode\u003ename\u003c/code\u003e's target permission class name component is empty, does not\n     *             refer to a concrete \u003ccode\u003ePermission\u003c/code\u003e descendant, or refers to\n     *             \u003ccode\u003eDeniedPermission.class\u003c/code\u003e or \u003ccode\u003eUnresolvedPermission.class\u003c/code\u003e.\u003c/li\u003e\n     *             \u003cli\u003e\u003ccode\u003ename\u003c/code\u003e's target name component is \u003ccode\u003eempty\u003c/code\u003e\u003c/li\u003e\n     *             \u003cli\u003ethe target permission class cannot be instantiated, and it's the caller's fault;\n     *             e.g., because \u003ccode\u003ename\u003c/code\u003e's target name and/or target actions component(s) do\n     *             not adhere to the naming constraints of the target class; or due to the target class\n     *             not exposing a \u003ccode\u003e(String name)\u003c/code\u003e, or\n     *             \u003ccode\u003e(String name, String actions)\u003c/code\u003e constructor, depending on whether the\n     *             target actions component is empty or not.\u003c/li\u003e\n     *             \u003c/ul\u003e\n     */\n    public DeniedPermission(String name) {\n        super(name);\n        String[] comps = name.split(\":\");\n        if (comps.length \u003c 2) {\n            throw new IllegalArgumentException(MessageFormat.format(\"Malformed name [{0}] argument.\", name));\n        }\n        this.target = initTarget(comps[0], comps[1], ((comps.length \u003c 3) ? null : comps[2]));\n    }\n\n    /**\n     * Instantiates a \u003ccode\u003eDeniedPermission\u003c/code\u003e that encapsulates the given target permission.\n     * \n     * @throws IllegalArgumentException\n     *             if \u003ccode\u003etarget\u003c/code\u003e is \u003ccode\u003enull\u003c/code\u003e, a \u003ccode\u003eDeniedPermission\u003c/code\u003e, or an\n     *             \u003ccode\u003eUnresolvedPermission\u003c/code\u003e.\n     */\n    public static DeniedPermission newDeniedPermission(Permission target) {\n        if (target == null) {\n            throw new IllegalArgumentException(\"Null [target] argument.\");\n        }\n        if (target instanceof DeniedPermission || target instanceof UnresolvedPermission) {\n            throw new IllegalArgumentException(\"[target] must not be a DeniedPermission or an UnresolvedPermission.\");\n        }\n        StringBuilder sb = new StringBuilder(target.getClass().getName()).append(\":\").append(target.getName());\n        String targetActions = target.getActions();\n        if (targetActions != null) {\n            sb.append(\":\").append(targetActions);\n        }\n        return new DeniedPermission(sb.toString(), target);\n    }\n\n    private DeniedPermission(String name, Permission target) {\n        super(name);\n        this.target = target;\n    }\n\n    private Permission initTarget(String targetClassName, String targetName, String targetActions) {\n        Class\u003c?\u003e targetClass;\n        try {\n            targetClass = Class.forName(targetClassName);\n        }\n        catch (ClassNotFoundException cnfe) {\n            if (targetClassName.trim().isEmpty()) {\n                targetClassName = \"\u003cempty\u003e\";\n            }\n            throw new IllegalArgumentException(\n                    MessageFormat.format(\"Target Permission class [{0}] not found.\", targetClassName));\n        }\n        if (!Permission.class.isAssignableFrom(targetClass) || Modifier.isAbstract(targetClass.getModifiers())) {\n            throw new IllegalArgumentException(MessageFormat\n                    .format(\"Target Permission class [{0}] is not a (concrete) Permission.\", targetClassName));\n        }\n        if (targetClass == DeniedPermission.class || targetClass == UnresolvedPermission.class) {\n            throw new IllegalArgumentException(\"Target Permission class cannot be a DeniedPermission itself.\");\n        }\n        Constructor\u003c?\u003e targetCtor;\n        try {\n            if (targetActions == null) {\n                targetCtor = targetClass.getConstructor(String.class);\n            }\n            else {\n                targetCtor = targetClass.getConstructor(String.class, String.class);\n            }\n        }\n        catch (NoSuchMethodException nsme) {\n            throw new IllegalArgumentException(MessageFormat.format(\n                    \"Target Permission class [{0}] does not provide or expose a (String name) or (String name, String actions) constructor.\",\n                    targetClassName));\n        }\n        try {\n            return (Permission) targetCtor\n                    .newInstance(((targetCtor.getParameterCount() == 1) ? new Object[] { targetName }\n                            : new Object[] { targetName, targetActions }));\n        }\n        catch (ReflectiveOperationException roe) {\n            if (roe instanceof InvocationTargetException) {\n                if (targetName == null) {\n                    targetName = \"\u003cnull\u003e\";\n                }\n                else if (targetName.trim().isEmpty()) {\n                    targetName = \"\u003cempty\u003e\";\n                }\n                if (targetActions == null) {\n                    targetActions = \"\u003cnull\u003e\";\n                }\n                else if (targetActions.trim().isEmpty()) {\n                    targetActions = \"\u003cempty\u003e\";\n                }\n                throw new IllegalArgumentException(MessageFormat.format(\n                        \"Could not instantiate target Permission class [{0}]; provided target name [{1}] and/or target actions [{2}] potentially erroneous.\",\n                        targetClassName, targetName, targetActions), roe);\n            }\n            throw new RuntimeException(\n                    \"Could not instantiate target Permission class [{0}]; an unforeseen error occurred - see attached cause for details\",\n                    roe);\n        }\n    }\n\n    /**\n     * Checks whether the given permission is implied by this one, as per the {@link DeniedPermission\n     * overview}.\n     */\n    @Override\n    public boolean implies(Permission p) {\n        if (p instanceof DeniedPermission) {\n            return target.implies(((DeniedPermission) p).target);\n        }\n        return target.implies(p);\n    }\n\n    /**\n     * Returns this denied permission's target permission (the actual positive permission which is not\n     * to be granted).\n     */\n    public Permission getTargetPermission() {\n        return target;\n    }\n\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518713540,
        "id": "423ad708-c07d-4423-82d3-b91b832886e0",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518713540,
        "parent_id": "1be03b36-9612-4a8f-90aa-752aeb6c2fbf",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The "
            ],
            [
              "DenyingPolicy",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " class"
            ]
          ]
        },
        "type": "sub_sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "The "
          },
          {
            "Text": "DenyingPolicy",
            "AttrFlags": 2
          },
          {
            "Text": " class"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518713540,
        "id": "2c7bf8fd-8de4-4307-b677-31f1fe6411f4",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518713540,
        "parent_id": "1be03b36-9612-4a8f-90aa-752aeb6c2fbf",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "package com.example;\n\nimport java.security.CodeSource;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Permission;\nimport java.security.PermissionCollection;\nimport java.security.Policy;\nimport java.security.ProtectionDomain;\nimport java.security.UnresolvedPermission;\nimport java.util.Enumeration;\n\n/**\n * Wrapper that adds rudimentary {@link DeniedPermission} processing capabilities to the standard\n * file-backed \u003ccode\u003ePolicy\u003c/code\u003e.\n */\npublic final class DenyingPolicy extends Policy {\n\n    {\n        try {\n            defaultPolicy = Policy.getInstance(\"javaPolicy\", null);\n        }\n        catch (NoSuchAlgorithmException nsae) {\n            throw new RuntimeException(\"Could not acquire default Policy.\", nsae);\n        }\n    }\n\n    private final Policy defaultPolicy;\n\n    @Override\n    public PermissionCollection getPermissions(CodeSource codesource) {\n        return defaultPolicy.getPermissions(codesource);\n    }\n\n    @Override\n    public PermissionCollection getPermissions(ProtectionDomain domain) {\n        return defaultPolicy.getPermissions(domain);\n    }\n\n    /**\n     * @return\n     *         \u003cul\u003e\n     *         \u003cli\u003e\u003ccode\u003etrue\u003c/code\u003e if:\u003c/li\u003e\n     *         \u003cul\u003e\n     *         \u003cli\u003e\u003ccode\u003epermission\u003c/code\u003e \u003cem\u003eis not\u003c/em\u003e an instance of\n     *         \u003ccode\u003eDeniedPermission\u003c/code\u003e,\u003c/li\u003e\n     *         \u003cli\u003ean \u003ccode\u003eimplies(domain, permission)\u003c/code\u003e invocation on the system-default\n     *         \u003ccode\u003ePolicy\u003c/code\u003e yields \u003ccode\u003etrue\u003c/code\u003e, and\u003c/li\u003e\n     *         \u003cli\u003e\u003ccode\u003epermission\u003c/code\u003e \u003cem\u003eis not\u003c/em\u003e implied by any \u003ccode\u003eDeniedPermission\u003c/code\u003es\n     *         having potentially been assigned to \u003ccode\u003edomain\u003c/code\u003e.\u003c/li\u003e\n     *         \u003c/ul\u003e\n     *         \u003cli\u003e\u003ccode\u003efalse\u003c/code\u003e, otherwise.\n     *         \u003c/ul\u003e\n     */\n    @Override\n    public boolean implies(ProtectionDomain domain, Permission permission) {\n        if (permission instanceof DeniedPermission) {\n            /*\n             * At the policy decision level, DeniedPermissions can only themselves imply, not be implied (as\n             * they take away, rather than grant, privileges). Furthermore, clients aren't supposed to use this\n             * method for checking whether some domain _does not_ have a permission (which is what\n             * DeniedPermissions express after all).\n             */\n            return false;\n        }\n\n        if (!defaultPolicy.implies(domain, permission)) {\n            // permission not granted, so no need to check whether denied\n            return false;\n        }\n\n        /*\n         * Permission granted--now check whether there's an overriding DeniedPermission. The following\n         * assumes that previousPolicy is a sun.security.provider.PolicyFile (different implementations\n         * might not support #getPermissions(ProtectionDomain) and/or handle UnresolvedPermissions\n         * differently).\n         */\n\n        Enumeration\u003cPermission\u003e perms = defaultPolicy.getPermissions(domain).elements();\n        while (perms.hasMoreElements()) {\n            Permission p = perms.nextElement();\n            /*\n             * DeniedPermissions will generally remain unresolved, as no code is expected to check whether other\n             * code has been \"granted\" such a permission.\n             */\n            if (p instanceof UnresolvedPermission) {\n                UnresolvedPermission up = (UnresolvedPermission) p;\n                if (up.getUnresolvedType().equals(DeniedPermission.class.getName())) {\n                    // force resolution\n                    defaultPolicy.implies(domain, up);\n                    // evaluate right away, to avoid reiterating over the collection\n                    p = new DeniedPermission(up.getUnresolvedName());\n                }\n            }\n            if (p instanceof DeniedPermission \u0026\u0026 p.implies(permission)) {\n                // permission denied\n                return false;\n            }\n        }\n        // permission granted\n        return true;\n    }\n\n    @Override\n    public void refresh() {\n        defaultPolicy.refresh();\n    }\n\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "package com.example;\n\nimport java.security.CodeSource;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Permission;\nimport java.security.PermissionCollection;\nimport java.security.Policy;\nimport java.security.ProtectionDomain;\nimport java.security.UnresolvedPermission;\nimport java.util.Enumeration;\n\n/**\n * Wrapper that adds rudimentary {@link DeniedPermission} processing capabilities to the standard\n * file-backed \u003ccode\u003ePolicy\u003c/code\u003e.\n */\npublic final class DenyingPolicy extends Policy {\n\n    {\n        try {\n            defaultPolicy = Policy.getInstance(\"javaPolicy\", null);\n        }\n        catch (NoSuchAlgorithmException nsae) {\n            throw new RuntimeException(\"Could not acquire default Policy.\", nsae);\n        }\n    }\n\n    private final Policy defaultPolicy;\n\n    @Override\n    public PermissionCollection getPermissions(CodeSource codesource) {\n        return defaultPolicy.getPermissions(codesource);\n    }\n\n    @Override\n    public PermissionCollection getPermissions(ProtectionDomain domain) {\n        return defaultPolicy.getPermissions(domain);\n    }\n\n    /**\n     * @return\n     *         \u003cul\u003e\n     *         \u003cli\u003e\u003ccode\u003etrue\u003c/code\u003e if:\u003c/li\u003e\n     *         \u003cul\u003e\n     *         \u003cli\u003e\u003ccode\u003epermission\u003c/code\u003e \u003cem\u003eis not\u003c/em\u003e an instance of\n     *         \u003ccode\u003eDeniedPermission\u003c/code\u003e,\u003c/li\u003e\n     *         \u003cli\u003ean \u003ccode\u003eimplies(domain, permission)\u003c/code\u003e invocation on the system-default\n     *         \u003ccode\u003ePolicy\u003c/code\u003e yields \u003ccode\u003etrue\u003c/code\u003e, and\u003c/li\u003e\n     *         \u003cli\u003e\u003ccode\u003epermission\u003c/code\u003e \u003cem\u003eis not\u003c/em\u003e implied by any \u003ccode\u003eDeniedPermission\u003c/code\u003es\n     *         having potentially been assigned to \u003ccode\u003edomain\u003c/code\u003e.\u003c/li\u003e\n     *         \u003c/ul\u003e\n     *         \u003cli\u003e\u003ccode\u003efalse\u003c/code\u003e, otherwise.\n     *         \u003c/ul\u003e\n     */\n    @Override\n    public boolean implies(ProtectionDomain domain, Permission permission) {\n        if (permission instanceof DeniedPermission) {\n            /*\n             * At the policy decision level, DeniedPermissions can only themselves imply, not be implied (as\n             * they take away, rather than grant, privileges). Furthermore, clients aren't supposed to use this\n             * method for checking whether some domain _does not_ have a permission (which is what\n             * DeniedPermissions express after all).\n             */\n            return false;\n        }\n\n        if (!defaultPolicy.implies(domain, permission)) {\n            // permission not granted, so no need to check whether denied\n            return false;\n        }\n\n        /*\n         * Permission granted--now check whether there's an overriding DeniedPermission. The following\n         * assumes that previousPolicy is a sun.security.provider.PolicyFile (different implementations\n         * might not support #getPermissions(ProtectionDomain) and/or handle UnresolvedPermissions\n         * differently).\n         */\n\n        Enumeration\u003cPermission\u003e perms = defaultPolicy.getPermissions(domain).elements();\n        while (perms.hasMoreElements()) {\n            Permission p = perms.nextElement();\n            /*\n             * DeniedPermissions will generally remain unresolved, as no code is expected to check whether other\n             * code has been \"granted\" such a permission.\n             */\n            if (p instanceof UnresolvedPermission) {\n                UnresolvedPermission up = (UnresolvedPermission) p;\n                if (up.getUnresolvedType().equals(DeniedPermission.class.getName())) {\n                    // force resolution\n                    defaultPolicy.implies(domain, up);\n                    // evaluate right away, to avoid reiterating over the collection\n                    p = new DeniedPermission(up.getUnresolvedName());\n                }\n            }\n            if (p instanceof DeniedPermission \u0026\u0026 p.implies(permission)) {\n                // permission denied\n                return false;\n            }\n        }\n        // permission granted\n        return true;\n    }\n\n    @Override\n    public void refresh() {\n        defaultPolicy.refresh();\n    }\n\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518713541,
        "id": "35a8c6be-7163-4c27-9fc7-5abdab4d3f48",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518713541,
        "parent_id": "1be03b36-9612-4a8f-90aa-752aeb6c2fbf",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Demo"
            ]
          ]
        },
        "type": "sub_sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Demo"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518713541,
        "id": "e5074f71-395a-45c4-9dd6-e33a9048583f",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518713541,
        "parent_id": "1be03b36-9612-4a8f-90aa-752aeb6c2fbf",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "package com.example;\n\nimport java.security.Policy;\n\npublic class Main {\n\n    public static void main(String... args) {\n        Policy.setPolicy(new DenyingPolicy());\n        System.setSecurityManager(new SecurityManager());\n        // should fail\n        System.getProperty(\"foo.bar\");\n    }\n\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "package com.example;\n\nimport java.security.Policy;\n\npublic class Main {\n\n    public static void main(String... args) {\n        Policy.setPolicy(new DenyingPolicy());\n        System.setSecurityManager(new SecurityManager());\n        // should fail\n        System.getProperty(\"foo.bar\");\n    }\n\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518713541,
        "id": "47ee7923-f7a6-4fa1-ab56-aa7e27b4a1bb",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518713541,
        "parent_id": "1be03b36-9612-4a8f-90aa-752aeb6c2fbf",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Assign some permissions:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Assign some permissions:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518713541,
        "id": "6d7b310a-0341-4aff-b6d4-a63662f6436d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518713541,
        "parent_id": "1be03b36-9612-4a8f-90aa-752aeb6c2fbf",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "grant codeBase \"file:///path/to/classes/bin/-\"\n    permission java.util.PropertyPermission \"*\", \"read,write\";\n    permission com.example.DeniedPermission \"java.util.PropertyPermission:foo.bar:read\";\n};"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "grant codeBase \"file:///path/to/classes/bin/-\"\n    permission java.util.PropertyPermission \"*\", \"read,write\";\n    permission com.example.DeniedPermission \"java.util.PropertyPermission:foo.bar:read\";\n};",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518713541,
        "id": "e643d48a-9f05-479a-9b14-47e1e6443fd5",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518713541,
        "parent_id": "1be03b36-9612-4a8f-90aa-752aeb6c2fbf",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Lastly, run the "
            ],
            [
              "Main",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " and watch it fail, due to the “deny” rule (the "
            ],
            [
              "DeniedPermission",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ") overriding the "
            ],
            [
              "grant",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " (its "
            ],
            [
              "PropertyPermission",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "). Note that a "
            ],
            [
              "setProperty(\"foo.baz\", \"xyz\")",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " invocation would instead have succeeded, since the denied permission only covers the “read” action, and solely for the “foo.bar” property."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Lastly, run the "
          },
          {
            "Text": "Main",
            "AttrFlags": 2
          },
          {
            "Text": " and watch it fail, due to the “deny” rule (the "
          },
          {
            "Text": "DeniedPermission",
            "AttrFlags": 2
          },
          {
            "Text": ") overriding the "
          },
          {
            "Text": "grant",
            "AttrFlags": 2
          },
          {
            "Text": " (its "
          },
          {
            "Text": "PropertyPermission",
            "AttrFlags": 2
          },
          {
            "Text": "). Note that a "
          },
          {
            "Text": "setProperty(\"foo.baz\", \"xyz\")",
            "AttrFlags": 2
          },
          {
            "Text": " invocation would instead have succeeded, since the denied permission only covers the “read” action, and solely for the “foo.bar” property."
          }
        ]
      }
    ],
    "title": "Implementing policy deny rules",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}