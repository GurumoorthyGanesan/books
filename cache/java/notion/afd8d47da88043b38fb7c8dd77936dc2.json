{
  "ID": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
  "Root": {
    "alive": true,
    "content": [
      "1efb7b26-98b8-4f47-964a-a70859ea91ce",
      "c22efba8-afb3-43ed-8a75-3a29934bd337",
      "9e130b46-3306-4c61-a97e-15e0495f0da3",
      "66780fb6-355a-46f6-ac3e-f9565d92a8aa",
      "ab9a0585-65c2-4ec2-8ea4-ddead75c4bb3",
      "5a5c10e5-ecc2-49cf-a48c-dd11028e2603",
      "52881301-f506-483c-9658-77f292a31984",
      "0279debd-1c91-401b-9ee5-1f2c1cbffc6e",
      "6fe7edee-8c98-403c-ac00-ba05a64e3bc5",
      "0e4ad8b1-1e15-466e-85d9-88a015dd210e",
      "12bfa714-b098-46db-8c05-179f9a3d162e",
      "9416ba5a-eb15-4a9a-96b7-926f1e8717af",
      "6391e4d3-89c4-4a8e-840d-0f04fb91dcdb",
      "dcdc4ae6-4f88-4cc3-b956-8326a472fcb4",
      "d5c83cf2-70b2-407a-8347-d172c7f62493",
      "3203ac49-e9f7-462b-83de-51b2ab2bf26f",
      "7546ef81-639c-444e-9390-6e3a54af4e42",
      "f8e3cf76-d939-410b-866c-5484bb1e9d47",
      "ecde60b6-d041-4d0e-86d5-b2dfff4dc181",
      "42800962-67f8-458f-b4af-4e3bbddc6bdf",
      "2b9f6a31-34a0-4e11-9f35-8abe60102848",
      "fc6147dd-557a-42c9-8b20-47259dfd8af0",
      "e1d39b59-e907-48c7-ba5a-62cba88b0a19",
      "c7e75b02-27f8-4164-81ae-a46478a90297",
      "dea87e90-1ac2-405d-8a1a-a403119a0e47"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1550518764784,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1550518764784,
    "parent_id": "d73cc3a8-7897-4311-9f5f-f3e15e294c43",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Motivation for Atomic Types"
        ]
      ]
    },
    "type": "page",
    "version": 3,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764773,
        "id": "1efb7b26-98b8-4f47-964a-a70859ea91ce",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764773,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The simple way to implement multi-threaded applications is to use Java’s built-in synchronization and locking primitives; e.g. the "
            ],
            [
              "synchronized",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " keyword. The following example shows how we might use "
            ],
            [
              "synchronized",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " to accumulate counts."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The simple way to implement multi-threaded applications is to use Java’s built-in synchronization and locking primitives; e.g. the "
          },
          {
            "Text": "synchronized",
            "AttrFlags": 2
          },
          {
            "Text": " keyword. The following example shows how we might use "
          },
          {
            "Text": "synchronized",
            "AttrFlags": 2
          },
          {
            "Text": " to accumulate counts."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764776,
        "id": "c22efba8-afb3-43ed-8a75-3a29934bd337",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764776,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "public class Counters {\n    private final int[] counters;\n\n    public Counters(int nosCounters) {\n        counters = new int[nosCounters];\n    }\n\n    /**\n     * Increments the integer at the given index\n     */\n    public synchronized void count(int number) {\n        if (number \u003e= 0 \u0026\u0026 number \u003c counters.length) {\n            counters[number]++;\n        }\n    }\n\n    /**\n     * Obtains the current count of the number at the given index,\n     * or if there is no number at that index, returns 0.\n     */\n    public synchronized int getCount(int number) {\n        return (number \u003e= 0 \u0026\u0026 number \u003c counters.length) ? counters[number] : 0;\n    }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "public class Counters {\n    private final int[] counters;\n\n    public Counters(int nosCounters) {\n        counters = new int[nosCounters];\n    }\n\n    /**\n     * Increments the integer at the given index\n     */\n    public synchronized void count(int number) {\n        if (number \u003e= 0 \u0026\u0026 number \u003c counters.length) {\n            counters[number]++;\n        }\n    }\n\n    /**\n     * Obtains the current count of the number at the given index,\n     * or if there is no number at that index, returns 0.\n     */\n    public synchronized int getCount(int number) {\n        return (number \u003e= 0 \u0026\u0026 number \u003c counters.length) ? counters[number] : 0;\n    }\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764776,
        "id": "9e130b46-3306-4c61-a97e-15e0495f0da3",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764776,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "This implementation will work correctly. However, if you have a large number of threads making lots of simultaneous calls on the same "
            ],
            [
              "Counters",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " object, the synchronization is liable to be a bottleneck. Specifically:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "This implementation will work correctly. However, if you have a large number of threads making lots of simultaneous calls on the same "
          },
          {
            "Text": "Counters",
            "AttrFlags": 2
          },
          {
            "Text": " object, the synchronization is liable to be a bottleneck. Specifically:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764777,
        "id": "66780fb6-355a-46f6-ac3e-f9565d92a8aa",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764777,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Each "
            ],
            [
              "synchronized",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " method call will start with the current thread acquiring the lock for the "
            ],
            [
              "Counters",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " instance."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Each "
          },
          {
            "Text": "synchronized",
            "AttrFlags": 2
          },
          {
            "Text": " method call will start with the current thread acquiring the lock for the "
          },
          {
            "Text": "Counters",
            "AttrFlags": 2
          },
          {
            "Text": " instance."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764777,
        "id": "ab9a0585-65c2-4ec2-8ea4-ddead75c4bb3",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764777,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The thread will hold the lock while it checks "
            ],
            [
              "number",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " value and updates the counter."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "The thread will hold the lock while it checks "
          },
          {
            "Text": "number",
            "AttrFlags": 2
          },
          {
            "Text": " value and updates the counter."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764777,
        "id": "5a5c10e5-ecc2-49cf-a48c-dd11028e2603",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764777,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Finally, the it will release the lock, allowing other threads access."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Finally, the it will release the lock, allowing other threads access."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764777,
        "id": "52881301-f506-483c-9658-77f292a31984",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764777,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "If one thread attempts to acquire the lock while another one holds it, the attempting thread will be blocked (stopped) at step 1 until the lock is released. If multiple threads are waiting, one of them will get it, and the others will continue to be blocked."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "If one thread attempts to acquire the lock while another one holds it, the attempting thread will be blocked (stopped) at step 1 until the lock is released. If multiple threads are waiting, one of them will get it, and the others will continue to be blocked."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764777,
        "id": "0279debd-1c91-401b-9ee5-1f2c1cbffc6e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764777,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "This can lead to a couple of problems:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "This can lead to a couple of problems:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764778,
        "id": "6fe7edee-8c98-403c-ac00-ba05a64e3bc5",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764778,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "If there is a lot of "
            ],
            [
              "contention",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " for the lock (i.e. lots of thread try to acquire it), then some threads can be blocked for a long time."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "If there is a lot of "
          },
          {
            "Text": "contention",
            "AttrFlags": 4
          },
          {
            "Text": " for the lock (i.e. lots of thread try to acquire it), then some threads can be blocked for a long time."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764778,
        "id": "0e4ad8b1-1e15-466e-85d9-88a015dd210e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764778,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "When a thread is blocked waiting for the lock, the operating system will typically try switch execution to a different thread. This "
            ],
            [
              "context switching",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " incurs a relatively large performance impact on the processor."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "When a thread is blocked waiting for the lock, the operating system will typically try switch execution to a different thread. This "
          },
          {
            "Text": "context switching",
            "AttrFlags": 4
          },
          {
            "Text": " incurs a relatively large performance impact on the processor."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764778,
        "id": "12bfa714-b098-46db-8c05-179f9a3d162e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764778,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "When there are multiple threads blocked on the same lock, there are no guarantees that any one of them will be treated “fairly” (i.e. each thread is guaranteed to be scheduled to run). This can lead to "
            ],
            [
              "thread starvation",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "When there are multiple threads blocked on the same lock, there are no guarantees that any one of them will be treated “fairly” (i.e. each thread is guaranteed to be scheduled to run). This can lead to "
          },
          {
            "Text": "thread starvation",
            "AttrFlags": 4
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764778,
        "id": "9416ba5a-eb15-4a9a-96b7-926f1e8717af",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764778,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "How does one implement Atomic Types?"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "How does one implement Atomic Types?"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764779,
        "id": "6391e4d3-89c4-4a8e-840d-0f04fb91dcdb",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764779,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Let us start by rewriting the example above using "
            ],
            [
              "AtomicInteger",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " counters:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Let us start by rewriting the example above using "
          },
          {
            "Text": "AtomicInteger",
            "AttrFlags": 2
          },
          {
            "Text": " counters:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764779,
        "id": "dcdc4ae6-4f88-4cc3-b956-8326a472fcb4",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764779,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "public class Counters {\n    private final AtomicInteger[] counters;\n\n    public Counters(int nosCounters) {\n        counters = new AtomicInteger[nosCounters];\n        for (int i = 0; i \u003c nosCounters; i++) {\n            counters[i] = new AtomicInteger();\n        }\n    }\n\n    /**\n     * Increments the integer at the given index\n     */\n    public void count(int number) {\n        if (number \u003e= 0 \u0026\u0026 number \u003c counters.length) {\n            counters[number].incrementAndGet();\n        }\n    }\n\n    /**\n     * Obtains the current count of the object at the given index,\n     * or if there is no number at that index, returns 0.\n     */\n    public int getCount(int number) {\n        return (number \u003e= 0 \u0026\u0026 number \u003c counters.length) ? \n                counters[number].get() : 0;\n    }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "public class Counters {\n    private final AtomicInteger[] counters;\n\n    public Counters(int nosCounters) {\n        counters = new AtomicInteger[nosCounters];\n        for (int i = 0; i \u003c nosCounters; i++) {\n            counters[i] = new AtomicInteger();\n        }\n    }\n\n    /**\n     * Increments the integer at the given index\n     */\n    public void count(int number) {\n        if (number \u003e= 0 \u0026\u0026 number \u003c counters.length) {\n            counters[number].incrementAndGet();\n        }\n    }\n\n    /**\n     * Obtains the current count of the object at the given index,\n     * or if there is no number at that index, returns 0.\n     */\n    public int getCount(int number) {\n        return (number \u003e= 0 \u0026\u0026 number \u003c counters.length) ? \n                counters[number].get() : 0;\n    }\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764779,
        "id": "d5c83cf2-70b2-407a-8347-d172c7f62493",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764779,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "We have replaced the "
            ],
            [
              "int[]",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " with an "
            ],
            [
              "AtomicInteger[]",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ", and initialized it with an instance in each element. We have also added calls to "
            ],
            [
              "incrementAndGet()",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "get()",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " in place of operations on "
            ],
            [
              "int",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " values."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "We have replaced the "
          },
          {
            "Text": "int[]",
            "AttrFlags": 2
          },
          {
            "Text": " with an "
          },
          {
            "Text": "AtomicInteger[]",
            "AttrFlags": 2
          },
          {
            "Text": ", and initialized it with an instance in each element. We have also added calls to "
          },
          {
            "Text": "incrementAndGet()",
            "AttrFlags": 2
          },
          {
            "Text": " and "
          },
          {
            "Text": "get()",
            "AttrFlags": 2
          },
          {
            "Text": " in place of operations on "
          },
          {
            "Text": "int",
            "AttrFlags": 2
          },
          {
            "Text": " values."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764780,
        "id": "3203ac49-e9f7-462b-83de-51b2ab2bf26f",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764780,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "But the most important thing is that we can remove the "
            ],
            [
              "synchronized",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " keyword because locking is no longer required. This works because the "
            ],
            [
              "incrementAndGet()",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "get()",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " operations are "
            ],
            [
              "atomic",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "thread-safe",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". In this context, it means that:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "But the most important thing is that we can remove the "
          },
          {
            "Text": "synchronized",
            "AttrFlags": 2
          },
          {
            "Text": " keyword because locking is no longer required. This works because the "
          },
          {
            "Text": "incrementAndGet()",
            "AttrFlags": 2
          },
          {
            "Text": " and "
          },
          {
            "Text": "get()",
            "AttrFlags": 2
          },
          {
            "Text": " operations are "
          },
          {
            "Text": "atomic",
            "AttrFlags": 4
          },
          {
            "Text": " and "
          },
          {
            "Text": "thread-safe",
            "AttrFlags": 4
          },
          {
            "Text": ". In this context, it means that:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764780,
        "id": "7546ef81-639c-444e-9390-6e3a54af4e42",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764780,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Each counter in the array will only be "
            ],
            [
              "observable",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " in the either the “before” state for an operation (like an “increment”) or in the “after” state."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Each counter in the array will only be "
          },
          {
            "Text": "observable",
            "AttrFlags": 4
          },
          {
            "Text": " in the either the “before” state for an operation (like an “increment”) or in the “after” state."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764780,
        "id": "f8e3cf76-d939-410b-866c-5484bb1e9d47",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764780,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Assuming that the operation occurs at time "
            ],
            [
              "T",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ", no thread will be able to see the “before” state after time "
            ],
            [
              "T",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Assuming that the operation occurs at time "
          },
          {
            "Text": "T",
            "AttrFlags": 2
          },
          {
            "Text": ", no thread will be able to see the “before” state after time "
          },
          {
            "Text": "T",
            "AttrFlags": 2
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764781,
        "id": "ecde60b6-d041-4d0e-86d5-b2dfff4dc181",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764781,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Furthermore, while two threads might actually attempt to update the same "
            ],
            [
              "AtomicInteger",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " instance at the same time, the implementations of the operations ensure that only one increment happens at a time on the given instance. This is done without locking, often resulting in better performance."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Furthermore, while two threads might actually attempt to update the same "
          },
          {
            "Text": "AtomicInteger",
            "AttrFlags": 2
          },
          {
            "Text": " instance at the same time, the implementations of the operations ensure that only one increment happens at a time on the given instance. This is done without locking, often resulting in better performance."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764781,
        "id": "42800962-67f8-458f-b4af-4e3bbddc6bdf",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764781,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "How do Atomic Types work?"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "How do Atomic Types work?"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764783,
        "id": "2b9f6a31-34a0-4e11-9f35-8abe60102848",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764783,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Atomic types typically rely on specialized hardware instructions in the instruction set of the target machine. For example, Intel-based instruction sets provide a "
            ],
            [
              "CAS",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " ("
            ],
            [
              "Compare and Swap",
              [
                [
                  "a",
                  "https://en.wikipedia.org/wiki/Compare-and-swap"
                ]
              ]
            ],
            [
              ") instruction that will perform a specific sequence of memory operations atomically."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Atomic types typically rely on specialized hardware instructions in the instruction set of the target machine. For example, Intel-based instruction sets provide a "
          },
          {
            "Text": "CAS",
            "AttrFlags": 2
          },
          {
            "Text": " ("
          },
          {
            "Text": "Compare and Swap",
            "Link": "https://en.wikipedia.org/wiki/Compare-and-swap"
          },
          {
            "Text": ") instruction that will perform a specific sequence of memory operations atomically."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764783,
        "id": "fc6147dd-557a-42c9-8b20-47259dfd8af0",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764783,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "These low-level instructions are are used to implement higher-level operations in the APIs of the respective "
            ],
            [
              "AtomicXxx",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " classes. For example, (again, in C-like pseudocode):"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "These low-level instructions are are used to implement higher-level operations in the APIs of the respective "
          },
          {
            "Text": "AtomicXxx",
            "AttrFlags": 2
          },
          {
            "Text": " classes. For example, (again, in C-like pseudocode):"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764783,
        "id": "e1d39b59-e907-48c7-ba5a-62cba88b0a19",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764783,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "private volatile num;\n\nint increment() {\n  while (TRUE) {\n    int old = num;\n    int new = old + 1;\n    if (old == compare_and_swap(\u0026num, old, new)) {\n      return new;\n    }\n  }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "private volatile num;\n\nint increment() {\n  while (TRUE) {\n    int old = num;\n    int new = old + 1;\n    if (old == compare_and_swap(\u0026num, old, new)) {\n      return new;\n    }\n  }\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764783,
        "id": "c7e75b02-27f8-4164-81ae-a46478a90297",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764783,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "If there is no contention on the "
            ],
            [
              "AtomicXxxx",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ", the "
            ],
            [
              "if",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " test will succeed and the loop will end immediately. If there is contention, then the "
            ],
            [
              "if",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " will fail for all but one of the threads, and they will “spin” in the loop for a small number of cycles of the loop. In practice, the spinning is orders of magnitude faster (except at "
            ],
            [
              "unrealistically high",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " levels of contention, where synchronized performs better than atomic classes because when the CAS operation fails, then the retry will only add more contention) than suspending the thread and switching to another one."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "If there is no contention on the "
          },
          {
            "Text": "AtomicXxxx",
            "AttrFlags": 2
          },
          {
            "Text": ", the "
          },
          {
            "Text": "if",
            "AttrFlags": 2
          },
          {
            "Text": " test will succeed and the loop will end immediately. If there is contention, then the "
          },
          {
            "Text": "if",
            "AttrFlags": 2
          },
          {
            "Text": " will fail for all but one of the threads, and they will “spin” in the loop for a small number of cycles of the loop. In practice, the spinning is orders of magnitude faster (except at "
          },
          {
            "Text": "unrealistically high",
            "AttrFlags": 4
          },
          {
            "Text": " levels of contention, where synchronized performs better than atomic classes because when the CAS operation fails, then the retry will only add more contention) than suspending the thread and switching to another one."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550518764784,
        "id": "dea87e90-1ac2-405d-8a1a-a403119a0e47",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550518764784,
        "parent_id": "afd8d47d-a880-43b3-8fb7-c8dd77936dc2",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Incidentally, CAS instructions are typically used by the JVM to implement "
            ],
            [
              "uncontended locking",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". If the JVM can see that a lock is not currently locked, it will attempt to use a CAS to acquire the lock. If the CAS succeeds, then there is no need to do the expensive thread scheduling, context switching and so on. For more information on the techniques used, see "
            ],
            [
              "Biased Locking in HotSpot",
              [
                [
                  "a",
                  "https://blogs.oracle.com/dave/entry/biased_locking_in_hotspot"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Incidentally, CAS instructions are typically used by the JVM to implement "
          },
          {
            "Text": "uncontended locking",
            "AttrFlags": 4
          },
          {
            "Text": ". If the JVM can see that a lock is not currently locked, it will attempt to use a CAS to acquire the lock. If the CAS succeeds, then there is no need to do the expensive thread scheduling, context switching and so on. For more information on the techniques used, see "
          },
          {
            "Text": "Biased Locking in HotSpot",
            "Link": "https://blogs.oracle.com/dave/entry/biased_locking_in_hotspot"
          },
          {
            "Text": "."
          }
        ]
      }
    ],
    "title": "Motivation for Atomic Types",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}