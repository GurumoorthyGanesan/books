{
  "ID": "66eb611b-33d4-4cff-8f2a-dedc32e4e221",
  "Root": {
    "alive": true,
    "content": [
      "aac01506-a97d-4990-9937-e681faf7e640",
      "2d9ac90f-8021-46a3-abb8-23fc5e255409",
      "491e9516-9518-45ab-8adc-22ed03d84e58",
      "0482f9fc-bfcd-4f18-82cb-4ce0bfc70034",
      "ed447471-9e77-4f0a-9cbc-a084b843e003",
      "7b7c3589-b4dd-4198-b8f7-f179143f12cd",
      "8846724f-abaf-46a8-a293-fb390da7f3e1"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1551928867797,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "66eb611b-33d4-4cff-8f2a-dedc32e4e221",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1551928867797,
    "parent_id": "2734ccd8-075a-412f-8976-e67dfd9416da",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Non-Linear Equation"
        ]
      ]
    },
    "type": "page",
    "version": 3,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928867795,
        "id": "aac01506-a97d-4990-9937-e681faf7e640",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928867795,
        "parent_id": "66eb611b-33d4-4cff-8f2a-dedc32e4e221",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "An equation of the type "
            ],
            [
              "f(x)=0",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " is either algebraic or transcendental. These types of equations can be solved by using two types of methods-"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "An equation of the type "
          },
          {
            "Text": "f(x)=0",
            "AttrFlags": 2
          },
          {
            "Text": " is either algebraic or transcendental. These types of equations can be solved by using two types of methods-"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928867796,
        "id": "2d9ac90f-8021-46a3-abb8-23fc5e255409",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928867796,
        "parent_id": "66eb611b-33d4-4cff-8f2a-dedc32e4e221",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Direct Method",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ": This method gives the exact value of all the roots directly in a finite number of steps."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Direct Method",
            "AttrFlags": 1
          },
          {
            "Text": ": This method gives the exact value of all the roots directly in a finite number of steps."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928867796,
        "id": "491e9516-9518-45ab-8adc-22ed03d84e58",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928867796,
        "parent_id": "66eb611b-33d4-4cff-8f2a-dedc32e4e221",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Indirect or Iterative Method",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ": Iterative methods are best suited for computer programs to solve an equation. It is based on the concept of successive approximation. In Iterative Method there are two ways to solve an equation-"
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Indirect or Iterative Method",
            "AttrFlags": 1
          },
          {
            "Text": ": Iterative methods are best suited for computer programs to solve an equation. It is based on the concept of successive approximation. In Iterative Method there are two ways to solve an equation-"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928867796,
        "id": "0482f9fc-bfcd-4f18-82cb-4ce0bfc70034",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928867796,
        "parent_id": "66eb611b-33d4-4cff-8f2a-dedc32e4e221",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Bracketing Method",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ": We take two initial points where the root lies in between them. Example- Bisection Method, False Position Method."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Bracketing Method",
            "AttrFlags": 1
          },
          {
            "Text": ": We take two initial points where the root lies in between them. Example- Bisection Method, False Position Method."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928867797,
        "id": "ed447471-9e77-4f0a-9cbc-a084b843e003",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928867797,
        "parent_id": "66eb611b-33d4-4cff-8f2a-dedc32e4e221",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Open End Method",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ": We take one or two initial values where the root may be any-where. Example- Newton-Raphson Method, Successive Approximation Method, Secant Method."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Open End Method",
            "AttrFlags": 1
          },
          {
            "Text": ": We take one or two initial values where the root may be any-where. Example- Newton-Raphson Method, Successive Approximation Method, Secant Method."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928867797,
        "id": "7b7c3589-b4dd-4198-b8f7-f179143f12cd",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928867797,
        "parent_id": "66eb611b-33d4-4cff-8f2a-dedc32e4e221",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Implementation in C-"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Implementation in C-"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928867797,
        "id": "8846724f-abaf-46a8-a293-fb390da7f3e1",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928867797,
        "parent_id": "66eb611b-33d4-4cff-8f2a-dedc32e4e221",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "/// Here define different functions to work with\n#define f(x) ( ((x)*(x)*(x)) - (x) - 2 )\n#define f2(x) ( (3*(x)*(x)) - 1 )\n#define g(x) ( cbrt( (x) + 2 ) )\n\n\n/**\n* Takes two initial values and shortens the distance by both side.\n**/\ndouble BisectionMethod(){\n    double root=0;\n\n    double a=1, b=2;\n    double c=0;\n\n    int loopCounter=0;\n    if(f(a)*f(b) \u003c 0){\n        while(1){\n            loopCounter++;\n            c=(a+b)/2;\n\n            if(f(c)\u003c0.00001 \u0026\u0026 f(c)\u003e-0.00001){\n                root=c;\n                break;\n            }\n\n            if((f(a))*(f(c)) \u003c 0){\n                b=c;\n            }else{\n                a=c;\n            }\n\n        }\n    }\n    printf(\"It took %d loops.\\n\", loopCounter);\n\n    return root;\n}\n\n/**\n* Takes two initial values and shortens the distance by single side.\n**/\ndouble FalsePosition(){\n    double root=0;\n\n    double a=1, b=2;\n    double c=0;\n\n    int loopCounter=0;\n    if(f(a)*f(b) \u003c 0){\n        while(1){\n            loopCounter++;\n\n            c=(a*f(b) - b*f(a)) / (f(b) - f(a));\n\n            /*/printf(\"%lf\\t %lf \\n\", c, f(c));/**////test\n            if(f(c)\u003c0.00001 \u0026\u0026 f(c)\u003e-0.00001){\n                root=c;\n                break;\n            }\n\n            if((f(a))*(f(c)) \u003c 0){\n                b=c;\n            }else{\n                a=c;\n            }\n        }\n    }\n    printf(\"It took %d loops.\\n\", loopCounter);\n\n    return root;\n}\n\n/**\n* Uses one initial value and gradually takes that value near to the real one.\n**/\ndouble NewtonRaphson(){\n    double root=0;\n\n    double x1=1;\n    double x2=0;\n\n    int loopCounter=0;\n    while(1){\n        loopCounter++;\n\n        x2 = x1 - (f(x1)/f2(x1));\n        /*/printf(\"%lf \\t %lf \\n\", x2, f(x2));/**////test\n\n        if(f(x2)\u003c0.00001 \u0026\u0026 f(x2)\u003e-0.00001){\n            root=x2;\n            break;\n        }\n\n        x1=x2;\n    }\n    printf(\"It took %d loops.\\n\", loopCounter);\n\n    return root;\n}\n\n/**\n* Uses one initial value and gradually takes that value near to the real one.\n**/\ndouble FixedPoint(){\n    double root=0;\n    double x=1;\n\n    int loopCounter=0;\n    while(1){\n        loopCounter++;\n\n        if( (x-g(x)) \u003c0.00001 \u0026\u0026 (x-g(x)) \u003e-0.00001){\n            root = x;\n            break;\n        }\n\n        /*/printf(\"%lf \\t %lf \\n\", g(x), x-(g(x)));/**////test\n\n        x=g(x);\n    }\n    printf(\"It took %d loops.\\n\", loopCounter);\n\n    return root;\n}\n\n/**\n* uses two initial values \u0026 both value approaches to the root.\n**/\ndouble Secant(){\n    double root=0;\n\n    double x0=1;\n    double x1=2;\n    double x2=0;\n\n    int loopCounter=0;\n    while(1){\n        loopCounter++;\n\n        /*/printf(\"%lf \\t %lf \\t %lf \\n\", x0, x1, f(x1));/**////test\n\n        if(f(x1)\u003c0.00001 \u0026\u0026 f(x1)\u003e-0.00001){\n            root=x1;\n            break;\n        }\n\n        x2 = ((x0*f(x1))-(x1*f(x0))) / (f(x1)-f(x0));\n\n        x0=x1;\n        x1=x2;\n    }\n    printf(\"It took %d loops.\\n\", loopCounter);\n\n    return root;\n}\n\n\nint main(){\n    double root;\n\n    root = BisectionMethod();\n    printf(\"Using Bisection Method the root is: %lf \\n\\n\", root);\n    \n    root = FalsePosition();\n    printf(\"Using False Position Method the root is: %lf \\n\\n\", root);\n    \n    root = NewtonRaphson();\n    printf(\"Using Newton-Raphson Method the root is: %lf \\n\\n\", root);\n    \n    root = FixedPoint();\n    printf(\"Using Fixed Point Method the root is: %lf \\n\\n\", root);\n    \n    root = Secant();\n    printf(\"Using Secant Method the root is: %lf \\n\\n\", root);\n\n    return 0;\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "/// Here define different functions to work with\n#define f(x) ( ((x)*(x)*(x)) - (x) - 2 )\n#define f2(x) ( (3*(x)*(x)) - 1 )\n#define g(x) ( cbrt( (x) + 2 ) )\n\n\n/**\n* Takes two initial values and shortens the distance by both side.\n**/\ndouble BisectionMethod(){\n    double root=0;\n\n    double a=1, b=2;\n    double c=0;\n\n    int loopCounter=0;\n    if(f(a)*f(b) \u003c 0){\n        while(1){\n            loopCounter++;\n            c=(a+b)/2;\n\n            if(f(c)\u003c0.00001 \u0026\u0026 f(c)\u003e-0.00001){\n                root=c;\n                break;\n            }\n\n            if((f(a))*(f(c)) \u003c 0){\n                b=c;\n            }else{\n                a=c;\n            }\n\n        }\n    }\n    printf(\"It took %d loops.\\n\", loopCounter);\n\n    return root;\n}\n\n/**\n* Takes two initial values and shortens the distance by single side.\n**/\ndouble FalsePosition(){\n    double root=0;\n\n    double a=1, b=2;\n    double c=0;\n\n    int loopCounter=0;\n    if(f(a)*f(b) \u003c 0){\n        while(1){\n            loopCounter++;\n\n            c=(a*f(b) - b*f(a)) / (f(b) - f(a));\n\n            /*/printf(\"%lf\\t %lf \\n\", c, f(c));/**////test\n            if(f(c)\u003c0.00001 \u0026\u0026 f(c)\u003e-0.00001){\n                root=c;\n                break;\n            }\n\n            if((f(a))*(f(c)) \u003c 0){\n                b=c;\n            }else{\n                a=c;\n            }\n        }\n    }\n    printf(\"It took %d loops.\\n\", loopCounter);\n\n    return root;\n}\n\n/**\n* Uses one initial value and gradually takes that value near to the real one.\n**/\ndouble NewtonRaphson(){\n    double root=0;\n\n    double x1=1;\n    double x2=0;\n\n    int loopCounter=0;\n    while(1){\n        loopCounter++;\n\n        x2 = x1 - (f(x1)/f2(x1));\n        /*/printf(\"%lf \\t %lf \\n\", x2, f(x2));/**////test\n\n        if(f(x2)\u003c0.00001 \u0026\u0026 f(x2)\u003e-0.00001){\n            root=x2;\n            break;\n        }\n\n        x1=x2;\n    }\n    printf(\"It took %d loops.\\n\", loopCounter);\n\n    return root;\n}\n\n/**\n* Uses one initial value and gradually takes that value near to the real one.\n**/\ndouble FixedPoint(){\n    double root=0;\n    double x=1;\n\n    int loopCounter=0;\n    while(1){\n        loopCounter++;\n\n        if( (x-g(x)) \u003c0.00001 \u0026\u0026 (x-g(x)) \u003e-0.00001){\n            root = x;\n            break;\n        }\n\n        /*/printf(\"%lf \\t %lf \\n\", g(x), x-(g(x)));/**////test\n\n        x=g(x);\n    }\n    printf(\"It took %d loops.\\n\", loopCounter);\n\n    return root;\n}\n\n/**\n* uses two initial values \u0026 both value approaches to the root.\n**/\ndouble Secant(){\n    double root=0;\n\n    double x0=1;\n    double x1=2;\n    double x2=0;\n\n    int loopCounter=0;\n    while(1){\n        loopCounter++;\n\n        /*/printf(\"%lf \\t %lf \\t %lf \\n\", x0, x1, f(x1));/**////test\n\n        if(f(x1)\u003c0.00001 \u0026\u0026 f(x1)\u003e-0.00001){\n            root=x1;\n            break;\n        }\n\n        x2 = ((x0*f(x1))-(x1*f(x0))) / (f(x1)-f(x0));\n\n        x0=x1;\n        x1=x2;\n    }\n    printf(\"It took %d loops.\\n\", loopCounter);\n\n    return root;\n}\n\n\nint main(){\n    double root;\n\n    root = BisectionMethod();\n    printf(\"Using Bisection Method the root is: %lf \\n\\n\", root);\n    \n    root = FalsePosition();\n    printf(\"Using False Position Method the root is: %lf \\n\\n\", root);\n    \n    root = NewtonRaphson();\n    printf(\"Using Newton-Raphson Method the root is: %lf \\n\\n\", root);\n    \n    root = FixedPoint();\n    printf(\"Using Fixed Point Method the root is: %lf \\n\\n\", root);\n    \n    root = Secant();\n    printf(\"Using Secant Method the root is: %lf \\n\\n\", root);\n\n    return 0;\n}",
        "code_language": "Plain Text"
      }
    ],
    "title": "Non-Linear Equation",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}