{
  "ID": "6754affe-e3fb-47f8-8be0-c7c6ae46f2cb",
  "Root": {
    "alive": true,
    "content": [
      "43c5cad8-8742-49ca-8f59-208e06ddfab7",
      "cf561825-81f9-4c30-9846-e42fe5f5404e",
      "249b2c06-f21e-4c22-b669-7c27ad7edf07",
      "128bf98f-06c5-44de-8609-c5db8ab02f1d",
      "a507d21d-9c24-4416-a21e-511facc3cbf4",
      "ebf66655-ffea-4dc6-934b-6264ba16e0d7",
      "5ac3a538-b9c1-4437-bedf-0db217dbe639",
      "acee6369-c7fb-4460-a9c1-d62396d1df70"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1551929294740,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "6754affe-e3fb-47f8-8be0-c7c6ae46f2cb",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1551929294740,
    "parent_id": "a3747844-afb9-4883-bbb2-bea5662e919d",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Radix 2 Inverse FFT"
        ]
      ]
    },
    "type": "page",
    "version": 3,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929294735,
        "id": "43c5cad8-8742-49ca-8f59-208e06ddfab7",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929294735,
        "parent_id": "6754affe-e3fb-47f8-8be0-c7c6ae46f2cb",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Due to the strong duality of the Fourier Transform, adjusting the output of a forward transform can produce the inverse FFT. Data in the frequency domain can be converted to the time domain by the following method:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Due to the strong duality of the Fourier Transform, adjusting the output of a forward transform can produce the inverse FFT. Data in the frequency domain can be converted to the time domain by the following method:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929294738,
        "id": "cf561825-81f9-4c30-9846-e42fe5f5404e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929294738,
        "parent_id": "6754affe-e3fb-47f8-8be0-c7c6ae46f2cb",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Find the complex conjugate of the frequency domain data by inverting the imaginary component for all instances of K."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Find the complex conjugate of the frequency domain data by inverting the imaginary component for all instances of K."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929294739,
        "id": "249b2c06-f21e-4c22-b669-7c27ad7edf07",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929294739,
        "parent_id": "6754affe-e3fb-47f8-8be0-c7c6ae46f2cb",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Perform the forward FFT on the conjugated frequency domain data."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Perform the forward FFT on the conjugated frequency domain data."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929294739,
        "id": "128bf98f-06c5-44de-8609-c5db8ab02f1d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929294739,
        "parent_id": "6754affe-e3fb-47f8-8be0-c7c6ae46f2cb",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Divide each output of the result of this FFT by N to give the true time domain value."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Divide each output of the result of this FFT by N to give the true time domain value."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929294739,
        "id": "a507d21d-9c24-4416-a21e-511facc3cbf4",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929294739,
        "parent_id": "6754affe-e3fb-47f8-8be0-c7c6ae46f2cb",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Find the complex conjugate of the output by inverting the imaginary component of the time domain data for all instances of n."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Find the complex conjugate of the output by inverting the imaginary component of the time domain data for all instances of n."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929294739,
        "id": "ebf66655-ffea-4dc6-934b-6264ba16e0d7",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929294739,
        "parent_id": "6754affe-e3fb-47f8-8be0-c7c6ae46f2cb",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Note",
              [
                [
                  "b"
                ],
                [
                  "i"
                ]
              ]
            ],
            [
              ": both frequency and time domain data are complex variables. Typically the imaginary component of the time domain signal following an inverse FFT is either zero, or ignored as rounding error. Increasing the precision of variables from 32-bit float to 64-bit double, or 128-bit long double significantly reduces rounding errors produced by several consecutive FFT operations.",
              [
                [
                  "i"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Note",
            "AttrFlags": 5
          },
          {
            "Text": ": both frequency and time domain data are complex variables. Typically the imaginary component of the time domain signal following an inverse FFT is either zero, or ignored as rounding error. Increasing the precision of variables from 32-bit float to 64-bit double, or 128-bit long double significantly reduces rounding errors produced by several consecutive FFT operations.",
            "AttrFlags": 4
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929294739,
        "id": "5ac3a538-b9c1-4437-bedf-0db217dbe639",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929294739,
        "parent_id": "6754affe-e3fb-47f8-8be0-c7c6ae46f2cb",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Code Example (C/C++)",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Code Example (C/C++)",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929294740,
        "id": "acee6369-c7fb-4460-a9c1-d62396d1df70",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929294740,
        "parent_id": "6754affe-e3fb-47f8-8be0-c7c6ae46f2cb",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "#include \u003cmath.h\u003e\n\n#define PI       3.1415926535897932384626433832795    // PI for sine/cos calculations\n#define TWOPI    6.283185307179586476925286766559     // 2*PI for sine/cos calculations\n#define Deg2Rad  0.017453292519943295769236907684886  // Degrees to Radians factor\n#define Rad2Deg  57.295779513082320876798154814105    // Radians to Degrees factor\n#define log10_2  0.30102999566398119521373889472449   // Log10 of 2 \n#define log10_2_INV 3.3219280948873623478703194294948 // 1/Log10(2)\n\n// complex variable structure (double precision)\nstruct complex\n{\npublic:\n    double  Re, Im;        // Not so complicated after all\n}; \n\nvoid rad2InverseFFT(int N, complex *x, complex *DFT)\n{\n    // M is number of stages to perform. 2^M = N\n    double Mx = (log10((double)N) / log10((double)2));\n    int a = (int)(ceil(pow(2.0, Mx)));\n    int status = 0;\n    if (a != N) // Check N is a power of 2\n    {\n        x = 0;\n        DFT = 0;\n        throw \"rad2InverseFFT(): N must be a power of 2 for Radix 2 Inverse FFT\";\n    }\n\n    complex *pDFT = DFT;        // Reset vector for DFT pointers\n    complex *pX = x;            // Reset vector for x[n] pointer\n    double NN = 1 / (double)N;  // Scaling factor for the inverse FFT        \n\n    for (int i = 0; i \u003c N; i++, DFT++)\n        DFT-\u003eIm *= -1;          // Find the complex conjugate of the Frequency Spectrum\n\n    DFT = pDFT;                 // Reset Freq Domain Pointer\n    rad2FFT(N, DFT, x); // Calculate the forward FFT with variables switched (time \u0026 freq)\n\n    int i;\n    complex* x;\n    for ( i = 0, x = pX; i \u003c N; i++, x++){\n        x-\u003eRe *= NN;    // Divide time domain by N for correct amplitude scaling\n        x-\u003eIm *= -1;    // Change the sign of ImX\n    }    \n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "#include \u003cmath.h\u003e\n\n#define PI       3.1415926535897932384626433832795    // PI for sine/cos calculations\n#define TWOPI    6.283185307179586476925286766559     // 2*PI for sine/cos calculations\n#define Deg2Rad  0.017453292519943295769236907684886  // Degrees to Radians factor\n#define Rad2Deg  57.295779513082320876798154814105    // Radians to Degrees factor\n#define log10_2  0.30102999566398119521373889472449   // Log10 of 2 \n#define log10_2_INV 3.3219280948873623478703194294948 // 1/Log10(2)\n\n// complex variable structure (double precision)\nstruct complex\n{\npublic:\n    double  Re, Im;        // Not so complicated after all\n}; \n\nvoid rad2InverseFFT(int N, complex *x, complex *DFT)\n{\n    // M is number of stages to perform. 2^M = N\n    double Mx = (log10((double)N) / log10((double)2));\n    int a = (int)(ceil(pow(2.0, Mx)));\n    int status = 0;\n    if (a != N) // Check N is a power of 2\n    {\n        x = 0;\n        DFT = 0;\n        throw \"rad2InverseFFT(): N must be a power of 2 for Radix 2 Inverse FFT\";\n    }\n\n    complex *pDFT = DFT;        // Reset vector for DFT pointers\n    complex *pX = x;            // Reset vector for x[n] pointer\n    double NN = 1 / (double)N;  // Scaling factor for the inverse FFT        \n\n    for (int i = 0; i \u003c N; i++, DFT++)\n        DFT-\u003eIm *= -1;          // Find the complex conjugate of the Frequency Spectrum\n\n    DFT = pDFT;                 // Reset Freq Domain Pointer\n    rad2FFT(N, DFT, x); // Calculate the forward FFT with variables switched (time \u0026 freq)\n\n    int i;\n    complex* x;\n    for ( i = 0, x = pX; i \u003c N; i++, x++){\n        x-\u003eRe *= NN;    // Divide time domain by N for correct amplitude scaling\n        x-\u003eIm *= -1;    // Change the sign of ImX\n    }    \n}",
        "code_language": "Plain Text"
      }
    ],
    "title": "Radix 2 Inverse FFT",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}