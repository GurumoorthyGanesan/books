{
  "ID": "8ef1e18f-1673-4c22-b9d8-22c8a2ce9c63",
  "Root": {
    "alive": true,
    "content": [
      "1317b4a1-6694-4779-83b4-e0b7b2a5775d",
      "77f39c0a-73b3-45a2-8a0c-4a1d6ac6cf8c",
      "226c26ab-e7d4-4eff-8322-0ee090d58f54",
      "79a65bec-be82-44c9-a829-c1892a001b83",
      "6c702536-d614-4ebd-94d3-118ae1cdc65b",
      "c1b5fb58-913b-41b3-803d-1756b8f0dfd3",
      "4553c661-e62b-47b1-b5d7-86a3ad2dfcfc",
      "7539a302-76ac-4b15-95f3-349955290856",
      "a05cfa55-d52f-4532-95ad-97280f468283",
      "712c86c5-1416-47be-8588-0855cd8e1454",
      "eb6d12c8-8e2e-4902-b0d5-287779e07215"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1551928757091,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "8ef1e18f-1673-4c22-b9d8-22c8a2ce9c63",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1551928757091,
    "parent_id": "3104f50a-b7e2-41fe-97d7-f6e02201ccb8",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Finding Shortest Path from Source in a 2D graph"
        ]
      ]
    },
    "type": "page",
    "version": 3,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928757088,
        "id": "1317b4a1-6694-4779-83b4-e0b7b2a5775d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928757088,
        "parent_id": "8ef1e18f-1673-4c22-b9d8-22c8a2ce9c63",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Most of the time, we’ll need to find out the shortest path from single source to all other nodes or a specific node in a 2D graph. Say for example: we want to find out how many moves are required for a knight to reach a certain square in a chessboard, or we have an array where some cells are blocked, we have to find out the shortest path from one cell to another. We can move only horizontally and vertically. Even diagonal moves can be possible too. For these cases, we can convert the squares or cells in nodes and solve these problems easily using BFS. Now our "
            ],
            [
              "visited",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "parent",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "level",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " will be 2D arrays. For each node, we’ll consider all possible moves. To find the distance to a specific node, we’ll also check whether we have reached our destination."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Most of the time, we’ll need to find out the shortest path from single source to all other nodes or a specific node in a 2D graph. Say for example: we want to find out how many moves are required for a knight to reach a certain square in a chessboard, or we have an array where some cells are blocked, we have to find out the shortest path from one cell to another. We can move only horizontally and vertically. Even diagonal moves can be possible too. For these cases, we can convert the squares or cells in nodes and solve these problems easily using BFS. Now our "
          },
          {
            "Text": "visited",
            "AttrFlags": 1
          },
          {
            "Text": ", "
          },
          {
            "Text": "parent",
            "AttrFlags": 1
          },
          {
            "Text": " and "
          },
          {
            "Text": "level",
            "AttrFlags": 1
          },
          {
            "Text": " will be 2D arrays. For each node, we’ll consider all possible moves. To find the distance to a specific node, we’ll also check whether we have reached our destination."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928757089,
        "id": "77f39c0a-73b3-45a2-8a0c-4a1d6ac6cf8c",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928757089,
        "parent_id": "8ef1e18f-1673-4c22-b9d8-22c8a2ce9c63",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "There will be one additional thing called direction array. This will simply store the all possible combinations of directions we can go to. Let’s say, for horizontal and vertical moves, our direction arrays will be:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "There will be one additional thing called direction array. This will simply store the all possible combinations of directions we can go to. Let’s say, for horizontal and vertical moves, our direction arrays will be:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928757089,
        "id": "226c26ab-e7d4-4eff-8322-0ee090d58f54",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928757089,
        "parent_id": "8ef1e18f-1673-4c22-b9d8-22c8a2ce9c63",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "+----+-----+-----+-----+-----+\n| dx |  1  |  -1 |  0  |  0  |\n+----+-----+-----+-----+-----+\n| dy |  0  |   0 |  1  |  -1 |\n+----+-----+-----+-----+-----+"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "+----+-----+-----+-----+-----+\n| dx |  1  |  -1 |  0  |  0  |\n+----+-----+-----+-----+-----+\n| dy |  0  |   0 |  1  |  -1 |\n+----+-----+-----+-----+-----+",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928757089,
        "id": "79a65bec-be82-44c9-a829-c1892a001b83",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928757089,
        "parent_id": "8ef1e18f-1673-4c22-b9d8-22c8a2ce9c63",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Here "
            ],
            [
              "dx",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " represents move in x-axis and "
            ],
            [
              "dy",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " represents move in y-axis. Again this part is optional. You can also write all the possible combinations separately. But it’s easier to handle it using direction array. There can be more and even different combinations for diagonal moves or knight moves."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Here "
          },
          {
            "Text": "dx",
            "AttrFlags": 4
          },
          {
            "Text": " represents move in x-axis and "
          },
          {
            "Text": "dy",
            "AttrFlags": 4
          },
          {
            "Text": " represents move in y-axis. Again this part is optional. You can also write all the possible combinations separately. But it’s easier to handle it using direction array. There can be more and even different combinations for diagonal moves or knight moves."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928757089,
        "id": "6c702536-d614-4ebd-94d3-118ae1cdc65b",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928757089,
        "parent_id": "8ef1e18f-1673-4c22-b9d8-22c8a2ce9c63",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The additional part we need to keep in mind is:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The additional part we need to keep in mind is:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928757089,
        "id": "c1b5fb58-913b-41b3-803d-1756b8f0dfd3",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928757089,
        "parent_id": "8ef1e18f-1673-4c22-b9d8-22c8a2ce9c63",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "If any of the cell is blocked, for every possible moves, we’ll check if the cell is blocked or not."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "If any of the cell is blocked, for every possible moves, we’ll check if the cell is blocked or not."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928757089,
        "id": "4553c661-e62b-47b1-b5d7-86a3ad2dfcfc",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928757089,
        "parent_id": "8ef1e18f-1673-4c22-b9d8-22c8a2ce9c63",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "We’ll also check if we have gone out of bounds, that is we’ve crossed the array boundaries."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "We’ll also check if we have gone out of bounds, that is we’ve crossed the array boundaries."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928757090,
        "id": "7539a302-76ac-4b15-95f3-349955290856",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928757090,
        "parent_id": "8ef1e18f-1673-4c22-b9d8-22c8a2ce9c63",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The number of rows and columns will be given."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "The number of rows and columns will be given."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928757090,
        "id": "a05cfa55-d52f-4532-95ad-97280f468283",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928757090,
        "parent_id": "8ef1e18f-1673-4c22-b9d8-22c8a2ce9c63",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Our pseudo-code will be:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Our pseudo-code will be:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928757090,
        "id": "712c86c5-1416-47be-8588-0855cd8e1454",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928757090,
        "parent_id": "8ef1e18f-1673-4c22-b9d8-22c8a2ce9c63",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "Procedure BFS2D(Graph, blocksign, row, column):\nfor i from 1 to row\n    for j from 1 to column\n        visited[i][j] := false\n    end for\nend for\nvisited[source.x][source.y] := true\nlevel[source.x][source.y] := 0\nQ = queue()\nQ.push(source)\nm := dx.size\nwhile Q is not empty\n    top := Q.pop\n    for i from 1 to m\n        temp.x := top.x + dx[i]\n        temp.y := top.y + dy[i]\n        if temp is inside the row and column and top doesn't equal to blocksign\n            visited[temp.x][temp.y] := true\n            level[temp.x][temp.y] := level[top.x][top.y] + 1\n            Q.push(temp)\n        end if\n    end for\nend while\nReturn level"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "Procedure BFS2D(Graph, blocksign, row, column):\nfor i from 1 to row\n    for j from 1 to column\n        visited[i][j] := false\n    end for\nend for\nvisited[source.x][source.y] := true\nlevel[source.x][source.y] := 0\nQ = queue()\nQ.push(source)\nm := dx.size\nwhile Q is not empty\n    top := Q.pop\n    for i from 1 to m\n        temp.x := top.x + dx[i]\n        temp.y := top.y + dy[i]\n        if temp is inside the row and column and top doesn't equal to blocksign\n            visited[temp.x][temp.y] := true\n            level[temp.x][temp.y] := level[top.x][top.y] + 1\n            Q.push(temp)\n        end if\n    end for\nend while\nReturn level",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928757091,
        "id": "eb6d12c8-8e2e-4902-b0d5-287779e07215",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928757091,
        "parent_id": "8ef1e18f-1673-4c22-b9d8-22c8a2ce9c63",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "As we have discussed earlier, BFS only works for unweighted graphs. For weighted graphs, we’ll need "
            ],
            [
              "Dijkstra",
              [
                [
                  "a",
                  "http://stackoverflow.com/documentation/algorithm/7151/dijkstra-s-algorithm/23947/dijkstras-shortest-path-algorithm"
                ]
              ]
            ],
            [
              "’s algorithm. For negative edge cycles, we need "
            ],
            [
              "Bellman-Ford",
              [
                [
                  "a",
                  "http://stackoverflow.com/documentation/algorithm/4791/bellman-ford-algorithm"
                ]
              ]
            ],
            [
              "‘s algorithm. Again this algorithm is single source shortest path algorithm. If we need to find out distance from each nodes to all other nodes, we’ll need "
            ],
            [
              "Floyd-Warshall",
              [
                [
                  "a",
                  "http://stackoverflow.com/documentation/algorithm/7193/floyd-warshall-algorithm"
                ]
              ]
            ],
            [
              "’s algorithm."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "As we have discussed earlier, BFS only works for unweighted graphs. For weighted graphs, we’ll need "
          },
          {
            "Text": "Dijkstra",
            "Link": "http://stackoverflow.com/documentation/algorithm/7151/dijkstra-s-algorithm/23947/dijkstras-shortest-path-algorithm"
          },
          {
            "Text": "’s algorithm. For negative edge cycles, we need "
          },
          {
            "Text": "Bellman-Ford",
            "Link": "http://stackoverflow.com/documentation/algorithm/4791/bellman-ford-algorithm"
          },
          {
            "Text": "‘s algorithm. Again this algorithm is single source shortest path algorithm. If we need to find out distance from each nodes to all other nodes, we’ll need "
          },
          {
            "Text": "Floyd-Warshall",
            "Link": "http://stackoverflow.com/documentation/algorithm/7193/floyd-warshall-algorithm"
          },
          {
            "Text": "’s algorithm."
          }
        ]
      }
    ],
    "title": "Finding Shortest Path from Source in a 2D graph",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}