{
  "ID": "57bca74c-8370-4324-a20c-070d94d57c65",
  "Root": {
    "alive": true,
    "content": [
      "78c8b8f1-3e10-4d19-b4f2-cd379ba390f2",
      "77371615-d1b8-459c-ad0a-316da8088914",
      "0e9cad52-4665-4cdd-8a6f-6cd5e8e9266c",
      "4a22390a-d97b-4d85-b197-c3058f881636",
      "6ece595d-37bb-4d92-8d9e-835f38717b1c",
      "f7ee29ed-3210-468b-bddf-0e18eeb7e628",
      "2c8b07f2-ab18-4a29-a1ee-cb6050a3fca3",
      "3327c4e8-d33b-4a51-ac71-079b9f241893",
      "3e050204-35a4-4c9e-8bd3-e16725cdb660",
      "bcebca43-b742-4070-bb8f-b2328956cc83",
      "fcf11548-a890-44c3-8704-f590d357ea94",
      "cc0f8a55-d7d5-45b5-b921-8631dfd41007",
      "8dc6b6d1-c395-4359-ba36-97cabd1d9c44",
      "a47ff269-e23b-4457-99fd-29ae208c8fe2",
      "e1712cbb-dde1-4e2f-bf4f-b528a6b30305",
      "796e3eb8-0451-4d59-b72e-8d20d0677e7a"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1551929293494,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "57bca74c-8370-4324-a20c-070d94d57c65",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1551929293494,
    "parent_id": "a3747844-afb9-4883-bbb2-bea5662e919d",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Radix 2 FFT"
        ]
      ]
    },
    "type": "page",
    "version": 3,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929293482,
        "id": "78c8b8f1-3e10-4d19-b4f2-cd379ba390f2",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929293482,
        "parent_id": "57bca74c-8370-4324-a20c-070d94d57c65",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The simplest and perhaps best-known method for computing the FFT is the Radix-2 Decimation in Time algorithm. The Radix-2 FFT works by decomposing an N point time domain signal into N time domain signals each composed of a single point"
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The simplest and perhaps best-known method for computing the FFT is the Radix-2 Decimation in Time algorithm. The Radix-2 FFT works by decomposing an N point time domain signal into N time domain signals each composed of a single point"
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929293484,
        "id": "77371615-d1b8-459c-ad0a-316da8088914",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929293484,
        "parent_id": "57bca74c-8370-4324-a20c-070d94d57c65",
        "parent_table": "block",
        "properties": {
          "source": [
            [
              "/tmp/4155f2a3-22d0-4f99-9436-eb90ede08377/f0841aecd875fd7f691c5637aa72cd38402af5f1.png"
            ]
          ]
        },
        "type": "image",
        "version": 1,
        "source": "/tmp/4155f2a3-22d0-4f99-9436-eb90ede08377/f0841aecd875fd7f691c5637aa72cd38402af5f1.png",
        "image_url": "https://www.notion.so/image/https:%2F%2Fwww.notion.so%2Ftmp%2F4155f2a3-22d0-4f99-9436-eb90ede08377%2Ff0841aecd875fd7f691c5637aa72cd38402af5f1.png"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929293485,
        "id": "0e9cad52-4665-4cdd-8a6f-6cd5e8e9266c",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929293485,
        "parent_id": "57bca74c-8370-4324-a20c-070d94d57c65",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Signal decomposition, or ‘decimation in time’ is achieved by bit reversing the indices for the array of time domain data. Thus, for a sixteen-point signal, sample 1 (Binary 0001) is swapped with sample 8 (1000), sample 2 (0010) is swapped with 4 (0100) and so on. Sample swapping using the bit reverse technique can be achieved simply in software, but limits the use of the Radix 2 FFT to signals of length N = 2^M."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Signal decomposition, or ‘decimation in time’ is achieved by bit reversing the indices for the array of time domain data. Thus, for a sixteen-point signal, sample 1 (Binary 0001) is swapped with sample 8 (1000), sample 2 (0010) is swapped with 4 (0100) and so on. Sample swapping using the bit reverse technique can be achieved simply in software, but limits the use of the Radix 2 FFT to signals of length N = 2^M."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929293485,
        "id": "4a22390a-d97b-4d85-b197-c3058f881636",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929293485,
        "parent_id": "57bca74c-8370-4324-a20c-070d94d57c65",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The value of a 1-point signal in the time domain is equal to its value in the frequency domain, thus this array of decomposed single time-domain points requires no transformation to become an array of frequency domain points. The N single points; however, need to be reconstructed into one N-point frequency spectra. Optimal reconstruction of the complete frequency spectrum is performed using butterfly calculations. Each reconstruction stage in the Radix-2 FFT performs a number of two point butterflies, using a similar set of exponential weighting functions, Wn^R."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The value of a 1-point signal in the time domain is equal to its value in the frequency domain, thus this array of decomposed single time-domain points requires no transformation to become an array of frequency domain points. The N single points; however, need to be reconstructed into one N-point frequency spectra. Optimal reconstruction of the complete frequency spectrum is performed using butterfly calculations. Each reconstruction stage in the Radix-2 FFT performs a number of two point butterflies, using a similar set of exponential weighting functions, Wn^R."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929293485,
        "id": "6ece595d-37bb-4d92-8d9e-835f38717b1c",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929293485,
        "parent_id": "57bca74c-8370-4324-a20c-070d94d57c65",
        "parent_table": "block",
        "properties": {
          "source": [
            [
              "/tmp/4155f2a3-22d0-4f99-9436-eb90ede08377/2f6c4f7f9d760ec866c3f689e3e5a2b43d8a3dbd.png"
            ]
          ]
        },
        "type": "image",
        "version": 1,
        "source": "/tmp/4155f2a3-22d0-4f99-9436-eb90ede08377/2f6c4f7f9d760ec866c3f689e3e5a2b43d8a3dbd.png",
        "image_url": "https://www.notion.so/image/https:%2F%2Fwww.notion.so%2Ftmp%2F4155f2a3-22d0-4f99-9436-eb90ede08377%2F2f6c4f7f9d760ec866c3f689e3e5a2b43d8a3dbd.png"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929293492,
        "id": "f7ee29ed-3210-468b-bddf-0e18eeb7e628",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929293492,
        "parent_id": "57bca74c-8370-4324-a20c-070d94d57c65",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The FFT removes redundant calculations in the Discrete Fourier Transform by exploiting the periodicity of Wn^R. Spectral reconstruction is completed in log2(N) stages of butterfly calculations giving X[K]; the real and imaginary frequency domain data in rectangular form. To convert to magnitude and phase (polar coordinates) requires finding the absolute value, √(Re2 + Im2), and argument, tan-1(Im/Re)."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The FFT removes redundant calculations in the Discrete Fourier Transform by exploiting the periodicity of Wn^R. Spectral reconstruction is completed in log2(N) stages of butterfly calculations giving X[K]; the real and imaginary frequency domain data in rectangular form. To convert to magnitude and phase (polar coordinates) requires finding the absolute value, √(Re2 + Im2), and argument, tan-1(Im/Re)."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929293493,
        "id": "2c8b07f2-ab18-4a29-a1ee-cb6050a3fca3",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929293493,
        "parent_id": "57bca74c-8370-4324-a20c-070d94d57c65",
        "parent_table": "block",
        "properties": {
          "source": [
            [
              "/tmp/4155f2a3-22d0-4f99-9436-eb90ede08377/e125a76f0166a1d96fcc3aea74c1b44ee6eb5fa9.png"
            ]
          ]
        },
        "type": "image",
        "version": 1,
        "source": "/tmp/4155f2a3-22d0-4f99-9436-eb90ede08377/e125a76f0166a1d96fcc3aea74c1b44ee6eb5fa9.png",
        "image_url": "https://www.notion.so/image/https:%2F%2Fwww.notion.so%2Ftmp%2F4155f2a3-22d0-4f99-9436-eb90ede08377%2Fe125a76f0166a1d96fcc3aea74c1b44ee6eb5fa9.png"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929293493,
        "id": "3327c4e8-d33b-4a51-ac71-079b9f241893",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929293493,
        "parent_id": "57bca74c-8370-4324-a20c-070d94d57c65",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The complete butterfly flow diagram for an eight point Radix 2 FFT is shown below. Note the input signals have previously been reordered according to the decimation in time procedure outlined previously."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The complete butterfly flow diagram for an eight point Radix 2 FFT is shown below. Note the input signals have previously been reordered according to the decimation in time procedure outlined previously."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929293493,
        "id": "3e050204-35a4-4c9e-8bd3-e16725cdb660",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929293493,
        "parent_id": "57bca74c-8370-4324-a20c-070d94d57c65",
        "parent_table": "block",
        "properties": {
          "source": [
            [
              "/tmp/4155f2a3-22d0-4f99-9436-eb90ede08377/9d3b0ce5f90f98a6a86c613cad5a07d018ca9f6f.png"
            ]
          ]
        },
        "type": "image",
        "version": 1,
        "source": "/tmp/4155f2a3-22d0-4f99-9436-eb90ede08377/9d3b0ce5f90f98a6a86c613cad5a07d018ca9f6f.png",
        "image_url": "https://www.notion.so/image/https:%2F%2Fwww.notion.so%2Ftmp%2F4155f2a3-22d0-4f99-9436-eb90ede08377%2F9d3b0ce5f90f98a6a86c613cad5a07d018ca9f6f.png"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929293493,
        "id": "bcebca43-b742-4070-bb8f-b2328956cc83",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929293493,
        "parent_id": "57bca74c-8370-4324-a20c-070d94d57c65",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The FFT typically operates on complex inputs and produces a complex output. For real signals, the imaginary part may be set to zero and real part set to the input signal, x[n], however many optimisations are possible involving the transformation of real-only data. Values of Wn^R used throughout the reconstruction can be determined using the exponential weighting equation."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The FFT typically operates on complex inputs and produces a complex output. For real signals, the imaginary part may be set to zero and real part set to the input signal, x[n], however many optimisations are possible involving the transformation of real-only data. Values of Wn^R used throughout the reconstruction can be determined using the exponential weighting equation."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929293493,
        "id": "fcf11548-a890-44c3-8704-f590d357ea94",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929293493,
        "parent_id": "57bca74c-8370-4324-a20c-070d94d57c65",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The value of R (the exponential weighting power) is determined the current stage in the spectral reconstruction and the current calculation within a particular butterfly."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The value of R (the exponential weighting power) is determined the current stage in the spectral reconstruction and the current calculation within a particular butterfly."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929293494,
        "id": "cc0f8a55-d7d5-45b5-b921-8631dfd41007",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929293494,
        "parent_id": "57bca74c-8370-4324-a20c-070d94d57c65",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Code Example (C/C++)",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Code Example (C/C++)",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929293494,
        "id": "8dc6b6d1-c395-4359-ba36-97cabd1d9c44",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929293494,
        "parent_id": "57bca74c-8370-4324-a20c-070d94d57c65",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "A C/C++ code sample for computing the Radix 2 FFT can be found below. This is a simple implementation which works for any size N where N is a power of 2. It is approx 3x slower than the fastest FFTw implementation, but still a very good basis for future optimisation or for learning about how this algorithm works."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "A C/C++ code sample for computing the Radix 2 FFT can be found below. This is a simple implementation which works for any size N where N is a power of 2. It is approx 3x slower than the fastest FFTw implementation, but still a very good basis for future optimisation or for learning about how this algorithm works."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929293494,
        "id": "a47ff269-e23b-4457-99fd-29ae208c8fe2",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929293494,
        "parent_id": "57bca74c-8370-4324-a20c-070d94d57c65",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "#include \u003cmath.h\u003e\n\n#define PI       3.1415926535897932384626433832795    // PI for sine/cos calculations\n#define TWOPI    6.283185307179586476925286766559     // 2*PI for sine/cos calculations\n#define Deg2Rad  0.017453292519943295769236907684886  // Degrees to Radians factor\n#define Rad2Deg  57.295779513082320876798154814105    // Radians to Degrees factor\n#define log10_2  0.30102999566398119521373889472449   // Log10 of 2 \n#define log10_2_INV 3.3219280948873623478703194294948 // 1/Log10(2)\n\n// complex variable structure (double precision)\nstruct complex\n{\npublic:\n    double  Re, Im;        // Not so complicated after all\n};\n\n// Returns true if N is a power of 2\nbool isPwrTwo(int N, int *M)\n{\n    *M = (int)ceil(log10((double)N) * log10_2_INV);// M is number of stages to perform. 2^M = N\n    int NN = (int)pow(2.0, *M);\n    if ((NN != N) || (NN == 0)) // Check N is a power of 2. \n        return false;\n\n    return true;\n}\n\nvoid rad2FFT(int N, complex *x, complex *DFT)\n{\n    int M = 0;\n\n    // Check if power of two. If not, exit        \n    if (!isPwrTwo(N, \u0026M))\n        throw \"Rad2FFT(): N must be a power of 2 for Radix FFT\";\n\n    // Integer Variables\n\n    int BSep;                  // BSep is memory spacing between butterflies\n    int BWidth;                // BWidth is memory spacing of opposite ends of the butterfly\n    int P;                     // P is number of similar Wn's to be used in that stage\n    int j;                     // j is used in a loop to perform all calculations in each stage\n    int stage = 1;             // stage is the stage number of the FFT. There are M stages in total (1 to M).\n    int HiIndex;               // HiIndex is the index of the DFT array for the top value of each butterfly calc \n    unsigned int iaddr;        // bitmask for bit reversal \n    int ii;                    // Integer bitfield for bit reversal (Decimation in Time)\n    int MM1 = M - 1;\n\n    unsigned int i;\n    int l;\n    unsigned int nMax = (unsigned int)N;\n\n    // Double Precision Variables\n    double TwoPi_N = TWOPI / (double)N;    // constant to save computational time.  = 2*PI / N\n    double TwoPi_NP;\n\n    // complex Variables (See 'struct complex')\n    complex WN;               // Wn is the exponential weighting function in the form a + jb\n    complex TEMP;             // TEMP is used to save computation in the butterfly calc\n    complex *pDFT = DFT;      // Pointer to first elements in DFT array\n    complex *pLo;             // Pointer for lo / hi value of butterfly calcs\n    complex *pHi;\n    complex *pX;              // Pointer to x[n]"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "#include \u003cmath.h\u003e\n\n#define PI       3.1415926535897932384626433832795    // PI for sine/cos calculations\n#define TWOPI    6.283185307179586476925286766559     // 2*PI for sine/cos calculations\n#define Deg2Rad  0.017453292519943295769236907684886  // Degrees to Radians factor\n#define Rad2Deg  57.295779513082320876798154814105    // Radians to Degrees factor\n#define log10_2  0.30102999566398119521373889472449   // Log10 of 2 \n#define log10_2_INV 3.3219280948873623478703194294948 // 1/Log10(2)\n\n// complex variable structure (double precision)\nstruct complex\n{\npublic:\n    double  Re, Im;        // Not so complicated after all\n};\n\n// Returns true if N is a power of 2\nbool isPwrTwo(int N, int *M)\n{\n    *M = (int)ceil(log10((double)N) * log10_2_INV);// M is number of stages to perform. 2^M = N\n    int NN = (int)pow(2.0, *M);\n    if ((NN != N) || (NN == 0)) // Check N is a power of 2. \n        return false;\n\n    return true;\n}\n\nvoid rad2FFT(int N, complex *x, complex *DFT)\n{\n    int M = 0;\n\n    // Check if power of two. If not, exit        \n    if (!isPwrTwo(N, \u0026M))\n        throw \"Rad2FFT(): N must be a power of 2 for Radix FFT\";\n\n    // Integer Variables\n\n    int BSep;                  // BSep is memory spacing between butterflies\n    int BWidth;                // BWidth is memory spacing of opposite ends of the butterfly\n    int P;                     // P is number of similar Wn's to be used in that stage\n    int j;                     // j is used in a loop to perform all calculations in each stage\n    int stage = 1;             // stage is the stage number of the FFT. There are M stages in total (1 to M).\n    int HiIndex;               // HiIndex is the index of the DFT array for the top value of each butterfly calc \n    unsigned int iaddr;        // bitmask for bit reversal \n    int ii;                    // Integer bitfield for bit reversal (Decimation in Time)\n    int MM1 = M - 1;\n\n    unsigned int i;\n    int l;\n    unsigned int nMax = (unsigned int)N;\n\n    // Double Precision Variables\n    double TwoPi_N = TWOPI / (double)N;    // constant to save computational time.  = 2*PI / N\n    double TwoPi_NP;\n\n    // complex Variables (See 'struct complex')\n    complex WN;               // Wn is the exponential weighting function in the form a + jb\n    complex TEMP;             // TEMP is used to save computation in the butterfly calc\n    complex *pDFT = DFT;      // Pointer to first elements in DFT array\n    complex *pLo;             // Pointer for lo / hi value of butterfly calcs\n    complex *pHi;\n    complex *pX;              // Pointer to x[n]",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929293494,
        "id": "e1712cbb-dde1-4e2f-bf4f-b528a6b30305",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929293494,
        "parent_id": "57bca74c-8370-4324-a20c-070d94d57c65",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "// Decimation In Time - x[n] sample sorting\nfor (i = 0; i \u003c nMax; i++, DFT++)\n{\n    pX = x + i;             // Calculate current x[n] from base address *x and index i.\n    ii = 0;                 // Reset new address for DFT[n]\n    iaddr = i;              // Copy i for manipulations\n    for (l = 0; l \u003c M; l++) // Bit reverse i and store in ii...\n    {\n        if (iaddr \u0026 0x01)     // Detemine least significant bit\n            ii += (1 \u003c\u003c (MM1 - l));    // Increment ii by 2^(M-1-l) if lsb was 1\n        iaddr \u003e\u003e= 1;                // right shift iaddr to test next bit. Use logical operations for speed increase\n        if (!iaddr)\n            break;\n    }\n    DFT = pDFT + ii;        // Calculate current DFT[n] from base address *pDFT and bit reversed index ii    \n    DFT-\u003eRe = pX-\u003eRe;       // Update the complex array with address sorted time domain signal x[n]\n    DFT-\u003eIm = pX-\u003eIm;       // NB: Imaginary is always zero\n}\n\n// FFT Computation by butterfly calculation\nfor (stage = 1; stage \u003c= M; stage++) // Loop for M stages, where 2^M = N\n{\n    BSep = (int)(pow(2, stage)); // Separation between butterflies = 2^stage\n    P = N / BSep;             // Similar Wn's in this stage = N/Bsep\n    BWidth = BSep / 2;     // Butterfly width (spacing between opposite points) = Separation / 2.\n\n    TwoPi_NP = TwoPi_N*P;\n\n    for (j = 0; j \u003c BWidth; j++) // Loop for j calculations per butterfly\n    {\n        if (j != 0)              // Save on calculation if R = 0, as WN^0 = (1 + j0)\n        {\n            //WN.Re = cos(TwoPi_NP*j)\n            WN.Re = cos(TwoPi_N*P*j);     // Calculate Wn (Real and Imaginary)\n            WN.Im = -sin(TwoPi_N*P*j);\n        }\n\n        for (HiIndex = j; HiIndex \u003c N; HiIndex += BSep) // Loop for HiIndex Step BSep butterflies per stage\n        {\n            pHi = pDFT + HiIndex;                  // Point to higher value\n            pLo = pHi + BWidth;                    // Point to lower value (Note VC++ adjusts for spacing between elements)\n\n            if (j != 0)                            // If exponential power is not zero...\n            {\n                //CMult(pLo, \u0026WN, \u0026TEMP);          // Perform complex multiplication of Lovalue with Wn\n                TEMP.Re = (pLo-\u003eRe * WN.Re) - (pLo-\u003eIm * WN.Im);\n                TEMP.Im = (pLo-\u003eRe * WN.Im) + (pLo-\u003eIm * WN.Re);\n\n                //CSub (pHi, \u0026TEMP, pLo);\n                pLo-\u003eRe = pHi-\u003eRe - TEMP.Re;       // Find new Lovalue (complex subtraction)\n                pLo-\u003eIm = pHi-\u003eIm - TEMP.Im;\n\n                //CAdd (pHi, \u0026TEMP, pHi);          // Find new Hivalue (complex addition)\n                pHi-\u003eRe = (pHi-\u003eRe + TEMP.Re);\n                pHi-\u003eIm = (pHi-\u003eIm + TEMP.Im);\n            }\n            else\n            {\n                TEMP.Re = pLo-\u003eRe;\n                TEMP.Im = pLo-\u003eIm;\n\n                //CSub (pHi, \u0026TEMP, pLo);\n                pLo-\u003eRe = pHi-\u003eRe - TEMP.Re;       // Find new Lovalue (complex subtraction)\n                pLo-\u003eIm = pHi-\u003eIm - TEMP.Im;\n\n                //CAdd (pHi, \u0026TEMP, pHi);          // Find new Hivalue (complex addition)\n                pHi-\u003eRe = (pHi-\u003eRe + TEMP.Re);\n                pHi-\u003eIm = (pHi-\u003eIm + TEMP.Im);\n            }\n        }\n    }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "// Decimation In Time - x[n] sample sorting\nfor (i = 0; i \u003c nMax; i++, DFT++)\n{\n    pX = x + i;             // Calculate current x[n] from base address *x and index i.\n    ii = 0;                 // Reset new address for DFT[n]\n    iaddr = i;              // Copy i for manipulations\n    for (l = 0; l \u003c M; l++) // Bit reverse i and store in ii...\n    {\n        if (iaddr \u0026 0x01)     // Detemine least significant bit\n            ii += (1 \u003c\u003c (MM1 - l));    // Increment ii by 2^(M-1-l) if lsb was 1\n        iaddr \u003e\u003e= 1;                // right shift iaddr to test next bit. Use logical operations for speed increase\n        if (!iaddr)\n            break;\n    }\n    DFT = pDFT + ii;        // Calculate current DFT[n] from base address *pDFT and bit reversed index ii    \n    DFT-\u003eRe = pX-\u003eRe;       // Update the complex array with address sorted time domain signal x[n]\n    DFT-\u003eIm = pX-\u003eIm;       // NB: Imaginary is always zero\n}\n\n// FFT Computation by butterfly calculation\nfor (stage = 1; stage \u003c= M; stage++) // Loop for M stages, where 2^M = N\n{\n    BSep = (int)(pow(2, stage)); // Separation between butterflies = 2^stage\n    P = N / BSep;             // Similar Wn's in this stage = N/Bsep\n    BWidth = BSep / 2;     // Butterfly width (spacing between opposite points) = Separation / 2.\n\n    TwoPi_NP = TwoPi_N*P;\n\n    for (j = 0; j \u003c BWidth; j++) // Loop for j calculations per butterfly\n    {\n        if (j != 0)              // Save on calculation if R = 0, as WN^0 = (1 + j0)\n        {\n            //WN.Re = cos(TwoPi_NP*j)\n            WN.Re = cos(TwoPi_N*P*j);     // Calculate Wn (Real and Imaginary)\n            WN.Im = -sin(TwoPi_N*P*j);\n        }\n\n        for (HiIndex = j; HiIndex \u003c N; HiIndex += BSep) // Loop for HiIndex Step BSep butterflies per stage\n        {\n            pHi = pDFT + HiIndex;                  // Point to higher value\n            pLo = pHi + BWidth;                    // Point to lower value (Note VC++ adjusts for spacing between elements)\n\n            if (j != 0)                            // If exponential power is not zero...\n            {\n                //CMult(pLo, \u0026WN, \u0026TEMP);          // Perform complex multiplication of Lovalue with Wn\n                TEMP.Re = (pLo-\u003eRe * WN.Re) - (pLo-\u003eIm * WN.Im);\n                TEMP.Im = (pLo-\u003eRe * WN.Im) + (pLo-\u003eIm * WN.Re);\n\n                //CSub (pHi, \u0026TEMP, pLo);\n                pLo-\u003eRe = pHi-\u003eRe - TEMP.Re;       // Find new Lovalue (complex subtraction)\n                pLo-\u003eIm = pHi-\u003eIm - TEMP.Im;\n\n                //CAdd (pHi, \u0026TEMP, pHi);          // Find new Hivalue (complex addition)\n                pHi-\u003eRe = (pHi-\u003eRe + TEMP.Re);\n                pHi-\u003eIm = (pHi-\u003eIm + TEMP.Im);\n            }\n            else\n            {\n                TEMP.Re = pLo-\u003eRe;\n                TEMP.Im = pLo-\u003eIm;\n\n                //CSub (pHi, \u0026TEMP, pLo);\n                pLo-\u003eRe = pHi-\u003eRe - TEMP.Re;       // Find new Lovalue (complex subtraction)\n                pLo-\u003eIm = pHi-\u003eIm - TEMP.Im;\n\n                //CAdd (pHi, \u0026TEMP, pHi);          // Find new Hivalue (complex addition)\n                pHi-\u003eRe = (pHi-\u003eRe + TEMP.Re);\n                pHi-\u003eIm = (pHi-\u003eIm + TEMP.Im);\n            }\n        }\n    }\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929293494,
        "id": "796e3eb8-0451-4d59-b72e-8d20d0677e7a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929293494,
        "parent_id": "57bca74c-8370-4324-a20c-070d94d57c65",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "pLo = 0;    // Null all pointers\npHi = 0;\npDFT = 0;\nDFT = 0;\npX = 0;\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "pLo = 0;    // Null all pointers\npHi = 0;\npDFT = 0;\nDFT = 0;\npX = 0;\n}",
        "code_language": "Plain Text"
      }
    ],
    "title": "Radix 2 FFT",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}