{
  "ID": "19222d13-f52f-43e1-a054-e0733cc5ec1c",
  "Root": {
    "alive": true,
    "content": [
      "e56dd7d7-62f8-477e-90ee-4cd0e6c6d8cd",
      "62e407df-5a48-4913-a248-7d3df0814f0d",
      "2834cfc5-440c-4d26-83b2-0c553a2a01ad",
      "e064ff4f-c28b-4383-8dfd-c80c9f9a1ba4",
      "d4238950-6716-4776-8f0e-1899da59517d",
      "39b175af-fadc-4982-95c3-5d373c3b8d23",
      "271022dd-13f7-451f-8358-e0f130586961",
      "c5c8e8f6-f61c-4348-8dca-8b717da5a1cc",
      "4670cfe7-9aab-479e-bf72-146bb434cc4b",
      "fec83828-9107-4798-a084-b9baeff2c773",
      "4c5776e3-052a-4809-a637-0ebcb106c039",
      "45ba4ddd-6903-4819-8325-338d75b73db2",
      "6f9dcb5d-efb0-4ea7-b3e2-ad2414d72b6d"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1551928073200,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "19222d13-f52f-43e1-a054-e0733cc5ec1c",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1551928073200,
    "parent_id": "e737c451-edb2-4ee1-8b50-4891f751f559",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Optimal disjoint-set based implementation"
        ]
      ]
    },
    "type": "page",
    "version": 3,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928073187,
        "id": "e56dd7d7-62f8-477e-90ee-4cd0e6c6d8cd",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928073187,
        "parent_id": "19222d13-f52f-43e1-a054-e0733cc5ec1c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "We can do two things to improve the simple and sub-optimal disjoint-set subalgorithms:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "We can do two things to improve the simple and sub-optimal disjoint-set subalgorithms:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928073196,
        "id": "62e407df-5a48-4913-a248-7d3df0814f0d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928073196,
        "parent_id": "19222d13-f52f-43e1-a054-e0733cc5ec1c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Path compression heuristic",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ": "
            ],
            [
              "findSet",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " does not need to ever handle a tree with height bigger than "
            ],
            [
              "2",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ". If it ends up iterating such a tree, it can link the lower nodes directly to the root, optimizing future traversals;"
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Path compression heuristic",
            "AttrFlags": 1
          },
          {
            "Text": ": "
          },
          {
            "Text": "findSet",
            "AttrFlags": 2
          },
          {
            "Text": " does not need to ever handle a tree with height bigger than "
          },
          {
            "Text": "2",
            "AttrFlags": 2
          },
          {
            "Text": ". If it ends up iterating such a tree, it can link the lower nodes directly to the root, optimizing future traversals;"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928073197,
        "id": "2834cfc5-440c-4d26-83b2-0c553a2a01ad",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928073197,
        "parent_id": "19222d13-f52f-43e1-a054-e0733cc5ec1c",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "subalgo findSet(v: a node):\n    if v.parent != v\n        v.parent = findSet(v.parent)\n    return v.parent"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "subalgo findSet(v: a node):\n    if v.parent != v\n        v.parent = findSet(v.parent)\n    return v.parent",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928073198,
        "id": "e064ff4f-c28b-4383-8dfd-c80c9f9a1ba4",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928073198,
        "parent_id": "19222d13-f52f-43e1-a054-e0733cc5ec1c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Height-based merging heuristic",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ": for each node, store the height of its subtree. When merging, make the taller tree the parent of the smaller one, thus not increasing anyone’s height."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Height-based merging heuristic",
            "AttrFlags": 1
          },
          {
            "Text": ": for each node, store the height of its subtree. When merging, make the taller tree the parent of the smaller one, thus not increasing anyone’s height."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928073198,
        "id": "d4238950-6716-4776-8f0e-1899da59517d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928073198,
        "parent_id": "19222d13-f52f-43e1-a054-e0733cc5ec1c",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "subalgo unionSet(u, v: nodes):\n    vRoot = findSet(v)\n    uRoot = findSet(u)"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "subalgo unionSet(u, v: nodes):\n    vRoot = findSet(v)\n    uRoot = findSet(u)",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928073198,
        "id": "39b175af-fadc-4982-95c3-5d373c3b8d23",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928073198,
        "parent_id": "19222d13-f52f-43e1-a054-e0733cc5ec1c",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "if vRoot == uRoot:\n    return\n\nif vRoot.height \u003c uRoot.height:\n    vRoot.parent = uRoot\nelse if vRoot.height \u003e uRoot.height:\n    uRoot.parent = vRoot\nelse:\n    uRoot.parent = vRoot\n    uRoot.height =  uRoot.height + 1"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "if vRoot == uRoot:\n    return\n\nif vRoot.height \u003c uRoot.height:\n    vRoot.parent = uRoot\nelse if vRoot.height \u003e uRoot.height:\n    uRoot.parent = vRoot\nelse:\n    uRoot.parent = vRoot\n    uRoot.height =  uRoot.height + 1",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928073198,
        "id": "271022dd-13f7-451f-8358-e0f130586961",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928073198,
        "parent_id": "19222d13-f52f-43e1-a054-e0733cc5ec1c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "This leads to "
            ],
            [
              "O(alpha(n))",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " time for each operation, where "
            ],
            [
              "alpha",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " is the inverse of the fast-growing Ackermann function, thus it is very slow growing, and can be considered "
            ],
            [
              "O(1)",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " for practical purposes."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "This leads to "
          },
          {
            "Text": "O(alpha(n))",
            "AttrFlags": 2
          },
          {
            "Text": " time for each operation, where "
          },
          {
            "Text": "alpha",
            "AttrFlags": 2
          },
          {
            "Text": " is the inverse of the fast-growing Ackermann function, thus it is very slow growing, and can be considered "
          },
          {
            "Text": "O(1)",
            "AttrFlags": 2
          },
          {
            "Text": " for practical purposes."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928073199,
        "id": "c5c8e8f6-f61c-4348-8dca-8b717da5a1cc",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928073199,
        "parent_id": "19222d13-f52f-43e1-a054-e0733cc5ec1c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "This makes the entire Kruskal’s algorithm "
            ],
            [
              "O(m log m + m) = O(m log m)",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ", because of the initial sorting."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "This makes the entire Kruskal’s algorithm "
          },
          {
            "Text": "O(m log m + m) = O(m log m)",
            "AttrFlags": 2
          },
          {
            "Text": ", because of the initial sorting."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928073199,
        "id": "4670cfe7-9aab-479e-bf72-146bb434cc4b",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928073199,
        "parent_id": "19222d13-f52f-43e1-a054-e0733cc5ec1c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Note",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Note",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928073199,
        "id": "fec83828-9107-4798-a084-b9baeff2c773",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928073199,
        "parent_id": "19222d13-f52f-43e1-a054-e0733cc5ec1c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Path compression may reduce the height of the tree, hence comparing heights of the trees during union operation might not be a trivial task. Hence to avoid the complexity of storing and calculating the height of the trees the resulting parent can be picked randomly:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Path compression may reduce the height of the tree, hence comparing heights of the trees during union operation might not be a trivial task. Hence to avoid the complexity of storing and calculating the height of the trees the resulting parent can be picked randomly:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928073199,
        "id": "4c5776e3-052a-4809-a637-0ebcb106c039",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928073199,
        "parent_id": "19222d13-f52f-43e1-a054-e0733cc5ec1c",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "subalgo unionSet(u, v: nodes):\n    vRoot = findSet(v)\n    uRoot = findSet(u)"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "subalgo unionSet(u, v: nodes):\n    vRoot = findSet(v)\n    uRoot = findSet(u)",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928073199,
        "id": "45ba4ddd-6903-4819-8325-338d75b73db2",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928073199,
        "parent_id": "19222d13-f52f-43e1-a054-e0733cc5ec1c",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "if vRoot == uRoot:\n    return\nif random() % 2 == 0:\n    vRoot.parent = uRoot\nelse:\n    uRoot.parent = vRoot"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "if vRoot == uRoot:\n    return\nif random() % 2 == 0:\n    vRoot.parent = uRoot\nelse:\n    uRoot.parent = vRoot",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928073200,
        "id": "6f9dcb5d-efb0-4ea7-b3e2-ad2414d72b6d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928073200,
        "parent_id": "19222d13-f52f-43e1-a054-e0733cc5ec1c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "In practice this randomised algorithm together with path compression for "
            ],
            [
              "findSet",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " operation will result in comparable performance, yet much simpler to implement."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "In practice this randomised algorithm together with path compression for "
          },
          {
            "Text": "findSet",
            "AttrFlags": 2
          },
          {
            "Text": " operation will result in comparable performance, yet much simpler to implement."
          }
        ]
      }
    ],
    "title": "Optimal disjoint-set based implementation",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}