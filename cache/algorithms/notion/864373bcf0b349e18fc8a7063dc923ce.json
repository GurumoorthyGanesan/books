{
  "ID": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
  "Root": {
    "alive": true,
    "content": [
      "6dfa6054-f285-4197-af1d-8e5d53166aaa",
      "a3b89965-dbbe-49a7-8108-fd92515c7f21",
      "bdc197f3-6527-4a4b-a299-20c13b3b29ad",
      "94e32789-a7dc-4598-a927-64ea3111c305",
      "8ea17b77-6607-41c7-9628-bf17fa926d0a",
      "4c074bf1-1378-4f0a-9bb2-fa5cf52e1a64",
      "05442c2c-d241-4e4e-b01b-a3acab85813a",
      "699a67ba-a5bc-4e4c-9442-33e847f906ed",
      "eca5c3b4-fef4-4081-b212-cd903482c678",
      "17e8ecce-5854-4636-9ce0-a7ef391f999a",
      "daef4c9b-e7fc-429b-9255-5ccb60360ca8",
      "71eb4604-0290-4f11-83b3-34190c616165",
      "9e978639-cfd1-4da2-a84d-b692a557fa64",
      "e6c9ce9f-9cf7-4860-91e3-30e68c6cbb8b",
      "6a695f0f-e061-4bbb-adab-740811a783d4",
      "dc3bbf47-eb2e-4f67-9e80-d2d42c355b48",
      "328e0c9f-271a-4ffc-9f8b-3c066e3ba051",
      "e655f15c-14ed-419d-be94-8486fa862e04",
      "873d1cdc-816c-46ee-88a0-1781270e540a",
      "cbe162f7-2cd8-4f36-a201-0321a18876bc",
      "a57c0ef3-7c5b-44d7-8164-94bbba4ac686",
      "f25e51e9-9d62-4f90-a738-02383f17cdf8",
      "f38dcca2-78c7-4359-8f75-83dc648f0ca0",
      "b2910daa-6a1b-467f-a9bd-7a30c27be411",
      "788d2507-bd7b-479c-9b2e-177ca9228333",
      "48ab51ea-4782-464d-8548-29a3dc5e09c6",
      "f4717f68-376f-4928-8c97-9b99e8ab45fe",
      "94b66dd2-3918-483f-b658-4d8cd5435df4",
      "7f3cec1e-ceb1-4881-8eee-f2e3d7fa3927",
      "bc519238-2463-4405-ac8d-f42ae55563b8",
      "00a5045c-989b-492e-9824-853031787ef9",
      "5e47e579-d8c9-4b07-8082-741402bdc17a",
      "4ab536cc-76fb-4b06-8624-1981b50107a2"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1551929189108,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1551929189108,
    "parent_id": "547abd24-965c-44ce-b5f0-e452aeea3821",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Longest Common Subsequence Explanation"
        ]
      ]
    },
    "type": "page",
    "version": 3,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189099,
        "id": "6dfa6054-f285-4197-af1d-8e5d53166aaa",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189099,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "One of the most important implementations of Dynamic Programming is finding out the "
            ],
            [
              "Longest Common Subsequence",
              [
                [
                  "a",
                  "https://en.wikipedia.org/wiki/Longest_common_subsequence_problem"
                ]
              ]
            ],
            [
              ". Let’s define some of the basic terminologies first."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "One of the most important implementations of Dynamic Programming is finding out the "
          },
          {
            "Text": "Longest Common Subsequence",
            "Link": "https://en.wikipedia.org/wiki/Longest_common_subsequence_problem"
          },
          {
            "Text": ". Let’s define some of the basic terminologies first."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189100,
        "id": "a3b89965-dbbe-49a7-8108-fd92515c7f21",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189100,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Subsequence:",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Subsequence:",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189101,
        "id": "bdc197f3-6527-4a4b-a299-20c13b3b29ad",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189101,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. Let’s say we have a string "
            ],
            [
              "ABC",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". If we erase zero or one or more than one character from this string we get the subsequence of this string. So the subsequences of string "
            ],
            [
              "ABC",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " will be {"
            ],
            [
              "“A”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "“B”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "“C”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "“AB”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "“AC”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "“BC”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "“ABC”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "” “",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              "}. Even if we remove all the characters, the empty string will also be a subsequence. To find out the subsequence, for each characters in a string, we have two options - either we take the character, or we don’t. So if the length of the string is "
            ],
            [
              "n",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", there are "
            ],
            [
              "2n",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " subsequences of that string."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. Let’s say we have a string "
          },
          {
            "Text": "ABC",
            "AttrFlags": 1
          },
          {
            "Text": ". If we erase zero or one or more than one character from this string we get the subsequence of this string. So the subsequences of string "
          },
          {
            "Text": "ABC",
            "AttrFlags": 1
          },
          {
            "Text": " will be {"
          },
          {
            "Text": "“A”",
            "AttrFlags": 1
          },
          {
            "Text": ", "
          },
          {
            "Text": "“B”",
            "AttrFlags": 1
          },
          {
            "Text": ", "
          },
          {
            "Text": "“C”",
            "AttrFlags": 1
          },
          {
            "Text": ", "
          },
          {
            "Text": "“AB”",
            "AttrFlags": 1
          },
          {
            "Text": ", "
          },
          {
            "Text": "“AC”",
            "AttrFlags": 1
          },
          {
            "Text": ", "
          },
          {
            "Text": "“BC”",
            "AttrFlags": 1
          },
          {
            "Text": ", "
          },
          {
            "Text": "“ABC”",
            "AttrFlags": 1
          },
          {
            "Text": ", "
          },
          {
            "Text": "” “",
            "AttrFlags": 1
          },
          {
            "Text": "}. Even if we remove all the characters, the empty string will also be a subsequence. To find out the subsequence, for each characters in a string, we have two options - either we take the character, or we don’t. So if the length of the string is "
          },
          {
            "Text": "n",
            "AttrFlags": 1
          },
          {
            "Text": ", there are "
          },
          {
            "Text": "2n",
            "AttrFlags": 1
          },
          {
            "Text": " subsequences of that string."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189101,
        "id": "94e32789-a7dc-4598-a927-64ea3111c305",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189101,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Longest Common Subsequence:",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Longest Common Subsequence:",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189101,
        "id": "8ea17b77-6607-41c7-9628-bf17fa926d0a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189101,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "As the name suggest, of all the common subsequencesbetween two strings, the longest common subsequence(LCS) is the one with the maximum length. For example: The common subsequences between "
            ],
            [
              "“HELLOM”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "“HMLD”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " are "
            ],
            [
              "“H”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "“HL”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "“HM”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " etc. Here "
            ],
            [
              "“HLL”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " is the longest common subsequence which has length 3."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "As the name suggest, of all the common subsequencesbetween two strings, the longest common subsequence(LCS) is the one with the maximum length. For example: The common subsequences between "
          },
          {
            "Text": "“HELLOM”",
            "AttrFlags": 1
          },
          {
            "Text": " and "
          },
          {
            "Text": "“HMLD”",
            "AttrFlags": 1
          },
          {
            "Text": " are "
          },
          {
            "Text": "“H”",
            "AttrFlags": 1
          },
          {
            "Text": ", "
          },
          {
            "Text": "“HL”",
            "AttrFlags": 1
          },
          {
            "Text": ", "
          },
          {
            "Text": "“HM”",
            "AttrFlags": 1
          },
          {
            "Text": " etc. Here "
          },
          {
            "Text": "“HLL”",
            "AttrFlags": 1
          },
          {
            "Text": " is the longest common subsequence which has length 3."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189101,
        "id": "4c074bf1-1378-4f0a-9bb2-fa5cf52e1a64",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189101,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Brute-Force Method:",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Brute-Force Method:",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189102,
        "id": "05442c2c-d241-4e4e-b01b-a3acab85813a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189102,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "We can generate all the subsequences of two strings using "
            ],
            [
              "backtracking",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Then we can compare them to find out the common subsequences. After we’ll need to find out the one with the maximum length. We have already seen that, there are "
            ],
            [
              "2n",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " subsequences of a string of length "
            ],
            [
              "n",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". It would take years to solve the problem if our "
            ],
            [
              "n",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " crosses "
            ],
            [
              "20-25",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "We can generate all the subsequences of two strings using "
          },
          {
            "Text": "backtracking",
            "AttrFlags": 4
          },
          {
            "Text": ". Then we can compare them to find out the common subsequences. After we’ll need to find out the one with the maximum length. We have already seen that, there are "
          },
          {
            "Text": "2n",
            "AttrFlags": 1
          },
          {
            "Text": " subsequences of a string of length "
          },
          {
            "Text": "n",
            "AttrFlags": 1
          },
          {
            "Text": ". It would take years to solve the problem if our "
          },
          {
            "Text": "n",
            "AttrFlags": 1
          },
          {
            "Text": " crosses "
          },
          {
            "Text": "20-25",
            "AttrFlags": 1
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189102,
        "id": "699a67ba-a5bc-4e4c-9442-33e847f906ed",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189102,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Dynamic Programming Method:",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Dynamic Programming Method:",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189102,
        "id": "eca5c3b4-fef4-4081-b212-cd903482c678",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189102,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Let’s approach our method with an example. Assume that, we have two strings "
            ],
            [
              "abcdaf",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "acbcf",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". Let’s denote these with "
            ],
            [
              "s1",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "s2",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". So the longest common subsequence of these two strings will be "
            ],
            [
              "“abcf”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", which has length 4. Again I remind you, subsequences need not be continuous in the string. To construct "
            ],
            [
              "“abcf”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", we ignored "
            ],
            [
              "“da”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " in "
            ],
            [
              "s1",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "“c”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " in "
            ],
            [
              "s2",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". How do we find this out using Dynamic Programming?"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Let’s approach our method with an example. Assume that, we have two strings "
          },
          {
            "Text": "abcdaf",
            "AttrFlags": 1
          },
          {
            "Text": " and "
          },
          {
            "Text": "acbcf",
            "AttrFlags": 1
          },
          {
            "Text": ". Let’s denote these with "
          },
          {
            "Text": "s1",
            "AttrFlags": 1
          },
          {
            "Text": " and "
          },
          {
            "Text": "s2",
            "AttrFlags": 1
          },
          {
            "Text": ". So the longest common subsequence of these two strings will be "
          },
          {
            "Text": "“abcf”",
            "AttrFlags": 1
          },
          {
            "Text": ", which has length 4. Again I remind you, subsequences need not be continuous in the string. To construct "
          },
          {
            "Text": "“abcf”",
            "AttrFlags": 1
          },
          {
            "Text": ", we ignored "
          },
          {
            "Text": "“da”",
            "AttrFlags": 1
          },
          {
            "Text": " in "
          },
          {
            "Text": "s1",
            "AttrFlags": 1
          },
          {
            "Text": " and "
          },
          {
            "Text": "“c”",
            "AttrFlags": 1
          },
          {
            "Text": " in "
          },
          {
            "Text": "s2",
            "AttrFlags": 1
          },
          {
            "Text": ". How do we find this out using Dynamic Programming?"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189103,
        "id": "17e8ecce-5854-4636-9ce0-a7ef391f999a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189103,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "We’ll start with a table (a 2D array) having all the characters of "
            ],
            [
              "s1",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " in a row and all the characters of "
            ],
            [
              "s2",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " in column. Here the table is 0-indexed and we put the characters from 1 to onwards. We’ll traverse the table from left to right for each row. Our table will look like:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "We’ll start with a table (a 2D array) having all the characters of "
          },
          {
            "Text": "s1",
            "AttrFlags": 1
          },
          {
            "Text": " in a row and all the characters of "
          },
          {
            "Text": "s2",
            "AttrFlags": 1
          },
          {
            "Text": " in column. Here the table is 0-indexed and we put the characters from 1 to onwards. We’ll traverse the table from left to right for each row. Our table will look like:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189103,
        "id": "daef4c9b-e7fc-429b-9255-5ccb60360ca8",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189103,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "0     1     2     3     4     5     6\n+-----+-----+-----+-----+-----+-----+-----+-----+\n| chʳ |     |  a  |  b  |  c  |  d  |  a  |  f  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n0  |     |     |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n1  |  a  |     |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n2  |  c  |     |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n3  |  b  |     |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n4  |  c  |     |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n5  |  f  |     |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "0     1     2     3     4     5     6\n+-----+-----+-----+-----+-----+-----+-----+-----+\n| chʳ |     |  a  |  b  |  c  |  d  |  a  |  f  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n0  |     |     |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n1  |  a  |     |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n2  |  c  |     |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n3  |  b  |     |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n4  |  c  |     |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n5  |  f  |     |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189103,
        "id": "71eb4604-0290-4f11-83b3-34190c616165",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189103,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Here each row and column represent the length of the longest common subsequence between two strings if we take the characters of that row and column and add to the prefix before it. For example: "
            ],
            [
              "Table[2][3]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " represents the length of the longest common subsequence between "
            ],
            [
              "“ac”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "“abc”",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Here each row and column represent the length of the longest common subsequence between two strings if we take the characters of that row and column and add to the prefix before it. For example: "
          },
          {
            "Text": "Table[2][3]",
            "AttrFlags": 1
          },
          {
            "Text": " represents the length of the longest common subsequence between "
          },
          {
            "Text": "“ac”",
            "AttrFlags": 1
          },
          {
            "Text": " and "
          },
          {
            "Text": "“abc”",
            "AttrFlags": 1
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189103,
        "id": "9e978639-cfd1-4da2-a84d-b692a557fa64",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189103,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The 0-th column represents the empty subsequence of "
            ],
            [
              "s1",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". Similarly the 0-th row represents the empty subsequence of "
            ],
            [
              "s2",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". If we take an empty subsequence of a string and try to match it with another string, no matter how long the length of the second substring is, the common subsequence will have 0 length. So we can fill-up the 0-th rows and 0-th columns with 0’s. We get:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The 0-th column represents the empty subsequence of "
          },
          {
            "Text": "s1",
            "AttrFlags": 1
          },
          {
            "Text": ". Similarly the 0-th row represents the empty subsequence of "
          },
          {
            "Text": "s2",
            "AttrFlags": 1
          },
          {
            "Text": ". If we take an empty subsequence of a string and try to match it with another string, no matter how long the length of the second substring is, the common subsequence will have 0 length. So we can fill-up the 0-th rows and 0-th columns with 0’s. We get:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189103,
        "id": "e6c9ce9f-9cf7-4860-91e3-30e68c6cbb8b",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189103,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "0     1     2     3     4     5     6\n+-----+-----+-----+-----+-----+-----+-----+-----+\n| chʳ |     |  a  |  b  |  c  |  d  |  a  |  f  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n0  |     |  0  |  0  |  0  |  0  |  0  |  0  |  0  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n1  |  a  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n2  |  c  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n3  |  b  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n4  |  c  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n5  |  f  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "0     1     2     3     4     5     6\n+-----+-----+-----+-----+-----+-----+-----+-----+\n| chʳ |     |  a  |  b  |  c  |  d  |  a  |  f  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n0  |     |  0  |  0  |  0  |  0  |  0  |  0  |  0  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n1  |  a  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n2  |  c  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n3  |  b  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n4  |  c  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n5  |  f  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189104,
        "id": "6a695f0f-e061-4bbb-adab-740811a783d4",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189104,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Let’s begin. When we’re filling "
            ],
            [
              "Table[1][1]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", we’re asking ourselves, if we had a string "
            ],
            [
              "a",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and another string "
            ],
            [
              "a",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and nothing else, what will be the longest common subsequence here? The length of the LCS here will be 1. Now let’s look at "
            ],
            [
              "Table[1][2]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". We have string "
            ],
            [
              "ab",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and string "
            ],
            [
              "a",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". The length of the LCS will be 1. As you can see, the rest of the values will be also 1 for the first row as it considers only string "
            ],
            [
              "a",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " with "
            ],
            [
              "abcd",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "abcda",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "abcdaf",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". So our table will look like:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Let’s begin. When we’re filling "
          },
          {
            "Text": "Table[1][1]",
            "AttrFlags": 1
          },
          {
            "Text": ", we’re asking ourselves, if we had a string "
          },
          {
            "Text": "a",
            "AttrFlags": 1
          },
          {
            "Text": " and another string "
          },
          {
            "Text": "a",
            "AttrFlags": 1
          },
          {
            "Text": " and nothing else, what will be the longest common subsequence here? The length of the LCS here will be 1. Now let’s look at "
          },
          {
            "Text": "Table[1][2]",
            "AttrFlags": 1
          },
          {
            "Text": ". We have string "
          },
          {
            "Text": "ab",
            "AttrFlags": 1
          },
          {
            "Text": " and string "
          },
          {
            "Text": "a",
            "AttrFlags": 1
          },
          {
            "Text": ". The length of the LCS will be 1. As you can see, the rest of the values will be also 1 for the first row as it considers only string "
          },
          {
            "Text": "a",
            "AttrFlags": 1
          },
          {
            "Text": " with "
          },
          {
            "Text": "abcd",
            "AttrFlags": 1
          },
          {
            "Text": ", "
          },
          {
            "Text": "abcda",
            "AttrFlags": 1
          },
          {
            "Text": ", "
          },
          {
            "Text": "abcdaf",
            "AttrFlags": 1
          },
          {
            "Text": ". So our table will look like:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189104,
        "id": "dc3bbf47-eb2e-4f67-9e80-d2d42c355b48",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189104,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "0     1     2     3     4     5     6\n+-----+-----+-----+-----+-----+-----+-----+-----+\n| chʳ |     |  a  |  b  |  c  |  d  |  a  |  f  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n0  |     |  0  |  0  |  0  |  0  |  0  |  0  |  0  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n1  |  a  |  0  |  1  |  1  |  1  |  1  |  1  |  1  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n2  |  c  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n3  |  b  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n4  |  c  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n5  |  f  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "0     1     2     3     4     5     6\n+-----+-----+-----+-----+-----+-----+-----+-----+\n| chʳ |     |  a  |  b  |  c  |  d  |  a  |  f  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n0  |     |  0  |  0  |  0  |  0  |  0  |  0  |  0  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n1  |  a  |  0  |  1  |  1  |  1  |  1  |  1  |  1  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n2  |  c  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n3  |  b  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n4  |  c  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n5  |  f  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189104,
        "id": "328e0c9f-271a-4ffc-9f8b-3c066e3ba051",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189104,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "For row 2, which will now include "
            ],
            [
              "c",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". For "
            ],
            [
              "Table[2][1]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " we have "
            ],
            [
              "ac",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " on one side and "
            ],
            [
              "a",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " on the other side. So the length of the LCS is 1. Where did we get this 1 from? From the top, which denotes the LCS "
            ],
            [
              "a",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " between two substrings. So what we are saying is, if "
            ],
            [
              "s1[2]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "s2[1]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " are not same, then the length of the LCS will be the maximum of the length of LCS at the "
            ],
            [
              "top",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", or at the "
            ],
            [
              "left",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". Taking the length of the LCS at the top denotes that, we don’t take the current character from "
            ],
            [
              "s2",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". Similarly, Taking the length of the LCS at the left denotes that, we don’t take the current character from "
            ],
            [
              "s1",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " to create the LCS. We get:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "For row 2, which will now include "
          },
          {
            "Text": "c",
            "AttrFlags": 1
          },
          {
            "Text": ". For "
          },
          {
            "Text": "Table[2][1]",
            "AttrFlags": 1
          },
          {
            "Text": " we have "
          },
          {
            "Text": "ac",
            "AttrFlags": 1
          },
          {
            "Text": " on one side and "
          },
          {
            "Text": "a",
            "AttrFlags": 1
          },
          {
            "Text": " on the other side. So the length of the LCS is 1. Where did we get this 1 from? From the top, which denotes the LCS "
          },
          {
            "Text": "a",
            "AttrFlags": 1
          },
          {
            "Text": " between two substrings. So what we are saying is, if "
          },
          {
            "Text": "s1[2]",
            "AttrFlags": 1
          },
          {
            "Text": " and "
          },
          {
            "Text": "s2[1]",
            "AttrFlags": 1
          },
          {
            "Text": " are not same, then the length of the LCS will be the maximum of the length of LCS at the "
          },
          {
            "Text": "top",
            "AttrFlags": 1
          },
          {
            "Text": ", or at the "
          },
          {
            "Text": "left",
            "AttrFlags": 1
          },
          {
            "Text": ". Taking the length of the LCS at the top denotes that, we don’t take the current character from "
          },
          {
            "Text": "s2",
            "AttrFlags": 1
          },
          {
            "Text": ". Similarly, Taking the length of the LCS at the left denotes that, we don’t take the current character from "
          },
          {
            "Text": "s1",
            "AttrFlags": 1
          },
          {
            "Text": " to create the LCS. We get:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189105,
        "id": "e655f15c-14ed-419d-be94-8486fa862e04",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189105,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "0     1     2     3     4     5     6\n+-----+-----+-----+-----+-----+-----+-----+-----+\n| chʳ |     |  a  |  b  |  c  |  d  |  a  |  f  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n0  |     |  0  |  0  |  0  |  0  |  0  |  0  |  0  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n1  |  a  |  0  |  1  |  1  |  1  |  1  |  1  |  1  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n2  |  c  |  0  |  1  |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n3  |  b  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n4  |  c  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n5  |  f  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "0     1     2     3     4     5     6\n+-----+-----+-----+-----+-----+-----+-----+-----+\n| chʳ |     |  a  |  b  |  c  |  d  |  a  |  f  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n0  |     |  0  |  0  |  0  |  0  |  0  |  0  |  0  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n1  |  a  |  0  |  1  |  1  |  1  |  1  |  1  |  1  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n2  |  c  |  0  |  1  |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n3  |  b  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n4  |  c  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n5  |  f  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189105,
        "id": "873d1cdc-816c-46ee-88a0-1781270e540a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189105,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "So our first formula will be:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "So our first formula will be:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189105,
        "id": "cbe162f7-2cd8-4f36-a201-0321a18876bc",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189105,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "if s2[i] is not equal to s1[j]\n    Table[i][j] = max(Table[i-1][j], Table[i][j-1]\nendif"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "if s2[i] is not equal to s1[j]\n    Table[i][j] = max(Table[i-1][j], Table[i][j-1]\nendif",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189105,
        "id": "a57c0ef3-7c5b-44d7-8164-94bbba4ac686",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189105,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Moving on, for "
            ],
            [
              "Table[2][2]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " we have string "
            ],
            [
              "ab",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "ac",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". Since "
            ],
            [
              "c",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "b",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " are not same, we put the maximum of the top or left here. In this case, it’s again 1. After that, for "
            ],
            [
              "Table[2][3]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " we have string "
            ],
            [
              "abc",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "ac",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". This time current values of both row and column are same. Now the length of the LCS will be equal to the maximum length of LCS so far + 1. How do we get the maximum length of LCS so far? We check the diagonal value, which represents the best match between "
            ],
            [
              "ab",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "a",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". From this state, for the current values, we added one more character to "
            ],
            [
              "s1",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "s2",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " which happened to be the same. So the length of LCS will of course increase. We’ll put "
            ],
            [
              "1 + 1 = 2",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " in "
            ],
            [
              "Table[2][3]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". We get,"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Moving on, for "
          },
          {
            "Text": "Table[2][2]",
            "AttrFlags": 1
          },
          {
            "Text": " we have string "
          },
          {
            "Text": "ab",
            "AttrFlags": 1
          },
          {
            "Text": " and "
          },
          {
            "Text": "ac",
            "AttrFlags": 1
          },
          {
            "Text": ". Since "
          },
          {
            "Text": "c",
            "AttrFlags": 1
          },
          {
            "Text": " and "
          },
          {
            "Text": "b",
            "AttrFlags": 1
          },
          {
            "Text": " are not same, we put the maximum of the top or left here. In this case, it’s again 1. After that, for "
          },
          {
            "Text": "Table[2][3]",
            "AttrFlags": 1
          },
          {
            "Text": " we have string "
          },
          {
            "Text": "abc",
            "AttrFlags": 1
          },
          {
            "Text": " and "
          },
          {
            "Text": "ac",
            "AttrFlags": 1
          },
          {
            "Text": ". This time current values of both row and column are same. Now the length of the LCS will be equal to the maximum length of LCS so far + 1. How do we get the maximum length of LCS so far? We check the diagonal value, which represents the best match between "
          },
          {
            "Text": "ab",
            "AttrFlags": 1
          },
          {
            "Text": " and "
          },
          {
            "Text": "a",
            "AttrFlags": 1
          },
          {
            "Text": ". From this state, for the current values, we added one more character to "
          },
          {
            "Text": "s1",
            "AttrFlags": 1
          },
          {
            "Text": " and "
          },
          {
            "Text": "s2",
            "AttrFlags": 1
          },
          {
            "Text": " which happened to be the same. So the length of LCS will of course increase. We’ll put "
          },
          {
            "Text": "1 + 1 = 2",
            "AttrFlags": 1
          },
          {
            "Text": " in "
          },
          {
            "Text": "Table[2][3]",
            "AttrFlags": 1
          },
          {
            "Text": ". We get,"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189106,
        "id": "f25e51e9-9d62-4f90-a738-02383f17cdf8",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189106,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "0     1     2     3     4     5     6\n+-----+-----+-----+-----+-----+-----+-----+-----+\n| chʳ |     |  a  |  b  |  c  |  d  |  a  |  f  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n0  |     |  0  |  0  |  0  |  0  |  0  |  0  |  0  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n1  |  a  |  0  |  1  |  1  |  1  |  1  |  1  |  1  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n2  |  c  |  0  |  1  |  1  |  2  |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n3  |  b  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n4  |  c  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n5  |  f  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "0     1     2     3     4     5     6\n+-----+-----+-----+-----+-----+-----+-----+-----+\n| chʳ |     |  a  |  b  |  c  |  d  |  a  |  f  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n0  |     |  0  |  0  |  0  |  0  |  0  |  0  |  0  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n1  |  a  |  0  |  1  |  1  |  1  |  1  |  1  |  1  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n2  |  c  |  0  |  1  |  1  |  2  |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n3  |  b  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n4  |  c  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n5  |  f  |  0  |     |     |     |     |     |     |\n+-----+-----+-----+-----+-----+-----+-----+-----+",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189106,
        "id": "f38dcca2-78c7-4359-8f75-83dc648f0ca0",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189106,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "So our second formula will be:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "So our second formula will be:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189106,
        "id": "b2910daa-6a1b-467f-a9bd-7a30c27be411",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189106,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "if s2[i] equals to s1[j]\n    Table[i][j] = Table[i-1][j-1] + 1\nendif"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "if s2[i] equals to s1[j]\n    Table[i][j] = Table[i-1][j-1] + 1\nendif",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189106,
        "id": "788d2507-bd7b-479c-9b2e-177ca9228333",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189106,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "We have defined both the cases. Using these two formulas, we can populate the whole table. After filling up the table, it will look like this:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "We have defined both the cases. Using these two formulas, we can populate the whole table. After filling up the table, it will look like this:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189106,
        "id": "48ab51ea-4782-464d-8548-29a3dc5e09c6",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189106,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "0     1     2     3     4     5     6\n+-----+-----+-----+-----+-----+-----+-----+-----+\n| chʳ |     |  a  |  b  |  c  |  d  |  a  |  f  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n0  |     |  0  |  0  |  0  |  0  |  0  |  0  |  0  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n1  |  a  |  0  |  1  |  1  |  1  |  1  |  1  |  1  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n2  |  c  |  0  |  1  |  1  |  2  |  2  |  2  |  2  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n3  |  b  |  0  |  1  |  2  |  2  |  2  |  2  |  2  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n4  |  c  |  0  |  1  |  2  |  3  |  3  |  3  |  3  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n5  |  f  |  0  |  1  |  2  |  3  |  3  |  3  |  4  |\n+-----+-----+-----+-----+-----+-----+-----+-----+"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "0     1     2     3     4     5     6\n+-----+-----+-----+-----+-----+-----+-----+-----+\n| chʳ |     |  a  |  b  |  c  |  d  |  a  |  f  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n0  |     |  0  |  0  |  0  |  0  |  0  |  0  |  0  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n1  |  a  |  0  |  1  |  1  |  1  |  1  |  1  |  1  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n2  |  c  |  0  |  1  |  1  |  2  |  2  |  2  |  2  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n3  |  b  |  0  |  1  |  2  |  2  |  2  |  2  |  2  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n4  |  c  |  0  |  1  |  2  |  3  |  3  |  3  |  3  |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n5  |  f  |  0  |  1  |  2  |  3  |  3  |  3  |  4  |\n+-----+-----+-----+-----+-----+-----+-----+-----+",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189106,
        "id": "f4717f68-376f-4928-8c97-9b99e8ab45fe",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189106,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The length of the LCS between "
            ],
            [
              "s1",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "s2",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " will be "
            ],
            [
              "Table[5][6] = 4",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". Here, 5 and 6 are the length of "
            ],
            [
              "s2",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "s1",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " respectively. Our pseudo-code will be:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The length of the LCS between "
          },
          {
            "Text": "s1",
            "AttrFlags": 1
          },
          {
            "Text": " and "
          },
          {
            "Text": "s2",
            "AttrFlags": 1
          },
          {
            "Text": " will be "
          },
          {
            "Text": "Table[5][6] = 4",
            "AttrFlags": 1
          },
          {
            "Text": ". Here, 5 and 6 are the length of "
          },
          {
            "Text": "s2",
            "AttrFlags": 1
          },
          {
            "Text": " and "
          },
          {
            "Text": "s1",
            "AttrFlags": 1
          },
          {
            "Text": " respectively. Our pseudo-code will be:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189106,
        "id": "94b66dd2-3918-483f-b658-4d8cd5435df4",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189106,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "Procedure LCSlength(s1, s2):\nTable[0][0] = 0\nfor i from 1 to s1.length\n    Table[0][i] = 0\nendfor\nfor i from 1 to s2.length\n    Table[i][0] = 0\nendfor\nfor i from 1 to s2.length\n    for j from 1 to s1.length\n        if s2[i] equals to s1[j]\n            Table[i][j] = Table[i-1][j-1] + 1\n        else\n            Table[i][j] = max(Table[i-1][j], Table[i][j-1])\n        endif\n    endfor\nendfor\nReturn Table[s2.length][s1.length]"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "Procedure LCSlength(s1, s2):\nTable[0][0] = 0\nfor i from 1 to s1.length\n    Table[0][i] = 0\nendfor\nfor i from 1 to s2.length\n    Table[i][0] = 0\nendfor\nfor i from 1 to s2.length\n    for j from 1 to s1.length\n        if s2[i] equals to s1[j]\n            Table[i][j] = Table[i-1][j-1] + 1\n        else\n            Table[i][j] = max(Table[i-1][j], Table[i][j-1])\n        endif\n    endfor\nendfor\nReturn Table[s2.length][s1.length]",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189107,
        "id": "7f3cec1e-ceb1-4881-8eee-f2e3d7fa3927",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189107,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The time complexity for this algorithm is: "
            ],
            [
              "O(mn)",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " where "
            ],
            [
              "m",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "n",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " denotes the length of each strings."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The time complexity for this algorithm is: "
          },
          {
            "Text": "O(mn)",
            "AttrFlags": 1
          },
          {
            "Text": " where "
          },
          {
            "Text": "m",
            "AttrFlags": 1
          },
          {
            "Text": " and "
          },
          {
            "Text": "n",
            "AttrFlags": 1
          },
          {
            "Text": " denotes the length of each strings."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189107,
        "id": "bc519238-2463-4405-ac8d-f42ae55563b8",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189107,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "How do we find out the longest common subsequence? We’ll start from the bottom-right corner. We will check from where the value is coming. If the value is coming from the diagonal, that is if "
            ],
            [
              "Table[i-1][j-1]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " is equal to "
            ],
            [
              "Table[i][j] - 1",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", we push either "
            ],
            [
              "s2[i]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " or "
            ],
            [
              "s1[j]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " (both are the same) and move diagonally. If the value is coming from top, that means, if "
            ],
            [
              "Table[i-1][j]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " is equal to "
            ],
            [
              "Table[i][j]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", we move to the top. If the value is coming from left, that means, if "
            ],
            [
              "Table[i][j-1]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " is equal to "
            ],
            [
              "Table[i][j]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", we move to the left. When we reach the leftmost or topmost column, our search ends. Then we pop the values from the stack and print them. The pseudo-code:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "How do we find out the longest common subsequence? We’ll start from the bottom-right corner. We will check from where the value is coming. If the value is coming from the diagonal, that is if "
          },
          {
            "Text": "Table[i-1][j-1]",
            "AttrFlags": 1
          },
          {
            "Text": " is equal to "
          },
          {
            "Text": "Table[i][j] - 1",
            "AttrFlags": 1
          },
          {
            "Text": ", we push either "
          },
          {
            "Text": "s2[i]",
            "AttrFlags": 1
          },
          {
            "Text": " or "
          },
          {
            "Text": "s1[j]",
            "AttrFlags": 1
          },
          {
            "Text": " (both are the same) and move diagonally. If the value is coming from top, that means, if "
          },
          {
            "Text": "Table[i-1][j]",
            "AttrFlags": 1
          },
          {
            "Text": " is equal to "
          },
          {
            "Text": "Table[i][j]",
            "AttrFlags": 1
          },
          {
            "Text": ", we move to the top. If the value is coming from left, that means, if "
          },
          {
            "Text": "Table[i][j-1]",
            "AttrFlags": 1
          },
          {
            "Text": " is equal to "
          },
          {
            "Text": "Table[i][j]",
            "AttrFlags": 1
          },
          {
            "Text": ", we move to the left. When we reach the leftmost or topmost column, our search ends. Then we pop the values from the stack and print them. The pseudo-code:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189107,
        "id": "00a5045c-989b-492e-9824-853031787ef9",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189107,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "Procedure PrintLCS(LCSlength, s1, s2)\ntemp := LCSlength\nS = stack()\ni := s2.length\nj := s1.length\nwhile i is not equal to 0 and j is not equal to 0\n     if Table[i-1][j-1] == Table[i][j] - 1 and s1[j]==s2[i]\n        S.push(s1[j])   //or S.push(s2[i])\n        i := i - 1\n        j := j - 1\n    else if Table[i-1][j] == Table[i][j]\n        i := i-1\n    else\n        j := j-1\n    endif\nendwhile\nwhile S is not empty\n    print(S.pop)\nendwhile"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "Procedure PrintLCS(LCSlength, s1, s2)\ntemp := LCSlength\nS = stack()\ni := s2.length\nj := s1.length\nwhile i is not equal to 0 and j is not equal to 0\n     if Table[i-1][j-1] == Table[i][j] - 1 and s1[j]==s2[i]\n        S.push(s1[j])   //or S.push(s2[i])\n        i := i - 1\n        j := j - 1\n    else if Table[i-1][j] == Table[i][j]\n        i := i-1\n    else\n        j := j-1\n    endif\nendwhile\nwhile S is not empty\n    print(S.pop)\nendwhile",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189108,
        "id": "5e47e579-d8c9-4b07-8082-741402bdc17a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189108,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Point to be noted: if both "
            ],
            [
              "Table[i-1][j]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "Table[i][j-1]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " is equal to "
            ],
            [
              "Table[i][j]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "Table[i-1][j-1]",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " is not equal to "
            ],
            [
              "Table[i][j] - 1",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", there can be two LCS for that moment. This pseudo-code doesn’t consider this situation. You’ll have to solve this recursively to find multiple LCSs."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Point to be noted: if both "
          },
          {
            "Text": "Table[i-1][j]",
            "AttrFlags": 1
          },
          {
            "Text": " and "
          },
          {
            "Text": "Table[i][j-1]",
            "AttrFlags": 1
          },
          {
            "Text": " is equal to "
          },
          {
            "Text": "Table[i][j]",
            "AttrFlags": 1
          },
          {
            "Text": " and "
          },
          {
            "Text": "Table[i-1][j-1]",
            "AttrFlags": 1
          },
          {
            "Text": " is not equal to "
          },
          {
            "Text": "Table[i][j] - 1",
            "AttrFlags": 1
          },
          {
            "Text": ", there can be two LCS for that moment. This pseudo-code doesn’t consider this situation. You’ll have to solve this recursively to find multiple LCSs."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551929189108,
        "id": "4ab536cc-76fb-4b06-8624-1981b50107a2",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551929189108,
        "parent_id": "864373bc-f0b3-49e1-8fc8-a7063dc923ce",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The time complexity for this algorithm is: "
            ],
            [
              "O(max(m, n))",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The time complexity for this algorithm is: "
          },
          {
            "Text": "O(max(m, n))",
            "AttrFlags": 1
          },
          {
            "Text": "."
          }
        ]
      }
    ],
    "title": "Longest Common Subsequence Explanation",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}