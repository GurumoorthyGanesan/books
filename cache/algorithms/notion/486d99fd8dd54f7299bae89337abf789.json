{
  "ID": "486d99fd-8dd5-4f72-99ba-e89337abf789",
  "Root": {
    "alive": true,
    "content": [
      "9bba095c-e815-4d12-b235-4c17b0bbdf3e",
      "da92560d-eb32-4fff-8f6c-0b95b0973b7e",
      "9e129c81-bd86-4314-8aeb-9b5e4c7e63da",
      "31f09ab4-4f75-455c-9881-1abac898f5df",
      "46f0ea2d-ce41-4078-9a49-90d09a760c4e",
      "f5278c45-798f-49d1-940b-2b88be390247",
      "e2b689c3-61ad-4f0e-84ec-bba55c00d48c",
      "e7a4ba4c-e00b-47ff-b9b3-d8071088b734",
      "47b6f708-c4ee-4ce8-97c0-8dd8909260a0"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1551928034613,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "486d99fd-8dd5-4f72-99ba-e89337abf789",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1551928034613,
    "parent_id": "8ae5c9b5-b80d-4e27-930b-0dbbf5b2a075",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Thorups algorithm"
        ]
      ]
    },
    "type": "page",
    "version": 3,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928034611,
        "id": "9bba095c-e815-4d12-b235-4c17b0bbdf3e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928034611,
        "parent_id": "486d99fd-8dd5-4f72-99ba-e89337abf789",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Thorup’s algorithm for single source shortest path for undirected graph has the time complexity O(m), lower than Dijkstra."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Thorup’s algorithm for single source shortest path for undirected graph has the time complexity O(m), lower than Dijkstra."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928034612,
        "id": "da92560d-eb32-4fff-8f6c-0b95b0973b7e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928034612,
        "parent_id": "486d99fd-8dd5-4f72-99ba-e89337abf789",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Basic ideas are the following. (Sorry, I didn’t try implementing it yet, so I might miss some minor details. And the original paper is paywalled so I tried to reconstruct it from other sources referencing it. Please remove this comment if you could verify.)"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Basic ideas are the following. (Sorry, I didn’t try implementing it yet, so I might miss some minor details. And the original paper is paywalled so I tried to reconstruct it from other sources referencing it. Please remove this comment if you could verify.)"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928034612,
        "id": "9e129c81-bd86-4314-8aeb-9b5e4c7e63da",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928034612,
        "parent_id": "486d99fd-8dd5-4f72-99ba-e89337abf789",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "There are ways to find the spanning tree in O(m) (not described here). You need to “grow” the spanning tree from the shortest edge to the longest, and it would be a forest with several connected components before fully grown."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "There are ways to find the spanning tree in O(m) (not described here). You need to “grow” the spanning tree from the shortest edge to the longest, and it would be a forest with several connected components before fully grown."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928034612,
        "id": "31f09ab4-4f75-455c-9881-1abac898f5df",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928034612,
        "parent_id": "486d99fd-8dd5-4f72-99ba-e89337abf789",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Select an integer b (b\u003e=2) and only consider the spanning forests with length limit b^k. Merge the components which are exactly the same but with different k, and call the minimum k the level of the component. Then logically make components into a tree. u is the parent of v iff u is the smallest component distinct from v that fully contains v. The root is the whole graph and the leaves are single vertices in the original graph (with the level of negative infinity). The tree still has only O(n) nodes."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Select an integer b (b\u003e=2) and only consider the spanning forests with length limit b^k. Merge the components which are exactly the same but with different k, and call the minimum k the level of the component. Then logically make components into a tree. u is the parent of v iff u is the smallest component distinct from v that fully contains v. The root is the whole graph and the leaves are single vertices in the original graph (with the level of negative infinity). The tree still has only O(n) nodes."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928034613,
        "id": "46f0ea2d-ce41-4078-9a49-90d09a760c4e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928034613,
        "parent_id": "486d99fd-8dd5-4f72-99ba-e89337abf789",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Maintain the distance of each component to the source (like in Dijkstra’s algorithm). The distance of a component with more than one vertices is the minimum distance of its unexpanded children. Set the distance of the source vertex to 0 and update the ancestors accordingly."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Maintain the distance of each component to the source (like in Dijkstra’s algorithm). The distance of a component with more than one vertices is the minimum distance of its unexpanded children. Set the distance of the source vertex to 0 and update the ancestors accordingly."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928034613,
        "id": "f5278c45-798f-49d1-940b-2b88be390247",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928034613,
        "parent_id": "486d99fd-8dd5-4f72-99ba-e89337abf789",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Consider the distances in base b. When visiting a node in level k the first time, put its children into buckets shared by all nodes of level k (as in bucket sort, replacing the heap in Dijkstra’s algorithm) by the digit k and higher of its distance. Each time visiting a node, consider only its first b buckets, visit and remove each of them, update the distance of the current node, and relink the current node to its own parent using the new distance and wait for the next visit for the following buckets."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Consider the distances in base b. When visiting a node in level k the first time, put its children into buckets shared by all nodes of level k (as in bucket sort, replacing the heap in Dijkstra’s algorithm) by the digit k and higher of its distance. Each time visiting a node, consider only its first b buckets, visit and remove each of them, update the distance of the current node, and relink the current node to its own parent using the new distance and wait for the next visit for the following buckets."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928034613,
        "id": "e2b689c3-61ad-4f0e-84ec-bba55c00d48c",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928034613,
        "parent_id": "486d99fd-8dd5-4f72-99ba-e89337abf789",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "When a leaf is visited, the current distance is the final distance of the vertex. Expand all edges from it in the original graph and update the distances accordingly."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "When a leaf is visited, the current distance is the final distance of the vertex. Expand all edges from it in the original graph and update the distances accordingly."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928034613,
        "id": "e7a4ba4c-e00b-47ff-b9b3-d8071088b734",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928034613,
        "parent_id": "486d99fd-8dd5-4f72-99ba-e89337abf789",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Visit the root node (whole graph) repeatedly until the destination is reached."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Visit the root node (whole graph) repeatedly until the destination is reached."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551928034613,
        "id": "47b6f708-c4ee-4ce8-97c0-8dd8909260a0",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551928034613,
        "parent_id": "486d99fd-8dd5-4f72-99ba-e89337abf789",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "It is based on the fact that, there isn’t an edge with length less than l between two connected components of the spanning forest with length limitation l, so, starting at distance x, you could focus only on one connected component until you reach the distance x + l. You’ll visit some vertices before vertices with shorter distance are all visited, but that doesn’t matter because it is known there won’t be a shorter path to here from those vertices. Other parts work like the bucket sort / MSD radix sort, and of course, it requires the O(m) spanning tree."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "It is based on the fact that, there isn’t an edge with length less than l between two connected components of the spanning forest with length limitation l, so, starting at distance x, you could focus only on one connected component until you reach the distance x + l. You’ll visit some vertices before vertices with shorter distance are all visited, but that doesn’t matter because it is known there won’t be a shorter path to here from those vertices. Other parts work like the bucket sort / MSD radix sort, and of course, it requires the O(m) spanning tree."
          }
        ]
      }
    ],
    "title": "Thorups algorithm",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}