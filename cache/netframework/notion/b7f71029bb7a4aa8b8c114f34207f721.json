{
  "ID": "b7f71029-bb7a-4aa8-b8c1-14f34207f721",
  "Root": {
    "alive": true,
    "content": [
      "8b2fe098-fa7c-43da-a3e8-d2401a5d3582",
      "55222d2b-c234-43e3-aa52-c2dcc16ccf46",
      "ed9275fe-e975-46b6-a104-a7df917d9658",
      "304f1251-4435-4fa8-9d10-7b6fb51fc3ea",
      "1abbc053-db45-43f8-aaf0-fa934b311b25",
      "a5129a3b-c207-499b-9fbd-7ab9363b116a",
      "79215f16-297a-471e-a01e-1a2758558557",
      "c3952c5c-c599-4a1b-9674-96d2066d1676"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1551950755423,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "b7f71029-bb7a-4aa8-b8c1-14f34207f721",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1551950755423,
    "parent_id": "e22cb3bc-f3f4-4401-9c36-3c8a0904b3ad",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "ConcurrentDictionary augmented with Lazy1 reduces duplicated computation"
        ]
      ]
    },
    "type": "page",
    "version": 3,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551950755419,
        "id": "8b2fe098-fa7c-43da-a3e8-d2401a5d3582",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551950755419,
        "parent_id": "b7f71029-bb7a-4aa8-b8c1-14f34207f721",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Problem"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Problem"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551950755422,
        "id": "55222d2b-c234-43e3-aa52-c2dcc16ccf46",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551950755422,
        "parent_id": "b7f71029-bb7a-4aa8-b8c1-14f34207f721",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "ConcurrentDictionary shines when it comes to instantly returning of existing keys from cache, mostly lock free, and contending on a granular level. But what if the object creation is really expensive, outweighing the cost of context switching, and some cache misses occur?"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "ConcurrentDictionary shines when it comes to instantly returning of existing keys from cache, mostly lock free, and contending on a granular level. But what if the object creation is really expensive, outweighing the cost of context switching, and some cache misses occur?"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551950755422,
        "id": "ed9275fe-e975-46b6-a104-a7df917d9658",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551950755422,
        "parent_id": "b7f71029-bb7a-4aa8-b8c1-14f34207f721",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "If the same key is requested from multiple threads, one of the objects resulting from colliding operations will be eventually added to the collection, and the others will be thrown away, wasting the CPU resource to create the object and memory resource to store the object temporarily. Other resources could be wasted as well. This is really bad."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "If the same key is requested from multiple threads, one of the objects resulting from colliding operations will be eventually added to the collection, and the others will be thrown away, wasting the CPU resource to create the object and memory resource to store the object temporarily. Other resources could be wasted as well. This is really bad."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551950755422,
        "id": "304f1251-4435-4fa8-9d10-7b6fb51fc3ea",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551950755422,
        "parent_id": "b7f71029-bb7a-4aa8-b8c1-14f34207f721",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Solution"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Solution"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551950755422,
        "id": "1abbc053-db45-43f8-aaf0-fa934b311b25",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551950755422,
        "parent_id": "b7f71029-bb7a-4aa8-b8c1-14f34207f721",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "We can combine "
            ],
            [
              "ConcurrentDictionary\u003cTKey, TValue\u003e",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " with "
            ],
            [
              "Lazy\u003cTValue\u003e",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ". The idea is that ConcurrentDictionary GetOrAdd method can only return the value which was actually added to the collection. The loosing Lazy objects could be wasted in this case too, but that’s not much problem, as the Lazy object itself is relatively unexpensive. The Value property of the losing Lazy is never requested, because we are smart to only request the Value property of the one actually added to the collection - the one returned from the GetOrAdd method:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "We can combine "
          },
          {
            "Text": "ConcurrentDictionary\u003cTKey, TValue\u003e",
            "AttrFlags": 2
          },
          {
            "Text": " with "
          },
          {
            "Text": "Lazy\u003cTValue\u003e",
            "AttrFlags": 2
          },
          {
            "Text": ". The idea is that ConcurrentDictionary GetOrAdd method can only return the value which was actually added to the collection. The loosing Lazy objects could be wasted in this case too, but that’s not much problem, as the Lazy object itself is relatively unexpensive. The Value property of the losing Lazy is never requested, because we are smart to only request the Value property of the one actually added to the collection - the one returned from the GetOrAdd method:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551950755422,
        "id": "a5129a3b-c207-499b-9fbd-7ab9363b116a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551950755422,
        "parent_id": "b7f71029-bb7a-4aa8-b8c1-14f34207f721",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "public static class ConcurrentDictionaryExtensions\n{\n    public static TValue GetOrCreateLazy\u003cTKey, TValue\u003e(\n        this ConcurrentDictionary\u003cTKey, Lazy\u003cTValue\u003e\u003e d,\n        TKey key,\n        Func\u003cTKey, TValue\u003e factory)\n    {\n        return\n            d.GetOrAdd(\n                key,\n                key1 =\u003e\n                    new Lazy\u003cTValue\u003e(() =\u003e factory(key1),\n                    LazyThreadSafetyMode.ExecutionAndPublication)).Value;\n    }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "public static class ConcurrentDictionaryExtensions\n{\n    public static TValue GetOrCreateLazy\u003cTKey, TValue\u003e(\n        this ConcurrentDictionary\u003cTKey, Lazy\u003cTValue\u003e\u003e d,\n        TKey key,\n        Func\u003cTKey, TValue\u003e factory)\n    {\n        return\n            d.GetOrAdd(\n                key,\n                key1 =\u003e\n                    new Lazy\u003cTValue\u003e(() =\u003e factory(key1),\n                    LazyThreadSafetyMode.ExecutionAndPublication)).Value;\n    }\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551950755423,
        "id": "79215f16-297a-471e-a01e-1a2758558557",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551950755423,
        "parent_id": "b7f71029-bb7a-4aa8-b8c1-14f34207f721",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Caching of XmlSerializer objects can be particularly expensive, and there is a lot of contention at the application startup too. And there is more to this: if those are custom serializers, there will be a memory leak too for the rest of the process lifecycle. The only benefit of the ConcurrentDictionary in this case is that for the rest of the process lifecycle there will be no locks, but application startup and memory usage would be inacceptable. This is a job for our ConcurrentDictionary, augmented with Lazy:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Caching of XmlSerializer objects can be particularly expensive, and there is a lot of contention at the application startup too. And there is more to this: if those are custom serializers, there will be a memory leak too for the rest of the process lifecycle. The only benefit of the ConcurrentDictionary in this case is that for the rest of the process lifecycle there will be no locks, but application startup and memory usage would be inacceptable. This is a job for our ConcurrentDictionary, augmented with Lazy:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551950755423,
        "id": "c3952c5c-c599-4a1b-9674-96d2066d1676",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551950755423,
        "parent_id": "b7f71029-bb7a-4aa8-b8c1-14f34207f721",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "private ConcurrentDictionary\u003cType, Lazy\u003cXmlSerializer\u003e\u003e _serializers =\n    new ConcurrentDictionary\u003cType, Lazy\u003cXmlSerializer\u003e\u003e();\n\npublic XmlSerializer GetSerialier(Type t)\n{\n    return _serializers.GetOrCreateLazy(t, BuildSerializer);\n}\n\nprivate XmlSerializer BuildSerializer(Type t)\n{\n    throw new NotImplementedException(\"and this is a homework\");\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "private ConcurrentDictionary\u003cType, Lazy\u003cXmlSerializer\u003e\u003e _serializers =\n    new ConcurrentDictionary\u003cType, Lazy\u003cXmlSerializer\u003e\u003e();\n\npublic XmlSerializer GetSerialier(Type t)\n{\n    return _serializers.GetOrCreateLazy(t, BuildSerializer);\n}\n\nprivate XmlSerializer BuildSerializer(Type t)\n{\n    throw new NotImplementedException(\"and this is a homework\");\n}",
        "code_language": "Plain Text"
      }
    ],
    "title": "ConcurrentDictionary augmented with Lazy1 reduces duplicated computation",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}