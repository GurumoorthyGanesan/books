{
  "ID": "1b62d207-6906-4f99-8833-e8c0518444a9",
  "Root": {
    "alive": true,
    "content": [
      "7010e515-733d-4846-9ab3-896f668c17db",
      "79041bef-5792-4b6d-af61-375f659807de",
      "6ef666cb-d256-40f5-84dd-fa6216fbde8d",
      "d7a3c15b-a2af-438f-9ff2-a8d21942ed54",
      "035b431c-64c8-4c3e-b517-e5f1a8dd0e06",
      "e527c31a-c8ee-482c-92b1-b1d5d982f078",
      "680fed48-8ea1-43a3-83ad-7420c82549d8",
      "5b9d18c2-e09a-434d-b432-ac50736ec243",
      "0eacf841-24ff-4f79-86ef-1a8e4975a80e",
      "83fd8f14-c2f8-44b9-8554-5065540d302a",
      "92d7c77b-74fb-42e9-b21c-43113993ebc5",
      "35c4d7d4-bc4e-4c5e-9002-493a2a6a2f7c",
      "b4aabff6-dc15-4928-8292-68895e61f623"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1550452962140,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "1b62d207-6906-4f99-8833-e8c0518444a9",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1550452962140,
    "parent_id": "110fdb13-f9c4-46fc-9fa4-10ffd91c395f",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "How to use Android Fingerprint API to save user passwords"
        ]
      ]
    },
    "type": "page",
    "version": 3,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550452962137,
        "id": "7010e515-733d-4846-9ab3-896f668c17db",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550452962137,
        "parent_id": "1b62d207-6906-4f99-8833-e8c0518444a9",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "This example helper class interacts with the finger print manager and performs encryption and decryption of password. Please note that the method used for encryption in this example is AES. This is not the only way to encrypt and "
            ],
            [
              "other examples",
              [
                [
                  "a",
                  "http://stackoverflow.com/documentation/android/3471/data-encryption-decryption/11997/aes-encrypt-data-using-password-in-a-secure-way#t=20170404140944107178"
                ]
              ]
            ],
            [
              " exist. In this example the data is encrypted and decrypted in the following manner:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "This example helper class interacts with the finger print manager and performs encryption and decryption of password. Please note that the method used for encryption in this example is AES. This is not the only way to encrypt and "
          },
          {
            "Text": "other examples",
            "Link": "http://stackoverflow.com/documentation/android/3471/data-encryption-decryption/11997/aes-encrypt-data-using-password-in-a-secure-way#t=20170404140944107178"
          },
          {
            "Text": " exist. In this example the data is encrypted and decrypted in the following manner:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550452962137,
        "id": "79041bef-5792-4b6d-af61-375f659807de",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550452962137,
        "parent_id": "1b62d207-6906-4f99-8833-e8c0518444a9",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Encryption:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Encryption:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550452962138,
        "id": "6ef666cb-d256-40f5-84dd-fa6216fbde8d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550452962138,
        "parent_id": "1b62d207-6906-4f99-8833-e8c0518444a9",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "User gives helper the desired non-encrypted password."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "User gives helper the desired non-encrypted password."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550452962138,
        "id": "d7a3c15b-a2af-438f-9ff2-a8d21942ed54",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550452962138,
        "parent_id": "1b62d207-6906-4f99-8833-e8c0518444a9",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "User is required to provide fingerprint."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "User is required to provide fingerprint."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550452962138,
        "id": "035b431c-64c8-4c3e-b517-e5f1a8dd0e06",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550452962138,
        "parent_id": "1b62d207-6906-4f99-8833-e8c0518444a9",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Once authenticated, the helper obtains a key from the "
            ],
            [
              "KeyStore",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " and encrypts the password using a "
            ],
            [
              "Cipher",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Once authenticated, the helper obtains a key from the "
          },
          {
            "Text": "KeyStore",
            "AttrFlags": 2
          },
          {
            "Text": " and encrypts the password using a "
          },
          {
            "Text": "Cipher",
            "AttrFlags": 2
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550452962138,
        "id": "e527c31a-c8ee-482c-92b1-b1d5d982f078",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550452962138,
        "parent_id": "1b62d207-6906-4f99-8833-e8c0518444a9",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Password and IV salt (IV is recreated for every encryption and is not reused) are saved to shared preferences to be used later in the decryption process."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Password and IV salt (IV is recreated for every encryption and is not reused) are saved to shared preferences to be used later in the decryption process."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550452962138,
        "id": "680fed48-8ea1-43a3-83ad-7420c82549d8",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550452962138,
        "parent_id": "1b62d207-6906-4f99-8833-e8c0518444a9",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Decryption:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Decryption:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550452962139,
        "id": "5b9d18c2-e09a-434d-b432-ac50736ec243",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550452962139,
        "parent_id": "1b62d207-6906-4f99-8833-e8c0518444a9",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "User requests to decrypt the password."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "User requests to decrypt the password."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550452962139,
        "id": "0eacf841-24ff-4f79-86ef-1a8e4975a80e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550452962139,
        "parent_id": "1b62d207-6906-4f99-8833-e8c0518444a9",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "User is required to provide fingerprint."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "User is required to provide fingerprint."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550452962139,
        "id": "83fd8f14-c2f8-44b9-8554-5065540d302a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550452962139,
        "parent_id": "1b62d207-6906-4f99-8833-e8c0518444a9",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The helper builds a "
            ],
            [
              "Cipher",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " using the IV and once user is authenticated, the KeyStore obtains a key from the "
            ],
            [
              "KeyStore",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " and deciphers the password."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "The helper builds a "
          },
          {
            "Text": "Cipher",
            "AttrFlags": 2
          },
          {
            "Text": " using the IV and once user is authenticated, the KeyStore obtains a key from the "
          },
          {
            "Text": "KeyStore",
            "AttrFlags": 2
          },
          {
            "Text": " and deciphers the password."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550452962139,
        "id": "92d7c77b-74fb-42e9-b21c-43113993ebc5",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550452962139,
        "parent_id": "1b62d207-6906-4f99-8833-e8c0518444a9",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "public class FingerPrintAuthHelper {\n\n    private static final String FINGER_PRINT_HELPER = \"FingerPrintAuthHelper\";\n    private static final String ENCRYPTED_PASS_SHARED_PREF_KEY = \"ENCRYPTED_PASS_SHARED_PREF_KEY\";\n    private static final String LAST_USED_IV_SHARED_PREF_KEY = \"LAST_USED_IV_SHARED_PREF_KEY\";\n    private static final String MY_APP_ALIAS = \"MY_APP_ALIAS\";\n\n    private KeyguardManager keyguardManager;\n    private FingerprintManager fingerprintManager;\n\n    private final Context context;\n    private KeyStore keyStore;\n    private KeyGenerator keyGenerator;\n\n    private String lastError;\n\n\n    public interface Callback {\n        void onSuccess(String savedPass);\n\n        void onFailure(String message);\n\n        void onHelp(int helpCode, String helpString);\n    }\n\n    public FingerPrintAuthHelper(Context context) {\n        this.context = context;\n    }\n\n    public String getLastError() {\n        return lastError;\n    }\n\n    @TargetApi(Build.VERSION_CODES.M)\n    public boolean init() {\n        if (Build.VERSION.SDK_INT \u003c Build.VERSION_CODES.M) {\n            setError(\"This Android version does not support fingerprint authentication\");\n            return false;\n        }\n\n        keyguardManager = (KeyguardManager) context.getSystemService(KEYGUARD_SERVICE);\n        fingerprintManager = (FingerprintManager) context.getSystemService(FINGERPRINT_SERVICE);\n\n        if (!keyguardManager.isKeyguardSecure()) {\n            setError(\"User hasn't enabled Lock Screen\");\n            return false;\n        }\n\n        if (!hasPermission()) {\n            setError(\"User hasn't granted permission to use Fingerprint\");\n            return false;\n        }\n\n        if (!fingerprintManager.hasEnrolledFingerprints()) {\n            setError(\"User hasn't registered any fingerprints\");\n            return false;\n        }\n\n        if (!initKeyStore()) {\n            return false;\n        }\n        return false;\n    }\n\n    @Nullable\n    @RequiresApi(api = Build.VERSION_CODES.M)\n    private Cipher createCipher(int mode) throws NoSuchPaddingException, NoSuchAlgorithmException, UnrecoverableKeyException, KeyStoreException, InvalidKeyException, InvalidAlgorithmParameterException {\n        Cipher cipher = Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + \"/\" +\n                KeyProperties.BLOCK_MODE_CBC + \"/\" +\n                KeyProperties.ENCRYPTION_PADDING_PKCS7);\n\n        Key key = keyStore.getKey(MY_APP_ALIAS, null);\n        if (key == null) {\n            return null;\n        }\n        if(mode == Cipher.ENCRYPT_MODE) {\n            cipher.init(mode, key);\n            byte[] iv = cipher.getIV();\n            saveIv(iv);\n        } else {\n            byte[] lastIv = getLastIv();\n            cipher.init(mode, key, new IvParameterSpec(lastIv));\n        }\n        return cipher;\n    }\n\n    @NonNull\n    @RequiresApi(api = Build.VERSION_CODES.M)\n    private KeyGenParameterSpec createKeyGenParameterSpec() {\n        return new KeyGenParameterSpec.Builder(MY_APP_ALIAS, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n                        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n                        .setUserAuthenticationRequired(true)\n                        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n                        .build();\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.M)\n    private boolean initKeyStore() {\n        try {\n            keyStore = KeyStore.getInstance(\"AndroidKeyStore\");\n            keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n            keyStore.load(null);\n            if (getLastIv() == null) {\n                KeyGenParameterSpec keyGeneratorSpec = createKeyGenParameterSpec();\n                keyGenerator.init(keyGeneratorSpec);\n                keyGenerator.generateKey();\n            }\n        } catch (Throwable t) {\n            setError(\"Failed init of keyStore \u0026 keyGenerator: \" + t.getMessage());\n            return false;\n        }\n        return true;\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.M)\n    private void authenticate(CancellationSignal cancellationSignal, FingerPrintAuthenticationListener authListener, int mode) {\n        try {\n            if (hasPermission()) {\n                Cipher cipher = createCipher(mode);\n                FingerprintManager.CryptoObject crypto = new FingerprintManager.CryptoObject(cipher);\n                fingerprintManager.authenticate(crypto, cancellationSignal, 0, authListener, null);\n            } else {\n                authListener.getCallback().onFailure(\"User hasn't granted permission to use Fingerprint\");\n            }\n        } catch (Throwable t) {\n            authListener.getCallback().onFailure(\"An error occurred: \" + t.getMessage());\n        }\n    }\n\n    private String getSavedEncryptedPassword() {\n        SharedPreferences sharedPreferences = getSharedPreferences();\n        if (sharedPreferences != null) {\n            return sharedPreferences.getString(ENCRYPTED_PASS_SHARED_PREF_KEY, null);\n        }\n        return null;\n    }\n\n    private void saveEncryptedPassword(String encryptedPassword) {\n        SharedPreferences.Editor edit = getSharedPreferences().edit();\n        edit.putString(ENCRYPTED_PASS_SHARED_PREF_KEY, encryptedPassword);\n        edit.commit();\n    }\n\n    private byte[] getLastIv() {\n        SharedPreferences sharedPreferences = getSharedPreferences();\n        if (sharedPreferences != null) {\n            String ivString = sharedPreferences.getString(LAST_USED_IV_SHARED_PREF_KEY, null);\n\n            if (ivString != null) {\n                return decodeBytes(ivString);\n            }\n        }\n        return null;\n    }\n\n    private void saveIv(byte[] iv) {\n        SharedPreferences.Editor edit = getSharedPreferences().edit();\n        String string = encodeBytes(iv);\n        edit.putString(LAST_USED_IV_SHARED_PREF_KEY, string);\n        edit.commit();\n    }\n\n    private SharedPreferences getSharedPreferences() {\n        return context.getSharedPreferences(FINGER_PRINT_HELPER, 0);\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.M)\n    private boolean hasPermission() {\n        return ActivityCompat.checkSelfPermission(context, Manifest.permission.USE_FINGERPRINT) == PackageManager.PERMISSION_GRANTED;\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.M)\n    public void savePassword(@NonNull String password, CancellationSignal cancellationSignal, Callback callback) {\n        authenticate(cancellationSignal, new FingerPrintEncryptPasswordListener(callback, password), Cipher.ENCRYPT_MODE);\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.M)\n    public void getPassword(CancellationSignal cancellationSignal, Callback callback) {\n        authenticate(cancellationSignal, new FingerPrintDecryptPasswordListener(callback), Cipher.DECRYPT_MODE);\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.M)\n    public boolean encryptPassword(Cipher cipher, String password) {\n        try {\n            // Encrypt the text\n            if(password.isEmpty()) {\n                setError(\"Password is empty\");\n                return false;\n            }\n\n            if (cipher == null) {\n                setError(\"Could not create cipher\");\n                return false;\n            }\n\n            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n            CipherOutputStream cipherOutputStream = new CipherOutputStream(outputStream, cipher);\n            byte[] bytes = password.getBytes(Charset.defaultCharset());\n            cipherOutputStream.write(bytes);\n            cipherOutputStream.flush();\n            cipherOutputStream.close();\n            saveEncryptedPassword(encodeBytes(outputStream.toByteArray()));\n        } catch (Throwable t) {\n            setError(\"Encryption failed \" + t.getMessage());\n            return false;\n        }\n\n        return true;\n    }\n\n    private byte[] decodeBytes(String s) {\n        final int len = s.length();\n\n        // \"111\" is not a valid hex encoding.\n        if( len%2 != 0 )\n            throw new IllegalArgumentException(\"hexBinary needs to be even-length: \"+s);\n\n        byte[] out = new byte[len/2];\n\n        for( int i=0; i\u003clen; i+=2 ) {\n            int h = hexToBin(s.charAt(i  ));\n            int l = hexToBin(s.charAt(i+1));\n            if( h==-1 || l==-1 )\n                throw new IllegalArgumentException(\"contains illegal character for hexBinary: \"+s);\n\n            out[i/2] = (byte)(h*16+l);\n        }\n\n        return out;\n    }\n\n    private static int hexToBin( char ch ) {\n        if( '0'\u003c=ch \u0026\u0026 ch\u003c='9' )    return ch-'0';\n        if( 'A'\u003c=ch \u0026\u0026 ch\u003c='F' )    return ch-'A'+10;\n        if( 'a'\u003c=ch \u0026\u0026 ch\u003c='f' )    return ch-'a'+10;\n        return -1;\n    }\n\n    private static final char[] hexCode = \"0123456789ABCDEF\".toCharArray();\n\n    public String encodeBytes(byte[] data) {\n        StringBuilder r = new StringBuilder(data.length*2);\n        for ( byte b : data) {\n            r.append(hexCode[(b \u003e\u003e 4) \u0026 0xF]);\n            r.append(hexCode[(b \u0026 0xF)]);\n        }\n        return r.toString();\n    }\n\n    @NonNull\n    private String decipher(Cipher cipher) throws IOException, IllegalBlockSizeException, BadPaddingException {\n        String retVal = null;\n        String savedEncryptedPassword = getSavedEncryptedPassword();\n        if (savedEncryptedPassword != null) {\n            byte[] decodedPassword = decodeBytes(savedEncryptedPassword);\n            CipherInputStream cipherInputStream = new CipherInputStream(new ByteArrayInputStream(decodedPassword), cipher);\n\n            ArrayList\u003cByte\u003e values = new ArrayList\u003c\u003e();\n            int nextByte;\n            while ((nextByte = cipherInputStream.read()) != -1) {\n                values.add((byte) nextByte);\n            }\n            cipherInputStream.close();\n\n            byte[] bytes = new byte[values.size()];\n            for (int i = 0; i \u003c values.size(); i++) {\n                bytes[i] = values.get(i).byteValue();\n            }\n\n            retVal = new String(bytes, Charset.defaultCharset());\n        }\n        return retVal;\n    }\n\n    private void setError(String error) {\n        lastError = error;\n        Log.w(FINGER_PRINT_HELPER, lastError);\n    }\n\n    @RequiresApi(Build.VERSION_CODES.M)\n    protected class FingerPrintAuthenticationListener extends FingerprintManager.AuthenticationCallback {\n\n        protected final Callback callback;\n\n        public FingerPrintAuthenticationListener(@NonNull Callback callback) {\n            this.callback = callback;\n        }\n\n        public void onAuthenticationError(int errorCode, CharSequence errString) {\n            callback.onFailure(\"Authentication error [\" + errorCode + \"] \" + errString);\n        }\n\n        /**\n         * Called when a recoverable error has been encountered during authentication. The help\n         * string is provided to give the user guidance for what went wrong, such as\n         * \"Sensor dirty, please clean it.\"\n         * @param helpCode An integer identifying the error message\n         * @param helpString A human-readable string that can be shown in UI\n         */\n        public void onAuthenticationHelp(int helpCode, CharSequence helpString) {\n            callback.onHelp(helpCode, helpString.toString());\n        }\n\n        /**\n         * Called when a fingerprint is recognized.\n         * @param result An object containing authentication-related data\n         */\n        public void onAuthenticationSucceeded(FingerprintManager.AuthenticationResult result) {\n        }\n\n        /**\n         * Called when a fingerprint is valid but not recognized.\n         */\n        public void onAuthenticationFailed() {\n            callback.onFailure(\"Authentication failed\");\n        }\n\n        public @NonNull\n        Callback getCallback() {\n            return callback;\n        }\n\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.M)\n    private class FingerPrintEncryptPasswordListener extends FingerPrintAuthenticationListener {\n\n        private final String password;\n\n        public FingerPrintEncryptPasswordListener(Callback callback, String password) {\n            super(callback);\n            this.password = password;\n        }\n\n        public void onAuthenticationSucceeded(FingerprintManager.AuthenticationResult result) {\n            Cipher cipher = result.getCryptoObject().getCipher();\n            try {\n                if (encryptPassword(cipher, password)) {\n                    callback.onSuccess(\"Encrypted\");\n                } else {\n                    callback.onFailure(\"Encryption failed\");\n                }\n\n            } catch (Exception e) {\n                callback.onFailure(\"Encryption failed \" + e.getMessage());\n            }\n        }\n    }\n\n    @RequiresApi(Build.VERSION_CODES.M)\n    protected class FingerPrintDecryptPasswordListener extends FingerPrintAuthenticationListener {\n\n        public FingerPrintDecryptPasswordListener(@NonNull Callback callback) {\n            super(callback);\n        }\n\n        public void onAuthenticationSucceeded(FingerprintManager.AuthenticationResult result) {\n            Cipher cipher = result.getCryptoObject().getCipher();\n            try {\n                String savedPass = decipher(cipher);\n                if (savedPass != null) {\n                    callback.onSuccess(savedPass);\n                } else {\n                    callback.onFailure(\"Failed deciphering\");\n                }\n\n            } catch (Exception e) {\n                callback.onFailure(\"Deciphering failed \" + e.getMessage());\n            }\n        }\n    }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "public class FingerPrintAuthHelper {\n\n    private static final String FINGER_PRINT_HELPER = \"FingerPrintAuthHelper\";\n    private static final String ENCRYPTED_PASS_SHARED_PREF_KEY = \"ENCRYPTED_PASS_SHARED_PREF_KEY\";\n    private static final String LAST_USED_IV_SHARED_PREF_KEY = \"LAST_USED_IV_SHARED_PREF_KEY\";\n    private static final String MY_APP_ALIAS = \"MY_APP_ALIAS\";\n\n    private KeyguardManager keyguardManager;\n    private FingerprintManager fingerprintManager;\n\n    private final Context context;\n    private KeyStore keyStore;\n    private KeyGenerator keyGenerator;\n\n    private String lastError;\n\n\n    public interface Callback {\n        void onSuccess(String savedPass);\n\n        void onFailure(String message);\n\n        void onHelp(int helpCode, String helpString);\n    }\n\n    public FingerPrintAuthHelper(Context context) {\n        this.context = context;\n    }\n\n    public String getLastError() {\n        return lastError;\n    }\n\n    @TargetApi(Build.VERSION_CODES.M)\n    public boolean init() {\n        if (Build.VERSION.SDK_INT \u003c Build.VERSION_CODES.M) {\n            setError(\"This Android version does not support fingerprint authentication\");\n            return false;\n        }\n\n        keyguardManager = (KeyguardManager) context.getSystemService(KEYGUARD_SERVICE);\n        fingerprintManager = (FingerprintManager) context.getSystemService(FINGERPRINT_SERVICE);\n\n        if (!keyguardManager.isKeyguardSecure()) {\n            setError(\"User hasn't enabled Lock Screen\");\n            return false;\n        }\n\n        if (!hasPermission()) {\n            setError(\"User hasn't granted permission to use Fingerprint\");\n            return false;\n        }\n\n        if (!fingerprintManager.hasEnrolledFingerprints()) {\n            setError(\"User hasn't registered any fingerprints\");\n            return false;\n        }\n\n        if (!initKeyStore()) {\n            return false;\n        }\n        return false;\n    }\n\n    @Nullable\n    @RequiresApi(api = Build.VERSION_CODES.M)\n    private Cipher createCipher(int mode) throws NoSuchPaddingException, NoSuchAlgorithmException, UnrecoverableKeyException, KeyStoreException, InvalidKeyException, InvalidAlgorithmParameterException {\n        Cipher cipher = Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + \"/\" +\n                KeyProperties.BLOCK_MODE_CBC + \"/\" +\n                KeyProperties.ENCRYPTION_PADDING_PKCS7);\n\n        Key key = keyStore.getKey(MY_APP_ALIAS, null);\n        if (key == null) {\n            return null;\n        }\n        if(mode == Cipher.ENCRYPT_MODE) {\n            cipher.init(mode, key);\n            byte[] iv = cipher.getIV();\n            saveIv(iv);\n        } else {\n            byte[] lastIv = getLastIv();\n            cipher.init(mode, key, new IvParameterSpec(lastIv));\n        }\n        return cipher;\n    }\n\n    @NonNull\n    @RequiresApi(api = Build.VERSION_CODES.M)\n    private KeyGenParameterSpec createKeyGenParameterSpec() {\n        return new KeyGenParameterSpec.Builder(MY_APP_ALIAS, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n                        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)\n                        .setUserAuthenticationRequired(true)\n                        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7)\n                        .build();\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.M)\n    private boolean initKeyStore() {\n        try {\n            keyStore = KeyStore.getInstance(\"AndroidKeyStore\");\n            keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\");\n            keyStore.load(null);\n            if (getLastIv() == null) {\n                KeyGenParameterSpec keyGeneratorSpec = createKeyGenParameterSpec();\n                keyGenerator.init(keyGeneratorSpec);\n                keyGenerator.generateKey();\n            }\n        } catch (Throwable t) {\n            setError(\"Failed init of keyStore \u0026 keyGenerator: \" + t.getMessage());\n            return false;\n        }\n        return true;\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.M)\n    private void authenticate(CancellationSignal cancellationSignal, FingerPrintAuthenticationListener authListener, int mode) {\n        try {\n            if (hasPermission()) {\n                Cipher cipher = createCipher(mode);\n                FingerprintManager.CryptoObject crypto = new FingerprintManager.CryptoObject(cipher);\n                fingerprintManager.authenticate(crypto, cancellationSignal, 0, authListener, null);\n            } else {\n                authListener.getCallback().onFailure(\"User hasn't granted permission to use Fingerprint\");\n            }\n        } catch (Throwable t) {\n            authListener.getCallback().onFailure(\"An error occurred: \" + t.getMessage());\n        }\n    }\n\n    private String getSavedEncryptedPassword() {\n        SharedPreferences sharedPreferences = getSharedPreferences();\n        if (sharedPreferences != null) {\n            return sharedPreferences.getString(ENCRYPTED_PASS_SHARED_PREF_KEY, null);\n        }\n        return null;\n    }\n\n    private void saveEncryptedPassword(String encryptedPassword) {\n        SharedPreferences.Editor edit = getSharedPreferences().edit();\n        edit.putString(ENCRYPTED_PASS_SHARED_PREF_KEY, encryptedPassword);\n        edit.commit();\n    }\n\n    private byte[] getLastIv() {\n        SharedPreferences sharedPreferences = getSharedPreferences();\n        if (sharedPreferences != null) {\n            String ivString = sharedPreferences.getString(LAST_USED_IV_SHARED_PREF_KEY, null);\n\n            if (ivString != null) {\n                return decodeBytes(ivString);\n            }\n        }\n        return null;\n    }\n\n    private void saveIv(byte[] iv) {\n        SharedPreferences.Editor edit = getSharedPreferences().edit();\n        String string = encodeBytes(iv);\n        edit.putString(LAST_USED_IV_SHARED_PREF_KEY, string);\n        edit.commit();\n    }\n\n    private SharedPreferences getSharedPreferences() {\n        return context.getSharedPreferences(FINGER_PRINT_HELPER, 0);\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.M)\n    private boolean hasPermission() {\n        return ActivityCompat.checkSelfPermission(context, Manifest.permission.USE_FINGERPRINT) == PackageManager.PERMISSION_GRANTED;\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.M)\n    public void savePassword(@NonNull String password, CancellationSignal cancellationSignal, Callback callback) {\n        authenticate(cancellationSignal, new FingerPrintEncryptPasswordListener(callback, password), Cipher.ENCRYPT_MODE);\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.M)\n    public void getPassword(CancellationSignal cancellationSignal, Callback callback) {\n        authenticate(cancellationSignal, new FingerPrintDecryptPasswordListener(callback), Cipher.DECRYPT_MODE);\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.M)\n    public boolean encryptPassword(Cipher cipher, String password) {\n        try {\n            // Encrypt the text\n            if(password.isEmpty()) {\n                setError(\"Password is empty\");\n                return false;\n            }\n\n            if (cipher == null) {\n                setError(\"Could not create cipher\");\n                return false;\n            }\n\n            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n            CipherOutputStream cipherOutputStream = new CipherOutputStream(outputStream, cipher);\n            byte[] bytes = password.getBytes(Charset.defaultCharset());\n            cipherOutputStream.write(bytes);\n            cipherOutputStream.flush();\n            cipherOutputStream.close();\n            saveEncryptedPassword(encodeBytes(outputStream.toByteArray()));\n        } catch (Throwable t) {\n            setError(\"Encryption failed \" + t.getMessage());\n            return false;\n        }\n\n        return true;\n    }\n\n    private byte[] decodeBytes(String s) {\n        final int len = s.length();\n\n        // \"111\" is not a valid hex encoding.\n        if( len%2 != 0 )\n            throw new IllegalArgumentException(\"hexBinary needs to be even-length: \"+s);\n\n        byte[] out = new byte[len/2];\n\n        for( int i=0; i\u003clen; i+=2 ) {\n            int h = hexToBin(s.charAt(i  ));\n            int l = hexToBin(s.charAt(i+1));\n            if( h==-1 || l==-1 )\n                throw new IllegalArgumentException(\"contains illegal character for hexBinary: \"+s);\n\n            out[i/2] = (byte)(h*16+l);\n        }\n\n        return out;\n    }\n\n    private static int hexToBin( char ch ) {\n        if( '0'\u003c=ch \u0026\u0026 ch\u003c='9' )    return ch-'0';\n        if( 'A'\u003c=ch \u0026\u0026 ch\u003c='F' )    return ch-'A'+10;\n        if( 'a'\u003c=ch \u0026\u0026 ch\u003c='f' )    return ch-'a'+10;\n        return -1;\n    }\n\n    private static final char[] hexCode = \"0123456789ABCDEF\".toCharArray();\n\n    public String encodeBytes(byte[] data) {\n        StringBuilder r = new StringBuilder(data.length*2);\n        for ( byte b : data) {\n            r.append(hexCode[(b \u003e\u003e 4) \u0026 0xF]);\n            r.append(hexCode[(b \u0026 0xF)]);\n        }\n        return r.toString();\n    }\n\n    @NonNull\n    private String decipher(Cipher cipher) throws IOException, IllegalBlockSizeException, BadPaddingException {\n        String retVal = null;\n        String savedEncryptedPassword = getSavedEncryptedPassword();\n        if (savedEncryptedPassword != null) {\n            byte[] decodedPassword = decodeBytes(savedEncryptedPassword);\n            CipherInputStream cipherInputStream = new CipherInputStream(new ByteArrayInputStream(decodedPassword), cipher);\n\n            ArrayList\u003cByte\u003e values = new ArrayList\u003c\u003e();\n            int nextByte;\n            while ((nextByte = cipherInputStream.read()) != -1) {\n                values.add((byte) nextByte);\n            }\n            cipherInputStream.close();\n\n            byte[] bytes = new byte[values.size()];\n            for (int i = 0; i \u003c values.size(); i++) {\n                bytes[i] = values.get(i).byteValue();\n            }\n\n            retVal = new String(bytes, Charset.defaultCharset());\n        }\n        return retVal;\n    }\n\n    private void setError(String error) {\n        lastError = error;\n        Log.w(FINGER_PRINT_HELPER, lastError);\n    }\n\n    @RequiresApi(Build.VERSION_CODES.M)\n    protected class FingerPrintAuthenticationListener extends FingerprintManager.AuthenticationCallback {\n\n        protected final Callback callback;\n\n        public FingerPrintAuthenticationListener(@NonNull Callback callback) {\n            this.callback = callback;\n        }\n\n        public void onAuthenticationError(int errorCode, CharSequence errString) {\n            callback.onFailure(\"Authentication error [\" + errorCode + \"] \" + errString);\n        }\n\n        /**\n         * Called when a recoverable error has been encountered during authentication. The help\n         * string is provided to give the user guidance for what went wrong, such as\n         * \"Sensor dirty, please clean it.\"\n         * @param helpCode An integer identifying the error message\n         * @param helpString A human-readable string that can be shown in UI\n         */\n        public void onAuthenticationHelp(int helpCode, CharSequence helpString) {\n            callback.onHelp(helpCode, helpString.toString());\n        }\n\n        /**\n         * Called when a fingerprint is recognized.\n         * @param result An object containing authentication-related data\n         */\n        public void onAuthenticationSucceeded(FingerprintManager.AuthenticationResult result) {\n        }\n\n        /**\n         * Called when a fingerprint is valid but not recognized.\n         */\n        public void onAuthenticationFailed() {\n            callback.onFailure(\"Authentication failed\");\n        }\n\n        public @NonNull\n        Callback getCallback() {\n            return callback;\n        }\n\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.M)\n    private class FingerPrintEncryptPasswordListener extends FingerPrintAuthenticationListener {\n\n        private final String password;\n\n        public FingerPrintEncryptPasswordListener(Callback callback, String password) {\n            super(callback);\n            this.password = password;\n        }\n\n        public void onAuthenticationSucceeded(FingerprintManager.AuthenticationResult result) {\n            Cipher cipher = result.getCryptoObject().getCipher();\n            try {\n                if (encryptPassword(cipher, password)) {\n                    callback.onSuccess(\"Encrypted\");\n                } else {\n                    callback.onFailure(\"Encryption failed\");\n                }\n\n            } catch (Exception e) {\n                callback.onFailure(\"Encryption failed \" + e.getMessage());\n            }\n        }\n    }\n\n    @RequiresApi(Build.VERSION_CODES.M)\n    protected class FingerPrintDecryptPasswordListener extends FingerPrintAuthenticationListener {\n\n        public FingerPrintDecryptPasswordListener(@NonNull Callback callback) {\n            super(callback);\n        }\n\n        public void onAuthenticationSucceeded(FingerprintManager.AuthenticationResult result) {\n            Cipher cipher = result.getCryptoObject().getCipher();\n            try {\n                String savedPass = decipher(cipher);\n                if (savedPass != null) {\n                    callback.onSuccess(savedPass);\n                } else {\n                    callback.onFailure(\"Failed deciphering\");\n                }\n\n            } catch (Exception e) {\n                callback.onFailure(\"Deciphering failed \" + e.getMessage());\n            }\n        }\n    }\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550452962139,
        "id": "35c4d7d4-bc4e-4c5e-9002-493a2a6a2f7c",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550452962139,
        "parent_id": "1b62d207-6906-4f99-8833-e8c0518444a9",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "This activity below is a very basic example of how to get a user saved password and interact with the helper."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "This activity below is a very basic example of how to get a user saved password and interact with the helper."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550452962139,
        "id": "b4aabff6-dc15-4928-8292-68895e61f623",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550452962139,
        "parent_id": "1b62d207-6906-4f99-8833-e8c0518444a9",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "public class MainActivity extends AppCompatActivity {\n    \n    private TextView passwordTextView;\n    private FingerPrintAuthHelper fingerPrintAuthHelper;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        passwordTextView = (TextView) findViewById(R.id.password);\n        errorTextView = (TextView) findViewById(R.id.error);\n\n        View savePasswordButton = findViewById(R.id.set_password_button);\n        savePasswordButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                if (Build.VERSION.SDK_INT \u003e= Build.VERSION_CODES.M) {\n                    fingerPrintAuthHelper.savePassword(passwordTextView.getText().toString(), new CancellationSignal(), getAuthListener(false));\n                }\n            }\n        });\n\n        View getPasswordButton = findViewById(R.id.get_password_button);\n        getPasswordButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                if (Build.VERSION.SDK_INT \u003e= Build.VERSION_CODES.M) {\n                    fingerPrintAuthHelper.getPassword(new CancellationSignal(), getAuthListener(true));\n                }\n            }\n        });\n    }\n\n    // Start the finger print helper. In case this fails show error to user\n    private void startFingerPrintAuthHelper() {\n        fingerPrintAuthHelper = new FingerPrintAuthHelper(this);\n        if (!fingerPrintAuthHelper.init()) {\n            errorTextView.setText(fingerPrintAuthHelper.getLastError());\n        }\n    }\n\n    @NonNull\n    private FingerPrintAuthHelper.Callback getAuthListener(final boolean isGetPass) {\n        return new FingerPrintAuthHelper.Callback() {\n            @Override\n            public void onSuccess(String result) {\n                if (isGetPass) {\n                    errorTextView.setText(\"Success!!! Pass = \" + result);\n                } else {\n                    errorTextView.setText(\"Encrypted pass = \" + result);\n                }\n            }\n\n            @Override\n            public void onFailure(String message) {\n                errorTextView.setText(\"Failed - \" + message);\n            }\n\n            @Override\n            public void onHelp(int helpCode, String helpString) {\n                errorTextView.setText(\"Help needed - \" + helpString);\n            }\n        };\n    }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "public class MainActivity extends AppCompatActivity {\n    \n    private TextView passwordTextView;\n    private FingerPrintAuthHelper fingerPrintAuthHelper;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        passwordTextView = (TextView) findViewById(R.id.password);\n        errorTextView = (TextView) findViewById(R.id.error);\n\n        View savePasswordButton = findViewById(R.id.set_password_button);\n        savePasswordButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                if (Build.VERSION.SDK_INT \u003e= Build.VERSION_CODES.M) {\n                    fingerPrintAuthHelper.savePassword(passwordTextView.getText().toString(), new CancellationSignal(), getAuthListener(false));\n                }\n            }\n        });\n\n        View getPasswordButton = findViewById(R.id.get_password_button);\n        getPasswordButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                if (Build.VERSION.SDK_INT \u003e= Build.VERSION_CODES.M) {\n                    fingerPrintAuthHelper.getPassword(new CancellationSignal(), getAuthListener(true));\n                }\n            }\n        });\n    }\n\n    // Start the finger print helper. In case this fails show error to user\n    private void startFingerPrintAuthHelper() {\n        fingerPrintAuthHelper = new FingerPrintAuthHelper(this);\n        if (!fingerPrintAuthHelper.init()) {\n            errorTextView.setText(fingerPrintAuthHelper.getLastError());\n        }\n    }\n\n    @NonNull\n    private FingerPrintAuthHelper.Callback getAuthListener(final boolean isGetPass) {\n        return new FingerPrintAuthHelper.Callback() {\n            @Override\n            public void onSuccess(String result) {\n                if (isGetPass) {\n                    errorTextView.setText(\"Success!!! Pass = \" + result);\n                } else {\n                    errorTextView.setText(\"Encrypted pass = \" + result);\n                }\n            }\n\n            @Override\n            public void onFailure(String message) {\n                errorTextView.setText(\"Failed - \" + message);\n            }\n\n            @Override\n            public void onHelp(int helpCode, String helpString) {\n                errorTextView.setText(\"Help needed - \" + helpString);\n            }\n        };\n    }\n}",
        "code_language": "Plain Text"
      }
    ],
    "title": "How to use Android Fingerprint API to save user passwords",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}