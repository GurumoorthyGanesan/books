{
  "ID": "d8b6846b-f84f-4c28-b193-d0e4517e6a31",
  "Root": {
    "alive": true,
    "content": [
      "7d8c7173-7d7f-4243-a2d3-285629028a0e",
      "29ac5f22-5bd0-4702-a8e8-960757b91d7f",
      "50837b5c-2fb3-4d28-83f1-f1b4a9ea461d",
      "148d35a1-89dd-49b2-8686-72667bf2c6ad"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1550455432063,
    "id": "d8b6846b-f84f-4c28-b193-d0e4517e6a31",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1550455432063,
    "parent_id": "ad0c3fdb-eee5-4ba0-bc81-169b78ed8365",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "010 Using AES for salted password encryption"
        ]
      ]
    },
    "type": "page",
    "version": 1,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550455432062,
        "id": "7d8c7173-7d7f-4243-a2d3-285629028a0e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550455432062,
        "parent_id": "d8b6846b-f84f-4c28-b193-d0e4517e6a31",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "This examples uses the AES algorithm for encrypting passwords. The salt length can be up to 128 bit."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "This examples uses the AES algorithm for encrypting passwords. The salt length can be up to 128 bit."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550455432062,
        "id": "29ac5f22-5bd0-4702-a8e8-960757b91d7f",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550455432062,
        "parent_id": "d8b6846b-f84f-4c28-b193-d0e4517e6a31",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "We are using the "
            ],
            [
              "SecureRandom",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " class to generate a salt, which is combined with the password to generate a secret key. The classes used are already existing in Android packages "
            ],
            [
              "javax.crypto",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "java.security",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "We are using the "
          },
          {
            "Text": "SecureRandom",
            "AttrFlags": 2
          },
          {
            "Text": " class to generate a salt, which is combined with the password to generate a secret key. The classes used are already existing in Android packages "
          },
          {
            "Text": "javax.crypto",
            "AttrFlags": 2
          },
          {
            "Text": " and "
          },
          {
            "Text": "java.security",
            "AttrFlags": 2
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550455432062,
        "id": "50837b5c-2fb3-4d28-83f1-f1b4a9ea461d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550455432062,
        "parent_id": "d8b6846b-f84f-4c28-b193-d0e4517e6a31",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Once a key is generated, we have to preserve this key in a variable or store it. We are storing it among the shared preferences in the value "
            ],
            [
              "S_KEY",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ". Then, a password is encrypted using the "
            ],
            [
              "doFinal",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " method of the "
            ],
            [
              "Cipher",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " class once it is initialised in "
            ],
            [
              "ENCRYPT_MODE",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ". Next, the encrypted password is converted from a byte array into a string and stored among the shared preferences. The key used to generate an encrypted password can be used to decrypt the password in a similar way:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Once a key is generated, we have to preserve this key in a variable or store it. We are storing it among the shared preferences in the value "
          },
          {
            "Text": "S_KEY",
            "AttrFlags": 2
          },
          {
            "Text": ". Then, a password is encrypted using the "
          },
          {
            "Text": "doFinal",
            "AttrFlags": 2
          },
          {
            "Text": " method of the "
          },
          {
            "Text": "Cipher",
            "AttrFlags": 2
          },
          {
            "Text": " class once it is initialised in "
          },
          {
            "Text": "ENCRYPT_MODE",
            "AttrFlags": 2
          },
          {
            "Text": ". Next, the encrypted password is converted from a byte array into a string and stored among the shared preferences. The key used to generate an encrypted password can be used to decrypt the password in a similar way:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550455432063,
        "id": "148d35a1-89dd-49b2-8686-72667bf2c6ad",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550455432063,
        "parent_id": "d8b6846b-f84f-4c28-b193-d0e4517e6a31",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "public class MainActivity extends AppCompatActivity {\n    public static final String PROVIDER = \"BC\";\n    public static final int SALT_LENGTH = 20;\n    public static final int IV_LENGTH = 16;\n    public static final int PBE_ITERATION_COUNT = 100;\n\n    private static final String RANDOM_ALGORITHM = \"SHA1PRNG\";\n    private static final String HASH_ALGORITHM = \"SHA-512\";\n    private static final String PBE_ALGORITHM = \"PBEWithSHA256And256BitAES-CBC-BC\";\n    private static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n    public static final String SECRET_KEY_ALGORITHM = \"AES\";\n    private static final String TAG = \"EncryptionPassword\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        String originalPassword = \"ThisIsAndroidStudio%$\";\n        Log.e(TAG, \"originalPassword =\u003e \" + originalPassword);\n        String encryptedPassword = encryptAndStorePassword(originalPassword);\n        Log.e(TAG, \"encryptedPassword =\u003e \" + encryptedPassword);\n        String decryptedPassword = decryptAndGetPassword();\n        Log.e(TAG, \"decryptedPassword =\u003e \" + decryptedPassword);\n    }\n\n    private String decryptAndGetPassword() {\n        SharedPreferences prefs = getSharedPreferences(\"pswd\", MODE_PRIVATE);\n        String encryptedPasswrd = prefs.getString(\"token\", \"\");\n        String passwrd = \"\";\n        if (encryptedPasswrd!=null \u0026\u0026 !encryptedPasswrd.isEmpty()) {\n            try {\n                String output = prefs.getString(\"S_KEY\", \"\");\n                byte[] encoded = hexStringToByteArray(output);\n                SecretKey aesKey = new SecretKeySpec(encoded, SECRET_KEY_ALGORITHM);\n                passwrd = decrypt(aesKey, encryptedPasswrd);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return passwrd;\n    }\n\n    public String encryptAndStorePassword(String password) {\n        SharedPreferences.Editor editor = getSharedPreferences(\"pswd\", MODE_PRIVATE).edit();\n        String encryptedPassword = \"\";\n        if (password!=null \u0026\u0026 !password.isEmpty()) {\n            SecretKey secretKey = null;\n            try {\n                secretKey = getSecretKey(password, generateSalt());\n\n                byte[] encoded = secretKey.getEncoded();\n                String input = byteArrayToHexString(encoded);\n                editor.putString(\"S_KEY\", input);\n                encryptedPassword = encrypt(secretKey, password);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            editor.putString(\"token\", encryptedPassword);\n            editor.commit();\n        }\n        return encryptedPassword;\n    }\n\n    public static String encrypt(SecretKey secret, String cleartext) throws Exception {\n        try {\n            byte[] iv = generateIv();\n            String ivHex = byteArrayToHexString(iv);\n            IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n            Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM, PROVIDER);\n            encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);\n            byte[] encryptedText = encryptionCipher.doFinal(cleartext.getBytes(\"UTF-8\"));\n            String encryptedHex = byteArrayToHexString(encryptedText);\n\n            return ivHex + encryptedHex;\n\n        } catch (Exception e) {\n            Log.e(\"SecurityException\", e.getCause().getLocalizedMessage());\n            throw new Exception(\"Unable to encrypt\", e);\n        }\n    }\n\n    public static String decrypt(SecretKey secret, String encrypted) throws Exception {\n        try {\n            Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM, PROVIDER);\n            String ivHex = encrypted.substring(0, IV_LENGTH * 2);\n            String encryptedHex = encrypted.substring(IV_LENGTH * 2);\n            IvParameterSpec ivspec = new IvParameterSpec(hexStringToByteArray(ivHex));\n            decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);\n            byte[] decryptedText = decryptionCipher.doFinal(hexStringToByteArray(encryptedHex));\n            String decrypted = new String(decryptedText, \"UTF-8\");\n            return decrypted;\n        } catch (Exception e) {\n            Log.e(\"SecurityException\", e.getCause().getLocalizedMessage());\n            throw new Exception(\"Unable to decrypt\", e);\n        }\n    }\n\n    public static String generateSalt() throws Exception {\n        try {\n            SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n            byte[] salt = new byte[SALT_LENGTH];\n            random.nextBytes(salt);\n            String saltHex = byteArrayToHexString(salt);\n            return saltHex;\n        } catch (Exception e) {\n            throw new Exception(\"Unable to generate salt\", e);\n        }\n    }\n\n    public static String byteArrayToHexString(byte[] b) {\n        StringBuffer sb = new StringBuffer(b.length * 2);\n        for (int i = 0; i \u003c b.length; i++) {\n            int v = b[i] \u0026 0xff;\n            if (v \u003c 16) {\n                sb.append('0');\n            }\n            sb.append(Integer.toHexString(v));\n        }\n        return sb.toString().toUpperCase();\n    }\n\n    public static byte[] hexStringToByteArray(String s) {\n        byte[] b = new byte[s.length() / 2];\n        for (int i = 0; i \u003c b.length; i++) {\n            int index = i * 2;\n            int v = Integer.parseInt(s.substring(index, index + 2), 16);\n            b[i] = (byte) v;\n        }\n        return b;\n    }\n\n    public static SecretKey getSecretKey(String password, String salt) throws Exception {\n        try {\n            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), hexStringToByteArray(salt), PBE_ITERATION_COUNT, 256);\n            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM, PROVIDER);\n            SecretKey tmp = factory.generateSecret(pbeKeySpec);\n            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), SECRET_KEY_ALGORITHM);\n            return secret;\n        } catch (Exception e) {\n            throw new Exception(\"Unable to get secret key\", e);\n        }\n    }\n\n    private static byte[] generateIv() throws NoSuchAlgorithmException, NoSuchProviderException {\n        SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n        byte[] iv = new byte[IV_LENGTH];\n        random.nextBytes(iv);\n        return iv;\n    }\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "public class MainActivity extends AppCompatActivity {\n    public static final String PROVIDER = \"BC\";\n    public static final int SALT_LENGTH = 20;\n    public static final int IV_LENGTH = 16;\n    public static final int PBE_ITERATION_COUNT = 100;\n\n    private static final String RANDOM_ALGORITHM = \"SHA1PRNG\";\n    private static final String HASH_ALGORITHM = \"SHA-512\";\n    private static final String PBE_ALGORITHM = \"PBEWithSHA256And256BitAES-CBC-BC\";\n    private static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n    public static final String SECRET_KEY_ALGORITHM = \"AES\";\n    private static final String TAG = \"EncryptionPassword\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        String originalPassword = \"ThisIsAndroidStudio%$\";\n        Log.e(TAG, \"originalPassword =\u003e \" + originalPassword);\n        String encryptedPassword = encryptAndStorePassword(originalPassword);\n        Log.e(TAG, \"encryptedPassword =\u003e \" + encryptedPassword);\n        String decryptedPassword = decryptAndGetPassword();\n        Log.e(TAG, \"decryptedPassword =\u003e \" + decryptedPassword);\n    }\n\n    private String decryptAndGetPassword() {\n        SharedPreferences prefs = getSharedPreferences(\"pswd\", MODE_PRIVATE);\n        String encryptedPasswrd = prefs.getString(\"token\", \"\");\n        String passwrd = \"\";\n        if (encryptedPasswrd!=null \u0026\u0026 !encryptedPasswrd.isEmpty()) {\n            try {\n                String output = prefs.getString(\"S_KEY\", \"\");\n                byte[] encoded = hexStringToByteArray(output);\n                SecretKey aesKey = new SecretKeySpec(encoded, SECRET_KEY_ALGORITHM);\n                passwrd = decrypt(aesKey, encryptedPasswrd);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        return passwrd;\n    }\n\n    public String encryptAndStorePassword(String password) {\n        SharedPreferences.Editor editor = getSharedPreferences(\"pswd\", MODE_PRIVATE).edit();\n        String encryptedPassword = \"\";\n        if (password!=null \u0026\u0026 !password.isEmpty()) {\n            SecretKey secretKey = null;\n            try {\n                secretKey = getSecretKey(password, generateSalt());\n\n                byte[] encoded = secretKey.getEncoded();\n                String input = byteArrayToHexString(encoded);\n                editor.putString(\"S_KEY\", input);\n                encryptedPassword = encrypt(secretKey, password);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            editor.putString(\"token\", encryptedPassword);\n            editor.commit();\n        }\n        return encryptedPassword;\n    }\n\n    public static String encrypt(SecretKey secret, String cleartext) throws Exception {\n        try {\n            byte[] iv = generateIv();\n            String ivHex = byteArrayToHexString(iv);\n            IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n            Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM, PROVIDER);\n            encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);\n            byte[] encryptedText = encryptionCipher.doFinal(cleartext.getBytes(\"UTF-8\"));\n            String encryptedHex = byteArrayToHexString(encryptedText);\n\n            return ivHex + encryptedHex;\n\n        } catch (Exception e) {\n            Log.e(\"SecurityException\", e.getCause().getLocalizedMessage());\n            throw new Exception(\"Unable to encrypt\", e);\n        }\n    }\n\n    public static String decrypt(SecretKey secret, String encrypted) throws Exception {\n        try {\n            Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM, PROVIDER);\n            String ivHex = encrypted.substring(0, IV_LENGTH * 2);\n            String encryptedHex = encrypted.substring(IV_LENGTH * 2);\n            IvParameterSpec ivspec = new IvParameterSpec(hexStringToByteArray(ivHex));\n            decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);\n            byte[] decryptedText = decryptionCipher.doFinal(hexStringToByteArray(encryptedHex));\n            String decrypted = new String(decryptedText, \"UTF-8\");\n            return decrypted;\n        } catch (Exception e) {\n            Log.e(\"SecurityException\", e.getCause().getLocalizedMessage());\n            throw new Exception(\"Unable to decrypt\", e);\n        }\n    }\n\n    public static String generateSalt() throws Exception {\n        try {\n            SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n            byte[] salt = new byte[SALT_LENGTH];\n            random.nextBytes(salt);\n            String saltHex = byteArrayToHexString(salt);\n            return saltHex;\n        } catch (Exception e) {\n            throw new Exception(\"Unable to generate salt\", e);\n        }\n    }\n\n    public static String byteArrayToHexString(byte[] b) {\n        StringBuffer sb = new StringBuffer(b.length * 2);\n        for (int i = 0; i \u003c b.length; i++) {\n            int v = b[i] \u0026 0xff;\n            if (v \u003c 16) {\n                sb.append('0');\n            }\n            sb.append(Integer.toHexString(v));\n        }\n        return sb.toString().toUpperCase();\n    }\n\n    public static byte[] hexStringToByteArray(String s) {\n        byte[] b = new byte[s.length() / 2];\n        for (int i = 0; i \u003c b.length; i++) {\n            int index = i * 2;\n            int v = Integer.parseInt(s.substring(index, index + 2), 16);\n            b[i] = (byte) v;\n        }\n        return b;\n    }\n\n    public static SecretKey getSecretKey(String password, String salt) throws Exception {\n        try {\n            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), hexStringToByteArray(salt), PBE_ITERATION_COUNT, 256);\n            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM, PROVIDER);\n            SecretKey tmp = factory.generateSecret(pbeKeySpec);\n            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), SECRET_KEY_ALGORITHM);\n            return secret;\n        } catch (Exception e) {\n            throw new Exception(\"Unable to get secret key\", e);\n        }\n    }\n\n    private static byte[] generateIv() throws NoSuchAlgorithmException, NoSuchProviderException {\n        SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n        byte[] iv = new byte[IV_LENGTH];\n        random.nextBytes(iv);\n        return iv;\n    }\n}",
        "code_language": "Plain Text"
      }
    ],
    "title": "010 Using AES for salted password encryption"
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}