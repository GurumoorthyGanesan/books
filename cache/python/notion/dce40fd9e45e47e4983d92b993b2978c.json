{
  "ID": "dce40fd9-e45e-47e4-983d-92b993b2978c",
  "Root": {
    "alive": true,
    "content": [
      "081d888d-831c-429e-9160-b32e19e6bc1c",
      "6466ab4c-eca8-44d3-8df2-15f8bd54c04f",
      "185e3194-2fa4-4955-a12d-5e87f394d7ad",
      "1a379e4c-327d-4597-bc57-f95476cab7d4",
      "3f2ea429-fee2-48ca-a608-a0aa309892bf",
      "7cc1cad7-45dd-47de-a094-c9505ac9de1d",
      "e25344b7-0ea7-41dc-873c-5f51deb6199f",
      "346b2833-971c-498b-8769-0574abe4e5aa",
      "1037ba58-ea7b-411d-af92-8c336fc49398",
      "26c646fe-50d6-4d6a-9999-15892bb94247",
      "d356acf4-d0d4-4d9c-af20-1b11b6f1e952",
      "9b14f228-3c1d-47e6-8e07-c9bf8a3e7061",
      "2e60ea19-50d1-419c-94d0-6758167eaae0",
      "7adc5209-9876-4acd-8509-58428984bfeb",
      "3315f882-dc42-4002-8d52-4725947afd9b"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1550392571966,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "dce40fd9-e45e-47e4-983d-92b993b2978c",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1550475840000,
    "parent_id": "fc100f71-43db-4563-adaa-317499f09cab",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Algorithmic Notations..."
        ]
      ]
    },
    "type": "page",
    "version": 8,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550392571959,
        "id": "081d888d-831c-429e-9160-b32e19e6bc1c",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550392571959,
        "parent_id": "dce40fd9-e45e-47e4-983d-92b993b2978c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "There are certain principles that apply to optimization in any computer language, and Python is no exception. "
            ],
            [
              "Don’t optimize as you go",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ": Write your program without regard to possible optimizations, concentrating instead on making sure that the code is clean, correct, and understandable. If it’s too big or too slow when you’ve finished, then you can consider optimizing it."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "There are certain principles that apply to optimization in any computer language, and Python is no exception. "
          },
          {
            "Text": "Don’t optimize as you go",
            "AttrFlags": 1
          },
          {
            "Text": ": Write your program without regard to possible optimizations, concentrating instead on making sure that the code is clean, correct, and understandable. If it’s too big or too slow when you’ve finished, then you can consider optimizing it."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550392571962,
        "id": "6466ab4c-eca8-44d3-8df2-15f8bd54c04f",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550392571962,
        "parent_id": "dce40fd9-e45e-47e4-983d-92b993b2978c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Remember the 80/20 rule",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ": In many fields you can get 80% of the result with 20% of the effort (also called the 90/10 rule - it depends on who you talk to). Whenever you’re about to optimize code, use profiling to find out where that 80% of execution time is going, so you know where to concentrate your effort."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Remember the 80/20 rule",
            "AttrFlags": 1
          },
          {
            "Text": ": In many fields you can get 80% of the result with 20% of the effort (also called the 90/10 rule - it depends on who you talk to). Whenever you’re about to optimize code, use profiling to find out where that 80% of execution time is going, so you know where to concentrate your effort."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550392571962,
        "id": "185e3194-2fa4-4955-a12d-5e87f394d7ad",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550392571962,
        "parent_id": "dce40fd9-e45e-47e4-983d-92b993b2978c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Always run “before” and “after” benchmarks",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ": How else will you know that your optimizations actually made a difference? If your optimized code turns out to be only slightly faster or smaller than the original version, undo your changes and go back to the original, clear code."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Always run “before” and “after” benchmarks",
            "AttrFlags": 1
          },
          {
            "Text": ": How else will you know that your optimizations actually made a difference? If your optimized code turns out to be only slightly faster or smaller than the original version, undo your changes and go back to the original, clear code."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550392571962,
        "id": "1a379e4c-327d-4597-bc57-f95476cab7d4",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550392571962,
        "parent_id": "dce40fd9-e45e-47e4-983d-92b993b2978c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Use the right algorithms and data structures: Don’t use an O(n2) bubble sort algorithm to sort a thousand elements when there’s an O(n log n) quicksort available. Similarly, don’t store a thousand items in an array that requires an O(n) search when you could use an O(log n) binary tree, or an O(1) Python hash table."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Use the right algorithms and data structures: Don’t use an O(n2) bubble sort algorithm to sort a thousand elements when there’s an O(n log n) quicksort available. Similarly, don’t store a thousand items in an array that requires an O(n) search when you could use an O(log n) binary tree, or an O(1) Python hash table."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550392571964,
        "id": "3f2ea429-fee2-48ca-a608-a0aa309892bf",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550392571964,
        "parent_id": "dce40fd9-e45e-47e4-983d-92b993b2978c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "For more visit the link below… "
            ],
            [
              "Python Speed Up",
              [
                [
                  "a",
                  "https://wiki.python.org/moin/PythonSpeed/PerformanceTips"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "For more visit the link below… "
          },
          {
            "Text": "Python Speed Up",
            "Link": "https://wiki.python.org/moin/PythonSpeed/PerformanceTips"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550392571964,
        "id": "7cc1cad7-45dd-47de-a094-c9505ac9de1d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550392571964,
        "parent_id": "dce40fd9-e45e-47e4-983d-92b993b2978c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The following 3 asymptotic notations are mostly used to represent time complexity of algorithms."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The following 3 asymptotic notations are mostly used to represent time complexity of algorithms."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550392571965,
        "id": "e25344b7-0ea7-41dc-873c-5f51deb6199f",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550392571965,
        "parent_id": "dce40fd9-e45e-47e4-983d-92b993b2978c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Θ Notation",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ": The theta notation bounds a functions from above and below, so it defines exact asymptotic behavior. A simple way to get Theta notation of an expression is to drop low order terms and ignore leading constants. For example, consider the following expression. 3n3 + 6n2 + 6000 = Θ(n3) Dropping lower order terms is always fine because there will always be a n0 after which Θ(n3) has higher values than Θn2) irrespective of the constants involved. For a given function g(n), we denote Θ(g(n)) is following set of functions. Θ(g(n)) = {f(n): there exist positive constants c1, c2 and n0 such that 0 \u003c= c1"
            ],
            [
              "g(n) \u003c= f(n) \u003c= c2",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              "g(n) for all n \u003e= n0} The above definition means, if f(n) is theta of g(n), then the value f(n) is always between c1"
            ],
            [
              "g(n) and c2",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              "g(n) for large values of n (n \u003e= n0). The definition of theta also requires that f(n) must be non-negative for values of n greater than n0."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Θ Notation",
            "AttrFlags": 1
          },
          {
            "Text": ": The theta notation bounds a functions from above and below, so it defines exact asymptotic behavior. A simple way to get Theta notation of an expression is to drop low order terms and ignore leading constants. For example, consider the following expression. 3n3 + 6n2 + 6000 = Θ(n3) Dropping lower order terms is always fine because there will always be a n0 after which Θ(n3) has higher values than Θn2) irrespective of the constants involved. For a given function g(n), we denote Θ(g(n)) is following set of functions. Θ(g(n)) = {f(n): there exist positive constants c1, c2 and n0 such that 0 \u003c= c1"
          },
          {
            "Text": "g(n) \u003c= f(n) \u003c= c2",
            "AttrFlags": 4
          },
          {
            "Text": "g(n) for all n \u003e= n0} The above definition means, if f(n) is theta of g(n), then the value f(n) is always between c1"
          },
          {
            "Text": "g(n) and c2",
            "AttrFlags": 4
          },
          {
            "Text": "g(n) for large values of n (n \u003e= n0). The definition of theta also requires that f(n) must be non-negative for values of n greater than n0."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550392571965,
        "id": "346b2833-971c-498b-8769-0574abe4e5aa",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550392571965,
        "parent_id": "dce40fd9-e45e-47e4-983d-92b993b2978c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Big O Notation",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ": The Big O notation defines an upper bound of an algorithm, it bounds a function only from above. For example, consider the case of Insertion Sort. It takes linear time in best case and quadratic time in worst case. We can safely say that the time complexity of Insertion sort is O(n^2). Note that O(n^2) also covers linear time. If we use Θ notation to represent time complexity of Insertion sort, we have to use two statements for best and worst cases:"
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Big O Notation",
            "AttrFlags": 1
          },
          {
            "Text": ": The Big O notation defines an upper bound of an algorithm, it bounds a function only from above. For example, consider the case of Insertion Sort. It takes linear time in best case and quadratic time in worst case. We can safely say that the time complexity of Insertion sort is O(n^2). Note that O(n^2) also covers linear time. If we use Θ notation to represent time complexity of Insertion sort, we have to use two statements for best and worst cases:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550392571965,
        "id": "1037ba58-ea7b-411d-af92-8c336fc49398",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550392571965,
        "parent_id": "dce40fd9-e45e-47e4-983d-92b993b2978c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The worst case time complexity of Insertion Sort is Θ(n^2)."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "The worst case time complexity of Insertion Sort is Θ(n^2)."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550392571965,
        "id": "26c646fe-50d6-4d6a-9999-15892bb94247",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550392571965,
        "parent_id": "dce40fd9-e45e-47e4-983d-92b993b2978c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The best case time complexity of Insertion Sort is Θ(n)."
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "The best case time complexity of Insertion Sort is Θ(n)."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550392571965,
        "id": "d356acf4-d0d4-4d9c-af20-1b11b6f1e952",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550392571965,
        "parent_id": "dce40fd9-e45e-47e4-983d-92b993b2978c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The Big O notation is useful when we only have upper bound on time complexity of an algorithm. Many times we easily find an upper bound by simply looking at the algorithm. O(g(n)) = { f(n): there exist positive constants c and"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The Big O notation is useful when we only have upper bound on time complexity of an algorithm. Many times we easily find an upper bound by simply looking at the algorithm. O(g(n)) = { f(n): there exist positive constants c and"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550392571965,
        "id": "9b14f228-3c1d-47e6-8e07-c9bf8a3e7061",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550392571965,
        "parent_id": "dce40fd9-e45e-47e4-983d-92b993b2978c",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "n0 such that 0 \u003c= f(n) \u003c= cg(n) for \nall n \u003e= n0}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "n0 such that 0 \u003c= f(n) \u003c= cg(n) for \nall n \u003e= n0}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550392571966,
        "id": "2e60ea19-50d1-419c-94d0-6758167eaae0",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550392571966,
        "parent_id": "dce40fd9-e45e-47e4-983d-92b993b2978c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Ω Notation",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ": Just as Big O notation provides an asymptotic upper bound on a function, Ω notation provides an asymptotic lower bound. Ω Notation\u003c can be useful when we have lower bound on time complexity of an algorithm. As discussed in the previous post, the best case performance of an algorithm is generally not useful, the Omega notation is the least used notation among all three. For a given function g(n), we denote by Ω(g(n)) the set of functions. Ω (g(n)) = {f(n): there exist positive constants c and"
            ]
          ]
        },
        "type": "numbered_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Ω Notation",
            "AttrFlags": 1
          },
          {
            "Text": ": Just as Big O notation provides an asymptotic upper bound on a function, Ω notation provides an asymptotic lower bound. Ω Notation\u003c can be useful when we have lower bound on time complexity of an algorithm. As discussed in the previous post, the best case performance of an algorithm is generally not useful, the Omega notation is the least used notation among all three. For a given function g(n), we denote by Ω(g(n)) the set of functions. Ω (g(n)) = {f(n): there exist positive constants c and"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550392571966,
        "id": "7adc5209-9876-4acd-8509-58428984bfeb",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550392571966,
        "parent_id": "dce40fd9-e45e-47e4-983d-92b993b2978c",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "n0 such that 0 \u003c= cg(n) \u003c= f(n) for\nall n \u003e= n0}."
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "n0 such that 0 \u003c= cg(n) \u003c= f(n) for\nall n \u003e= n0}.",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550392571966,
        "id": "3315f882-dc42-4002-8d52-4725947afd9b",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550392571966,
        "parent_id": "dce40fd9-e45e-47e4-983d-92b993b2978c",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Let us consider the same Insertion sort example here. The time complexity of Insertion Sort can be written as Ω(n), but it is not a very useful information about insertion sort, as we are generally interested in worst case and sometimes in average case."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Let us consider the same Insertion sort example here. The time complexity of Insertion Sort can be written as Ω(n), but it is not a very useful information about insertion sort, as we are generally interested in worst case and sometimes in average case."
          }
        ]
      }
    ],
    "title": "Algorithmic Notations...",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}