{
  "ID": "7665b43f-7b42-437d-adb9-108709b70d11",
  "Root": {
    "alive": true,
    "content": [
      "5b38b3e3-363c-4705-a39b-dfe9a7c8f583",
      "b85a69f2-8e7c-4438-abbd-659c75bbc4c2",
      "cd395653-e559-411f-87f8-ccf4c85646df",
      "aee97314-de70-4021-a43c-9f7c4756f154",
      "fff9710e-9229-4661-a2fc-4ae53f573cfa",
      "bcc59c70-2447-4be3-bee7-9e53172cbbe1",
      "a92061f0-be8d-473c-a7a8-67d52ea3759e",
      "1f858f91-5d93-4d74-9665-57de37faadb0",
      "21d6fe78-2616-4271-8560-6eb5336912d2",
      "24bcca7e-c70e-4822-ae60-dfa79261b290",
      "c4608df5-a364-4065-a546-feae1616a999",
      "28e6ff73-cab7-4ea3-98db-38c93e0cf639",
      "cb5ded4d-874e-49a3-b892-4abdc12fc7d6",
      "f82a7d2a-bd7a-4769-b1ae-997d13258901",
      "2df48b69-d286-48ad-9623-033456127792"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1550389255677,
    "id": "7665b43f-7b42-437d-adb9-108709b70d11",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1550469360000,
    "parent_id": "6f02e2b4-2630-4916-8284-461d35c0ceba",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Garbage Collection"
        ]
      ]
    },
    "type": "page",
    "version": 8,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550389255671,
        "id": "5b38b3e3-363c-4705-a39b-dfe9a7c8f583",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550389255671,
        "parent_id": "7665b43f-7b42-437d-adb9-108709b70d11",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Remarks"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Remarks"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550389255671,
        "id": "b85a69f2-8e7c-4438-abbd-659c75bbc4c2",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550389255671,
        "parent_id": "7665b43f-7b42-437d-adb9-108709b70d11",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "At its core, Python’s garbage collector (as of 3.5) is a simple reference counting implementation. Every time you make a reference to an object (for example, "
            ],
            [
              "a = myobject",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ") the reference count on that object (myobject) is incremented. Every time a reference gets removed, the reference count is decremented, and once the reference count reaches "
            ],
            [
              "0",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ", we know that nothing holds a reference to that object and we can deallocate it!"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "At its core, Python’s garbage collector (as of 3.5) is a simple reference counting implementation. Every time you make a reference to an object (for example, "
          },
          {
            "Text": "a = myobject",
            "AttrFlags": 2
          },
          {
            "Text": ") the reference count on that object (myobject) is incremented. Every time a reference gets removed, the reference count is decremented, and once the reference count reaches "
          },
          {
            "Text": "0",
            "AttrFlags": 2
          },
          {
            "Text": ", we know that nothing holds a reference to that object and we can deallocate it!"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550389255672,
        "id": "cd395653-e559-411f-87f8-ccf4c85646df",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550389255672,
        "parent_id": "7665b43f-7b42-437d-adb9-108709b70d11",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "One common misunderstanding about how Python memory management works is that the "
            ],
            [
              "del",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " keyword frees objects memory. This is not true. What actually happens is that the "
            ],
            [
              "del",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " keyword merely decrements the objects refcount, meaning that if you call it enough times for the refcount to reach zero the object may be garbage collected (even if there are actually still references to the object available elsewhere in your code)."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "One common misunderstanding about how Python memory management works is that the "
          },
          {
            "Text": "del",
            "AttrFlags": 2
          },
          {
            "Text": " keyword frees objects memory. This is not true. What actually happens is that the "
          },
          {
            "Text": "del",
            "AttrFlags": 2
          },
          {
            "Text": " keyword merely decrements the objects refcount, meaning that if you call it enough times for the refcount to reach zero the object may be garbage collected (even if there are actually still references to the object available elsewhere in your code)."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550389255672,
        "id": "aee97314-de70-4021-a43c-9f7c4756f154",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550389255672,
        "parent_id": "7665b43f-7b42-437d-adb9-108709b70d11",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Python aggresively creates or cleans up objects the first time it needs them If I perform the assignment a = object(), the memory for object is allocated at that time (cpython will sometimes reuse certain types of object, eg. lists under the hood, but mostly it doesn’t keep a free object pool and will perform allocation when you need it). Similarly, as soon as the refcount is decremented to 0, GC cleans it up."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Python aggresively creates or cleans up objects the first time it needs them If I perform the assignment a = object(), the memory for object is allocated at that time (cpython will sometimes reuse certain types of object, eg. lists under the hood, but mostly it doesn’t keep a free object pool and will perform allocation when you need it). Similarly, as soon as the refcount is decremented to 0, GC cleans it up."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550389255672,
        "id": "fff9710e-9229-4661-a2fc-4ae53f573cfa",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550389255672,
        "parent_id": "7665b43f-7b42-437d-adb9-108709b70d11",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Generational Garbage Collection"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Generational Garbage Collection"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550389255672,
        "id": "bcc59c70-2447-4be3-bee7-9e53172cbbe1",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550389255672,
        "parent_id": "7665b43f-7b42-437d-adb9-108709b70d11",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "In the 1960’s John McCarthy discovered a fatal flaw in refcounting garbage collection when he implemented the refcounting algorithm used by Lisp: What happens if two objects refer to each other in a cyclic reference? How can you ever garbage collect those two objects even if there are no external references to them if they will always refer to eachother? This problem also extends to any cyclic data structure, such as a ring buffers or any two consecutive entries in a doubly linked list. Python attempts to fix this problem using a slightly interesting twist on another garbage collection algorithm called "
            ],
            [
              "Generational Garbage Collection",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "In the 1960’s John McCarthy discovered a fatal flaw in refcounting garbage collection when he implemented the refcounting algorithm used by Lisp: What happens if two objects refer to each other in a cyclic reference? How can you ever garbage collect those two objects even if there are no external references to them if they will always refer to eachother? This problem also extends to any cyclic data structure, such as a ring buffers or any two consecutive entries in a doubly linked list. Python attempts to fix this problem using a slightly interesting twist on another garbage collection algorithm called "
          },
          {
            "Text": "Generational Garbage Collection",
            "AttrFlags": 1
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550389255672,
        "id": "a92061f0-be8d-473c-a7a8-67d52ea3759e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550389255672,
        "parent_id": "7665b43f-7b42-437d-adb9-108709b70d11",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "In essence, any time you create an object in Python it adds it to the end of a doubly linked list. On occasion Python loops through this list, checks what objects the objects in the list refer too, and if they’re also in the list (we’ll see why they might not be in a moment), further decrements their refcounts. At this point (actually, there are some heuristics that determine when things get moved, but let’s assume it’s after a single collection to keep things simple) anything that still has a refcount greater than 0 gets promoted to another linked list called “Generation 1” (this is why all objects aren’t always in the generation 0 list) which has this loop applied to it less often. This is where the generational garbage collection comes in. There are 3 generations by default in Python (three linked lists of objects): The first list (generation 0) contains all new objects; if a GC cycle happens and the objects are not collected, they get moved to the second list (generation 1), and if a GC cycle happens on the second list and they are still not collected they get moved to the third list (generation 2). The third generation list (called “generation 2”, since we’re zero indexing) is garbage collected much less often than the first two, the idea being that if your object is long lived it’s not as likely to be GCed, and may never be GCed during the lifetime of your application so there’s no point in wasting time checking it on every single GC run. Furthermore, it’s observed that most objects are garbage collected relatively quickly. From now on, we’ll call these “good objects” since they die young. This is called the “weak generational hypothesis” and was also first observed in the 60s."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "In essence, any time you create an object in Python it adds it to the end of a doubly linked list. On occasion Python loops through this list, checks what objects the objects in the list refer too, and if they’re also in the list (we’ll see why they might not be in a moment), further decrements their refcounts. At this point (actually, there are some heuristics that determine when things get moved, but let’s assume it’s after a single collection to keep things simple) anything that still has a refcount greater than 0 gets promoted to another linked list called “Generation 1” (this is why all objects aren’t always in the generation 0 list) which has this loop applied to it less often. This is where the generational garbage collection comes in. There are 3 generations by default in Python (three linked lists of objects): The first list (generation 0) contains all new objects; if a GC cycle happens and the objects are not collected, they get moved to the second list (generation 1), and if a GC cycle happens on the second list and they are still not collected they get moved to the third list (generation 2). The third generation list (called “generation 2”, since we’re zero indexing) is garbage collected much less often than the first two, the idea being that if your object is long lived it’s not as likely to be GCed, and may never be GCed during the lifetime of your application so there’s no point in wasting time checking it on every single GC run. Furthermore, it’s observed that most objects are garbage collected relatively quickly. From now on, we’ll call these “good objects” since they die young. This is called the “weak generational hypothesis” and was also first observed in the 60s."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550389255675,
        "id": "1f858f91-5d93-4d74-9665-57de37faadb0",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550389255675,
        "parent_id": "7665b43f-7b42-437d-adb9-108709b70d11",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "A quick aside: unlike the first two generations, the long lived third generation list is not garbage collected on a regular schedule. It is checked when the ratio of long lived pending objects (those that are in the third generation list, but haven’t actually had a GC cycle yet) to the total long lived objects in the list is greater than 25%. This is because the third list is unbounded (things are never moved off of it to another list, so they only go away when they’re actually garbage collected), meaning that for applications where you are creating lots of long lived objects, GC cycles on the third list can get quite long. By using a ratio we achieve “amortized linear performance in the total number of objects”; aka, the longer the list, the longer GC takes, but the less often we perform GC (here’s the "
            ],
            [
              "original 2008 proposal",
              [
                [
                  "a",
                  "https://mail.python.org/pipermail/python-dev/2008-June/080579.html"
                ]
              ]
            ],
            [
              " for this heuristic by Martin von Löwis for futher reading). The act of performing a garbage collection on the third generation or “mature” list is called “full garbage collection”."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "A quick aside: unlike the first two generations, the long lived third generation list is not garbage collected on a regular schedule. It is checked when the ratio of long lived pending objects (those that are in the third generation list, but haven’t actually had a GC cycle yet) to the total long lived objects in the list is greater than 25%. This is because the third list is unbounded (things are never moved off of it to another list, so they only go away when they’re actually garbage collected), meaning that for applications where you are creating lots of long lived objects, GC cycles on the third list can get quite long. By using a ratio we achieve “amortized linear performance in the total number of objects”; aka, the longer the list, the longer GC takes, but the less often we perform GC (here’s the "
          },
          {
            "Text": "original 2008 proposal",
            "Link": "https://mail.python.org/pipermail/python-dev/2008-June/080579.html"
          },
          {
            "Text": " for this heuristic by Martin von Löwis for futher reading). The act of performing a garbage collection on the third generation or “mature” list is called “full garbage collection”."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550389255675,
        "id": "21d6fe78-2616-4271-8560-6eb5336912d2",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550389255675,
        "parent_id": "7665b43f-7b42-437d-adb9-108709b70d11",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "So the generational garbage collection speeds things up tremdously by not requiring that we scan over objects that aren’t likely to need GC all the time, but how does it help us break cyclic references? Probably not very well, it turns out. The function for actually breaking these reference cycles starts out "
            ],
            [
              "like this",
              [
                [
                  "a",
                  "https://github.com/python/cpython/blob/8f33d77/Modules/gcmodule.c#L847"
                ]
              ]
            ],
            [
              ":"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "So the generational garbage collection speeds things up tremdously by not requiring that we scan over objects that aren’t likely to need GC all the time, but how does it help us break cyclic references? Probably not very well, it turns out. The function for actually breaking these reference cycles starts out "
          },
          {
            "Text": "like this",
            "Link": "https://github.com/python/cpython/blob/8f33d77/Modules/gcmodule.c#L847"
          },
          {
            "Text": ":"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550389255676,
        "id": "24bcca7e-c70e-4822-ae60-dfa79261b290",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550389255676,
        "parent_id": "7665b43f-7b42-437d-adb9-108709b70d11",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "/* Break reference cycles by clearing the containers involved.  This is\n * tricky business as the lists can be changing and we don't know which\n * objects may be freed.  It is possible I screwed something up here.\n */\nstatic void\ndelete_garbage(PyGC_Head *collectable, PyGC_Head *old)"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "/* Break reference cycles by clearing the containers involved.  This is\n * tricky business as the lists can be changing and we don't know which\n * objects may be freed.  It is possible I screwed something up here.\n */\nstatic void\ndelete_garbage(PyGC_Head *collectable, PyGC_Head *old)",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550389255676,
        "id": "c4608df5-a364-4065-a546-feae1616a999",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550389255676,
        "parent_id": "7665b43f-7b42-437d-adb9-108709b70d11",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The reason generational garbage collection helps with this is that we can keep the length of the list as a separate count; each time we add a new object to the generation we increment this count, and any time we move an object to another generation or dealloc it we decrement the count. Theoretically at the end of a GC cycle this count (for the first two generations anyways) should always be 0. If it’s not, anything in the list that’s left over is some form of circular reference and we can drop it. However, there’s one more problem here: What if the leftover objects have Python’s magic method "
            ],
            [
              "__del__",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " on them? "
            ],
            [
              "__del__",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " is called any time a Python object is destroyed. However, if two objects in a circular reference have "
            ],
            [
              "__del__",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " methods, we can’t be sure that destroying one won’t break the others "
            ],
            [
              "__del__",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " method. For a contrived example, imagine we wrote the following:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The reason generational garbage collection helps with this is that we can keep the length of the list as a separate count; each time we add a new object to the generation we increment this count, and any time we move an object to another generation or dealloc it we decrement the count. Theoretically at the end of a GC cycle this count (for the first two generations anyways) should always be 0. If it’s not, anything in the list that’s left over is some form of circular reference and we can drop it. However, there’s one more problem here: What if the leftover objects have Python’s magic method "
          },
          {
            "Text": "__del__",
            "AttrFlags": 2
          },
          {
            "Text": " on them? "
          },
          {
            "Text": "__del__",
            "AttrFlags": 2
          },
          {
            "Text": " is called any time a Python object is destroyed. However, if two objects in a circular reference have "
          },
          {
            "Text": "__del__",
            "AttrFlags": 2
          },
          {
            "Text": " methods, we can’t be sure that destroying one won’t break the others "
          },
          {
            "Text": "__del__",
            "AttrFlags": 2
          },
          {
            "Text": " method. For a contrived example, imagine we wrote the following:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550389255676,
        "id": "28e6ff73-cab7-4ea3-98db-38c93e0cf639",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550389255676,
        "parent_id": "7665b43f-7b42-437d-adb9-108709b70d11",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "class A(object):\n    def __init__(self, b=None):\n        self.b = b\n \n    def __del__(self):\n        print(\"We're deleting an instance of A containing:\", self.b)\n     \nclass B(object):\n    def __init__(self, a=None):\n        self.a = a\n \n    def __del__(self):\n        print(\"We're deleting an instance of B containing:\", self.a)"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "class A(object):\n    def __init__(self, b=None):\n        self.b = b\n \n    def __del__(self):\n        print(\"We're deleting an instance of A containing:\", self.b)\n     \nclass B(object):\n    def __init__(self, a=None):\n        self.a = a\n \n    def __del__(self):\n        print(\"We're deleting an instance of B containing:\", self.a)",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550389255677,
        "id": "cb5ded4d-874e-49a3-b892-4abdc12fc7d6",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550389255677,
        "parent_id": "7665b43f-7b42-437d-adb9-108709b70d11",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "and we set an instance of A and an instance of B to point to one another and then they end up in the same garbage collection cycle? Let’s say we pick one at random and dealloc our instance of A first; A’s "
            ],
            [
              "__del__",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " method will be called, it will print, then A will be freed. Next we come to B, we call its "
            ],
            [
              "__del__",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " method, and oops! Segfault! A no longer exists. We could fix this by calling everything that’s left over’s "
            ],
            [
              "__del__",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " methods first, then doing another pass to actually dealloc everything, however, this introduces another, issue: What if one objects "
            ],
            [
              "__del__",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " method saves a reference of the other object that’s about to be GCed and has a reference to us somewhere else? We still have a reference cycle, but now it’s not possible to actually GC either object, even if they’re no longer in use. Note that even if an object is not part of a circular data structure, it could revive itself in its own "
            ],
            [
              "__del__",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " method; Python does have a check for this and will stop GCing if an objects refcount has increased after its "
            ],
            [
              "__del__",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " method has been called."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "and we set an instance of A and an instance of B to point to one another and then they end up in the same garbage collection cycle? Let’s say we pick one at random and dealloc our instance of A first; A’s "
          },
          {
            "Text": "__del__",
            "AttrFlags": 2
          },
          {
            "Text": " method will be called, it will print, then A will be freed. Next we come to B, we call its "
          },
          {
            "Text": "__del__",
            "AttrFlags": 2
          },
          {
            "Text": " method, and oops! Segfault! A no longer exists. We could fix this by calling everything that’s left over’s "
          },
          {
            "Text": "__del__",
            "AttrFlags": 2
          },
          {
            "Text": " methods first, then doing another pass to actually dealloc everything, however, this introduces another, issue: What if one objects "
          },
          {
            "Text": "__del__",
            "AttrFlags": 2
          },
          {
            "Text": " method saves a reference of the other object that’s about to be GCed and has a reference to us somewhere else? We still have a reference cycle, but now it’s not possible to actually GC either object, even if they’re no longer in use. Note that even if an object is not part of a circular data structure, it could revive itself in its own "
          },
          {
            "Text": "__del__",
            "AttrFlags": 2
          },
          {
            "Text": " method; Python does have a check for this and will stop GCing if an objects refcount has increased after its "
          },
          {
            "Text": "__del__",
            "AttrFlags": 2
          },
          {
            "Text": " method has been called."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550389255677,
        "id": "f82a7d2a-bd7a-4769-b1ae-997d13258901",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550389255677,
        "parent_id": "7665b43f-7b42-437d-adb9-108709b70d11",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "CPython deals with this is by sticking those un-GC-able objects (anything with some form of circular reference and a "
            ],
            [
              "__del__",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " method) onto a global list of uncollectable garbage and then leaving it there for all eternity:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "CPython deals with this is by sticking those un-GC-able objects (anything with some form of circular reference and a "
          },
          {
            "Text": "__del__",
            "AttrFlags": 2
          },
          {
            "Text": " method) onto a global list of uncollectable garbage and then leaving it there for all eternity:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1550389255677,
        "id": "2df48b69-d286-48ad-9623-033456127792",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1550389255677,
        "parent_id": "7665b43f-7b42-437d-adb9-108709b70d11",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "/* list of uncollectable objects */\nstatic PyObject *garbage = NULL;"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "/* list of uncollectable objects */\nstatic PyObject *garbage = NULL;",
        "code_language": "Plain Text"
      }
    ],
    "title": "Garbage Collection"
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}