@url: https://repl.it/@kjk1/getting-started-hello-world
main.go:+74
package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}

---
@url: https://repl.it/@kjk1/getting-started-hello-world
main.go:+80
package main

import "fmt"

func main() {
	fmt.Println("Hello there, 世界")
}

---
@url: https://repl.it/@kjk1/getting-started-hello-world
main.go:+74
package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}

---
@url: https://repl.it/@kjk1/book-booleans
main.go:+229
package main

import "fmt"

func main() {
	// :show start
	var b bool = true
	fmt.Printf("b is: '%v'\n", b)
	b = false
	fmt.Printf("b is: '%v'\n", b)
	var b2 bool
	fmt.Printf("zero value of bool is: '%v'\n", b2)
	// :show end
}


---
@url: https://repl.it/@kjk1/book-booleans2
main.go:+155
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	// :show start
	b := true
	fmt.Printf("size of bool is: %d\n", unsafe.Sizeof(b))
	// :show end
}

---
@url: https://repl.it/@kjk1/book-int-to-str-itoa
main.go:+218
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// :show start
	var i1 int = -38
	fmt.Printf("i1: %s\n", strconv.Itoa(i1))

	var i2 int32 = 148
	fmt.Printf("i2: %s\n", strconv.Itoa(int(i2)))
	// :show end
}

---
@url: https://repl.it/@kjk1/book-int-to-str-sprintf
main.go:+231
package main

import (
	"fmt"
)

func main() {
	// :show start
	var i1 int = -38
	s1 := fmt.Sprintf("%d", i1)
	fmt.Printf("i1: %s\n", s1)

	var i2 int32 = 148
	s2 := fmt.Sprintf("%d", i2)
	fmt.Printf("i2: %s\n", s2)
	// :show end
}
---
@url: https://repl.it/@kjk1/book-int-from-string-atoi
main.go:+238
package main

import (
	"fmt"
	"log"
	"strconv"
)

func main() {
	// :show start
	s := "-48"
	i1, err := strconv.Atoi(s)
	if err != nil {
		log.Fatalf("strconv.Atoi() failed with %s\n", err)
	}
	fmt.Printf("i1: %d\n", i1)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-int-to-str-sscanf
main.go:+242
package main

import (
	"fmt"
	"log"
)

func main() {
	// :show start
	s := "348"
	var i int
	_, err := fmt.Sscanf(s, "%d", &i)
	if err != nil {
		log.Fatalf("fmt.Sscanf failed with '%s'\n", err)
	}
	fmt.Printf("i1: %d\n", i)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-floating-point
main.go:+336
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// :show start
	var f32 float32 = 1.3
	bitSize := 32
	s1 := strconv.FormatFloat(float64(f32), 'E', -1, bitSize)
	fmt.Printf("f32: %s\n", s1)

	var f64 float64 = 8.1234
	bitSize = 64
	s2 := strconv.FormatFloat(f64, 'e', -1, bitSize)
	fmt.Printf("f64: %s\n", s2)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-floating-point-2
main.go:+158
package main

import "fmt"

func main() {
	// :show start
	var f64 float64 = 1.54
	s := fmt.Sprintf("%f", f64)
	fmt.Printf("f is: '%s'\n", s)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-floating-point-3
main.go:+262
package main

import (
	"fmt"
	"log"
	"strconv"
)

func main() {
	// :show start
	s := "1.2341"
	f64, err := strconv.ParseFloat(s, 64)
	if err != nil {
		log.Fatalf("strconv.ParseFloat() failed with '%s'\n", err)
	}
	fmt.Printf("f64: %f\n", f64)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-floating-point-4
main.go:+248
package main

import (
	"fmt"
	"log"
)

func main() {
	// :show start
	s := "1.2341"
	var f float64
	_, err := fmt.Sscanf(s, "%f", &f)
	if err != nil {
		log.Fatalf("fmt.Sscanf failed with '%s'\n", err)
	}
	fmt.Printf("f: %f\n", f)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-characters
main.go:+191
package main

import "fmt"

func main() {
	// :show start
	s := "str"
	for i := 0; i < len(s); i++ {
		c := s[i]
		fmt.Printf("Byte at index %d is '%c' (0x%x)\n", i, c, c)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-characters-2
main.go:+188
package main

import "fmt"

func main() {
	// :show start
	s := "日本語"
	for i, runeChar := range s {
		fmt.Printf("Rune at byte position %d is %#U\n", i, runeChar)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-strings
main.go:+286
package main

import "fmt"

func main() {
	// :show start
	var s string // empty string ""
	s1 := "string\nliteral\nwith\tescape characters\n"
	s2 := `raw string literal
which doesnt't recgonize escape characters like \n
`
	fmt.Printf("sum of strings\n'%s'\n", s+s1+s2)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-constants
main.go:+414
// no output
package main

// :show start
const (
	i  int = 32       // int constant
	s      = "string" // string constant
	i2     = 33       // untyped number constant
)

var (
	// values that are not read-only (like slices or maps or structs) cannot be
	// constants
	// we can declare them as top-level variables
	b = []byte{3, 4} // this could not be a constant
)

// :show end

func main() {
	// do nothing
}

---
@url: https://repl.it/@kjk1/book-array-basics
main.go:+289
package main

import "fmt"

func main() {
	// :show start
	var a1 = [2]byte{3, 8} // array of 2 bytes
	// when using [...] size will be deduced from { ... }
	a2 := [...]int{1, 2, 3} // array of 3 integers

	fmt.Printf("Size of a1: %d.\nSize of a2: %d\n", len(a1), len(a2))
	// :show end
}

---
@url: https://repl.it/@kjk1/book-map-basics
main.go:+545
package main

import "fmt"

func main() {
	// :show start
	m := make(map[string]int)
	m["number3"] = 3

	checkKey := func(k string) {
		if n, ok := m[k]; ok {
			fmt.Printf("value for key '%s' is %d\n", k, n)
		} else {
			fmt.Printf("key '%s' doesn't exist in map\n", k)
		}
	}

	// get value for a key that exists
	checkKey("number3")

	// get value for a key that doesn't exist
	checkKey("number4")

	// remove a key
	delete(m, "number3")
	fmt.Printf("deleted key 'number3\n")
	checkKey("number3") // and now it doesn't exist
	// :show end
}

---
@url: https://repl.it/@kjk1/book-structs-basics
main.go:+182
// no output
package main

// :show start
type MyStruct struct {
	IntVal           int
	StringVal        string
	unexportedIntVal int
}

// :show end

func main() {
	// do nothing
}

---
@url: https://repl.it/@kjk1/book-pointers-basics
main.go:+180
package main

import "fmt"

func main() {
	// :show start
	var a int = 4
	pa := &a
	fmt.Printf("Address of a variable in memory is %p. Its value is: %d\n", pa, *pa)
	// :show end
}
---
@url: https://repl.it/@kjk1/book-channels-basics
main.go:+364
package main

import "fmt"

func main() {
	// :show start
	// create unbuffered channel of int values with capacity of 1
	ch := make(chan int)
	// start a new goroutine that sends value 3 over a channel
	go func() { ch <- 3 }()
	// read the value from a channel
	// it waits until goroutine above sends a value
	n := <-ch
	fmt.Printf("n: %d\n", n)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-zero-values
main.go:+1008
package main

import "fmt"

func main() {
	// :show start
	var zeroBool bool
	var zeroInt int
	var zeroF32 float32
	var zeroF64 float64
	var zeroStr string
	var zeroPtr *int
	var zeroSlice []uint32
	var zeroMap map[string]int
	var zeroInterface interface{}
	var zeroChan chan bool
	var zeroArray [5]int
	type struc struct {
		a int
		b string
	}
	var zeroStruct struc
	var zeroFunc func(bool)

  fmt.Println("zero values for basic types:")
	fmt.Printf("bool:       %v\n", zeroBool)
	fmt.Printf("int:        %v\n", zeroInt)
	fmt.Printf("float32:    %v\n", zeroF32)
	fmt.Printf("float64:    %v\n", zeroF64)
	fmt.Printf("string:     %#v\n", zeroStr)
	fmt.Printf("pointer:    %v\n", zeroPtr)
	fmt.Printf("slice:      %v\n", zeroSlice)
	fmt.Printf("map:        %#v\n", zeroMap)
	fmt.Printf("interface:  %v\n", zeroInterface)
	fmt.Printf("channel:    %v\n", zeroChan)
	fmt.Printf("array:      %v\n", zeroArray)
	fmt.Printf("struct:     %#v\n", zeroStruct)
	fmt.Printf("function:   %v\n", zeroFunc)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-type-casting-basics
main.go:+521
// no output
package main

func main() {
	// :show start
	// you can cast between numbers i.e. integers of various sizes and floating point numbers
	var i1 int32 = 3
	var i2 int = int(i1) // we must explicitly cast from int32 to int
	var f float64 = float64(i1)

	s := "string"
	// we can cast between string and []byte and vice-versa
	// note that unless optimizted by the compiler, this involves allocation
	var d []byte = []byte(s)
	// :show end

	_, _, _ = i2, f, d // silence compiler error about unused variables
}

---
@url: https://repl.it/@kjk1/book-define-variables
main.go:+1130
package main

import (
	"bytes"
	"fmt"
	"io"
)

// :show start
// declaration of a single top-level variable
var topLevel int64 = 5

// grouping of multiple top-level declarations
var (
	intVal int            // value is initialized with zero-value
	str    string = "str" // assigning

	// functions are first-class values so can be assigned to variables
	// fn is variable of type func(a int) string
	// it's uninitialized so is nil (zero-value for function variables)
	fn func(a int) string
)

func f() {
	// shorthand using local type inference
	// type of `i` is int and is inferred from the value
	// note: this is not allowed at top-level
	i := 4

	// grouping inside a function
	var (
		i2 int
		s  string
	)

	// _ is like a variable whose value is discarded. It's called blank identifier.
	// Useful when we don't care about one of the values returned by a function
	_, err := io.Copy(dst, src) // don't care how many bytes were written
	// ...

	fmt.Printf("i: %d, i2: %d, s: %s, err: %v\n", i, i2, s, err)
}

// :show end

var (
	dst io.Writer = &bytes.Buffer{}
	src io.Reader = &bytes.Buffer{}
)

func main() {
	f()
}

---
@url: https://repl.it/@kjk1/book-constants-2
main.go:+319
// no output
package main

// :show start
// Greeting is an exported (public) string constant
const Greeting string = "Hello World"

// we can group const declarations
const (
	// years is an unexported (package private) int constant
	years int  = 10
	truth bool = true
)

// :show end

func main() {
	// do  nothing
}

---
@url: https://repl.it/@kjk1/book-constants-3
main.go:+536
package main

import (
	"fmt"
	"math"
)

const s string = "constant"

func main() {
	fmt.Println(s) // constant

	// A `const` statement can appear anywhere a `var` statement can.
	const n = 10
	fmt.Println(n)                           // 10
	fmt.Printf("n=%d is of type %T\n", n, n) // n=10 is of type int

	const m float64 = 4.3
	fmt.Println(m) // 4.3

	// An untyped constant takes the type needed by its context.
	// For example, here `math.Sin` expects a `float64`.
	const x = 10
	fmt.Println(math.Sin(x)) // -0.5440211108893699
}

---
@url: https://repl.it/@kjk1/book-basic-variable
main.go:+702
// no output
package main

type Person struct {
	FirstName string
	LastName  string
}

func main() {
	// :show start
	// Basic variable declaration. Declares a variable of type specified on the right.
	// The variable is initialized to the zero value of the respective type.
	var x int
	var s string
	var p Person // Assuming type Person struct {}

	// Assignment of a value to a variable
	x = 3

	// Short declaration using := infers the type
	y := 4

	u := int64(100)    // declare variable of type int64 and init with 100
	var u2 int64 = 100 // declare variable of type int64 and init with 100
	// :show end

	// silence compiler error about unused variables
	_, _, _, _, _, _ = x, s, p, y, u, u2
}

---
@url: https://repl.it/@kjk1/book-multiple-variables
main.go:+476
// no output
package main

func main() {
	// :show start
	// You can declare multiple variables of the same type in one line
	var a, b, c string

	var d, e string = "Hello", "world!"

	// You can also use short declaration to assign multiple variables
	x, y, z := 1, 2, 3

	foo, bar := 4, "stack" // `foo` is type `int`, `bar` is type `string`
	// :show end

	// silence compiler error about unused variables
	_, _, _, _, _, _, _, _, _, _ = a, b, c, d, e, x, y, z, foo, bar
}

---
@url: https://repl.it/@kjk1/book-multiple-variable
main.go:+331
package main

import "fmt"

// :show start
func multipleReturn() (int, int) {
	return 1, 2
}

func multipleReturn2() (a int, b int) {
	a = 3
	b = 4
	return
}

func main() {
	x, y := multipleReturn()  // x = 1, y = 2
	w, z := multipleReturn2() // w = 3, z = 4
	fmt.Printf("x: %d, y: %d\nw: %d, z: %d\n", x, y, w, z)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-blank-identifier
main.go:+256
package main

import "fmt"

// :show start
func SumProduct(a, b int) (int, int) {
	return a + b, a * b
}

func main() {
	// only need the sum
	sum, _ := SumProduct(1, 2) // the product gets discarded
	fmt.Println(sum)           // prints 3
}

// :show end

---
@url: https://repl.it/@kjk1/book-blank-identifier-2
main.go:+263
package main

import "fmt"

// :show start
func main() {
	pets := []string{"dog", "cat", "fish"}

	// range returns both the current index and value
	// but sometimes we only need one or the other
	for _, pet := range pets {
		fmt.Println(pet)
	}
}

// :show end

---
@url: https://repl.it/@kjk1/book-typed-vs-untyped
main.go:+687
// allow error
package main

func main() {
	// :show start
	const untypedNumber = 345

	// if this was a variable declaration, untypedNumber would have its type
	// inferred as int.
	// since it's a const, it remains untyped until it's e.g. assigned to a variable
	var i int = untypedNumber      // no need to cast to int
	var u16 uint16 = untypedNumber // no need to cast to uint16
	var f float64 = untypedNumber  // no need to cast to float64

	// incompatible assignments are detected by the compiler
	// 345 is too big to fit in int8 and compiler detects that
	var b int8 = untypedNumber

	// :show end

	// silence compiler error about unused variables
	_, _, _, _ = i, u16, f, b
}

---
@url: https://repl.it/@kjk1/book-iota
main.go:+182

package main

import "fmt"

func main() {
	// :show start
	const (
		Low = iota
		Medium
		High
	)
	fmt.Printf("Low: %d\nMedium: %d\nHigh: %d\n", Low, Medium, High)

	// :show end
}
---
@url: https://repl.it/@kjk1/book-iota-2
main.go:+414
package main

import "fmt"

func main() {
	// :show start
	const (
		Secure = 1 << iota // 0b001
		Authn              // 0b010
		Ready              // 0b100
	)

	ConnState := Secure | Authn // 0b011: Connection is secure and authenticated, but not yet Ready

	fmt.Printf("Secure: 0x%x (0b%03b)\nAuthn: 0x%x (0b%03b)\nConnState: 0x%x (0b%03b)\n", Secure, Secure, Authn, Authn, ConnState, ConnState)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-iota-3
main.go:+310
package main

import "fmt"

func main() {
	// :show start
	const ( // iota is reset to 0
		a = 1 << iota // a == 1
		b = 1 << iota // b == 2
		c = 3         // c == 3  (iota is not used but still incremented)
		d = 1 << iota // d == 8
	)
	fmt.Printf("a: %d, b: %d, c: %d, d: %d\n", a, b, c, d)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-iota-4
main.go:+196
package main

import "fmt"

func main() {
	// :show start
	const (
		a = iota // a = 0
		_        // iota is incremented
		b        // b = 2
	)
	fmt.Printf("a: %d, b: %d\n", a, b)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-iota-5
main.go:+440
package main

import "fmt"

func main() {
	// :show start
	const (
		bit0, mask0 = 1 << iota, 1<<iota - 1 // bit0 == 1, mask0 == 0
		bit1, mask1                          // bit1 == 2, mask1 == 1
		_, _                                 // skips iota == 2
		bit3, mask3                          // bit3 == 8, mask3 == 7
	)
	fmt.Printf("bit0: %d, mask0: 0x%x\n", bit0, mask0)
	fmt.Printf("bit3: %d, mask3: 0x%x\n", bit3, mask3)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-iota-6
main.go:+263
package main

import "fmt"

func main() {
	// :show start
	type ByteSize int

	const (
		_           = iota // ignore first value by assigning to blank identifier
		KB ByteSize = 1 << (10 * iota)
		MB
		GB
		TB
		PB
	)
	fmt.Printf("KB: %d\n", KB)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-strings-basics
main.go:+677
package main

import "fmt"

func main() {
	// :show start
	var s string // empty string ""
	s1 := "string\nliteral\nwith\tescape characters"
	s2 := `raw string literal
	which doesn't recgonize escape characters like \n
	`

	// you can add strings with +
	fmt.Printf("sum of string: %s\n", s+s1+s2)

	// you can compare strings with ==
	if s1 == s2 {
		fmt.Printf("s1 is equal to s2\n")
	} else {
		fmt.Printf("s1 is not equal to s2\n")
	}

	fmt.Printf("substring of s1: %s\n", s1[3:5])
	fmt.Printf("byte (character) at position 3 in s1: %d\n", s1[3])

	// C-style string formatting
	s = fmt.Sprintf("%d + %f = %s", 1, float64(3), "4")
	fmt.Printf("s: %s\n", s)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-pointers-basics-2
main.go:+338
package main

import "fmt"

func main() {
	// :show start
	v := 5

	// pv is a pointer to v
	pv := &v
	fmt.Printf("v: %d, pv: %p\n", v, pv)

	// we change the value of v via pv
	*pv = 4
	fmt.Printf("v: %d\n", v)

	// two pointers to the same value have the same address
	pv2 := &v
	fmt.Printf("pv: %p, pv2: %p\n", pv, pv2)
	// :show end
}
---
@url: https://repl.it/@kjk1/book-array-basic
main.go:+428
package main

import "fmt"

func main() {
	// :show start
	a := [3]int{4, 5} // array of 2 ints

	// access element of array
	fmt.Printf("a[2]: %d\n", a[2])

	// set element of array
	a[1] = 3

	// get size of array
	fmt.Printf("size of array a: %d\n", len(a))

	// when using [...] size will be deduced from { ... }
	a2 := [...]int{4, 8, -1} // array of 3 integers
	fmt.Printf("size of array a2: %d\n", len(a2))
	// :show end
}
---
@url: https://repl.it/@kjk1/book-slice-basics
main.go:+334
package main

import "fmt"

func main() {
	// :show start
	slice := make([]int, 0, 5)
	// append element to end of slice
	slice = append(slice, 5)
	// append multiple elements to end
	slice = append(slice, 3, 4)
	fmt.Printf("length of slice is: %d\n", len(slice))
	fmt.Printf("capacity of slice is: %d\n", cap(slice))
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-map-basics
main.go:+999
package main

import "fmt"

func main() {
	// :show start
	// create an empty map
	m := make(map[string]int)

	// set the value
	m["three"] = 3
	m["four"] = 4

	// get the value and see if the value exists
	key := "four"
	if value, ok := m[key]; ok {
		fmt.Printf("Key '%s' exists and maps to %d\n", key, value)
	} else {
		fmt.Printf("Key '%s' doesn't exists\n", key)
	}

	key = "five"
	if value, ok := m[key]; ok {
		fmt.Printf("Key '%s' exists and maps to %d\n", key, value)
	} else {
		fmt.Printf("Key '%s' doesn't exists\n", key)
	}

	// if value doesn't exist, the result of lookup is zero value. In this case zero value of int is 0
	fmt.Printf("\nValue for non-existing key: %d\n\n", m["not-exists"])

	// iterating over keys and values
	fmt.Printf("All keys and their values:\n")
	for key, value := range m {
		fmt.Printf("%s => %d\n", key, value)
	}

	fmt.Printf("\nBefore deletion: len(m)=%d\n", len(m))
	delete(m, "four")
	fmt.Printf("After deletion: len(m)=%d\n", len(m))
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-struct-basics
main.go:+534
package main

import (
	"fmt"
)

// :show start
// Person describes a person
type Person struct {
	FirstName string
	LastName  string
}

// FullName returns full name of a person
func (p *Person) FullName() string {
	return fmt.Sprintf("%s %s", p.FirstName, p.LastName)
}

func main() {
	// zero value of struct
	var p Person
	fmt.Printf("p: %v\n\n", p)

	p = Person{
		FirstName: "John",
		LastName:  "Doe",
	}
	fmt.Printf("p: %v\n\n", p)

	// call a method on a struct
	fmt.Printf("p.FullName(): %s\n", p.FullName())
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-interface-basics
main.go:+776
package main

import (
	"fmt"
	"strconv"
)

// :show start
// Stringer is an interface with a single method
type Stringer interface {
	String() string
}

// User struct that implements Stringer interface
type User struct {
	Name string
}

func (u *User) String() string {
	return u.Name
}

// Any type can implement an interface. Here we create
// an alias of int type an implement Stringer interface

type MyInt int

func (mi MyInt) String() string {
	return strconv.Itoa(int(mi))
}

// printTypeAndString accepts an interface. 's' can be any value
// that implements Stringer interface
func printTypeAndString(s Stringer) {
	fmt.Printf("%T: %s\n", s, s)
}

func main() {
	u := &User{Name: "John"}
	printTypeAndString(u)

	n := MyInt(5)
	printTypeAndString(n)
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-empty-interface-basics
main.go:+428
package main

import (
	"fmt"
)

// :show start
func printVariableType(v interface{}) {
	switch v.(type) {
	case string:
		fmt.Printf("v is of type 'string'\n")
	case int:
		fmt.Printf("v is of type 'int'\n")
	default:
		// generic fallback
		fmt.Printf("v is of type '%T'\n", v)
	}
}

func main() {
	printVariableType("string") // string
	printVariableType(5)        // int
	printVariableType(int32(5)) // int32
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-if-basics
main.go:+186

package main

import "fmt"

func main() {
	// :show start
	a := 5
	b := 6
	if a == b {
		fmt.Print("a is equal to b\n")
	} else {
		fmt.Print("a is not equal to b\n")
	}
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-switch-basics
main.go:+280

package main

import "fmt"

func main() {
	// :show start
	stmt := "if"
	switch stmt {
	case "if", "for":
		fmt.Printf("stmt ('%s') is either 'if' or 'for'\n", stmt)
	case "else":
		fmt.Printf("stmt is 'else'\n")
	default:
		fmt.Printf("stmt is '%s'\n", stmt)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-finding-strings
main.go:+377
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "where hello is?"
	toFind := "hello"
	idx := strings.Index(s, toFind)
	fmt.Printf("'%s' is in s starting at position %d\n", toFind, idx)

	// when string is not found, result is -1
	idx = strings.Index(s, "not present")
	fmt.Printf("Index of non-existent substring is: %d\n", idx)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-finding-strings-2
main.go:+260
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "hello and second hello"
	toFind := "hello"
	idx := strings.LastIndex(s, toFind)
	fmt.Printf("when searching from end, '%s' is in s at position %d\n", toFind, idx)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-finding-strings-3
main.go:+360
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "first is, second is, third is"
	toFind := "is"
	currStart := 0
	for {
		idx := strings.Index(s, toFind)
		if idx == -1 {
			break
		}
		fmt.Printf("found '%s' at position %d\n", toFind, currStart+idx)
		currStart += idx + len(toFind)
		s = s[idx+len(toFind):]
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-finding-strings-4
main.go:+283
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "is hello there?"
	toFind := "hello"
	if strings.Contains(s, toFind) {
		fmt.Printf("'%s' contains '%s'\n", s, toFind)
	} else {
		fmt.Printf("'%s' doesn't contain '%s'\n", s, toFind)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-finding-strings-5
main.go:+288
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "this is string"
	toFind := "this"
	if strings.HasPrefix(s, toFind) {
		fmt.Printf("'%s' starts with '%s'\n", s, toFind)
	} else {
		fmt.Printf("'%s' doesn't start with '%s'\n", s, toFind)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-finding-strings-6
main.go:+285
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "this is string"
	toFind := "string"
	if strings.HasSuffix(s, toFind) {
		fmt.Printf("'%s' ends with '%s'\n", s, toFind)
	} else {
		fmt.Printf("'%s' doesn't end with '%s'\n", s, toFind)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/book-comparing-strings
main.go:+547
package main

import (
	"fmt"
)

func main() {
	// :show start
	s1 := "string one"
	s2 := "string two"

	if s1 == s2 {
		fmt.Printf("s1 is equal to s2\n")
	} else {
		fmt.Printf("s1 is not equal to s2\n")
	}

	if s1 == s1 {
		fmt.Printf("s1 is equal to s1\n")
	} else {
		fmt.Printf("inconcivable! s1 is not equal to itself\n")
	}

	if s1 > s2 {
		fmt.Printf("s1 is > than s2\n")
	} else {
		fmt.Printf("s1 is not > than s2\n")
	}

	if s1 < s2 {
		fmt.Printf("s1 is < than s2\n")
	} else {
		fmt.Printf("s1 is not < than s2\n")
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-comparing-strings-2
main.go:+295
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s1 := "gone"
	s2 := "GoNe"
	if strings.EqualFold(s1, s2) {
		fmt.Printf("'%s' is equal '%s' when ignoring case\n", s1, s2)
	} else {
		fmt.Printf("'%s' is not equal '%s' when ignoring case\n", s1, s2)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-strings-convert-case
main.go:+271
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "Mixed Case"
	fmt.Printf("ToLower(s): '%s'\n", strings.ToLower(s))
	fmt.Printf("ToUpper(s): '%s'\n", strings.ToUpper(s))
	fmt.Printf("ToTitle(s): '%s'\n", strings.ToTitle(s))
	// :show end
}

---
@url: https://repl.it/@kjk1/book-convert-to-number
main.go:+917
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// :show start
	s := "234"
	i, err := strconv.Atoi(s)
	if err != nil {
		fmt.Printf("strconv.Atoi() failed with: '%s'\n", err)
	}
	fmt.Printf("strconv.Atoi('%s'): %d\n", s, i)

	i, err = strconv.Atoi("not a number")
	if err != nil {
		fmt.Printf("strconv.Atoi('not a number') failed with: '%s'\n", err)
	}

	i64, err := strconv.ParseInt(s, 10, 64)
	if err != nil {
		fmt.Printf("strconv.ParseInt() failed with: '%s'\n", err)
	}
	fmt.Printf("strconv.ParseInt('%s', 64): %d\n", s, i64)

	s = "-3.234"
	f64, err := strconv.ParseFloat(s, 64)
	if err != nil {
		fmt.Printf("strconv.ParseFloat() failed with: '%s'\n", err)
	}
	fmt.Printf("strconv.ParseFloat('%s', 64): %g\n", s, f64)

	var f2 float64
	_, err = fmt.Sscanf(s, "%f", &f2)
	if err != nil {
		fmt.Printf("fmt.Sscanf() failed with: '%s'\n", err)
	}
	fmt.Printf("fmt.Sscanf(): %g\n", f2)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-strings-tirm
main.go:+672
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "  str  "
	fmt.Printf("TrimSpace('%s'): '%s'\n\n", s, strings.TrimSpace(s))

	s = "abacdda"
	cutset := "ab"
	fmt.Printf("Trim('%s', '%s'): '%s'\n\n", s, cutset, strings.Trim(s, cutset))

	fmt.Printf("TrimLeft('%s', '%s'): '%s'\n\n", s, cutset, strings.TrimLeft(s, cutset))

	fmt.Printf("TrimRight('%s', '%s'): '%s'\n\n", s, cutset, strings.TrimRight(s, cutset))

	suffix := "ab"
	fmt.Printf("TrimSuffix('%s', '%s'): '%s'\n\n", s, suffix, strings.TrimSuffix(s, suffix))

	prefix := "ab"
	fmt.Printf("TrimPrefix('%s', '%s'): '%s'\n\n", s, prefix, strings.TrimPrefix(s, prefix))
	// :show end
}

---
@url: https://repl.it/@kjk1/book-string-split-join
main.go:+229

package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "this is a string"
	a := strings.Split(s, " ")
	fmt.Printf("a: %#v\n", a)

	s2 := strings.Join(a, ",")
	fmt.Printf("s2: %#v\n", s2)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-formatting-text
main.go:+213
package main

import (
	"fmt"
)

func main() {
	// :show start
	s := fmt.Sprintf("Hello %s", "World")
	fmt.Printf("s: '%s'\n", s)
	s = fmt.Sprintf("%d + %f = %d", 2, float64(3), 5)
	fmt.Println(s)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-parse-sscanf
main.go:+498
package main

import (
	"fmt"
	"log"
)

func main() {
	// :show start
	// extract int and float from a string
	s := "48 123.45"
	var f float64
	var i int
	nParsed, err := fmt.Sscanf(s, "%d %f", &i, &f)
	if err != nil {
		log.Fatalf("first fmt.Sscanf failed with %s\n", err)
	}
	fmt.Printf("i: %d, f: %f, extracted %d values\n", i, f, nParsed)

	var i2 int
	_, err = fmt.Sscanf(s, "%d %f %d", &i, &f, &i2)
	if err != nil {
		fmt.Printf("second fmt.Sscanf failed with %s\n", err)
	}

	// :show end
}

---
@url: https://repl.it/@kjk1/book-strings-parse-split
main.go:+177
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "this,. is,. a,. string"
	a := strings.Split(s, ",.")
	fmt.Printf("a: %#v\n", a)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-string-replace
main.go:+207
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "original string original"
	s2 := strings.Replace(s, "original", "replaced", -1)
	fmt.Printf("s2: '%s'\n", s2)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-strings-replace-regex
main.go:+234
package main

import (
	"fmt"
	"regexp"
)

func main() {
	// :show start
	s := "original string original"
	rx := regexp.MustCompile("(?U)or.*al")
	s2 := rx.ReplaceAllString(s, "replaced")
	fmt.Printf("s2: '%s'\n", s2)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-read-file-as-lines
main.go:+558
package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"strings"
)

// :show start
// ReadFileAsLines reads a file and splits it into lines
func ReadFileAsLines(path string) ([]string, error) {
	d, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}
	s := string(d)
	lines := strings.Split(s, "\n")
	return lines, nil
}

// :show end

func main() {
	path := "main.go"
	lines, err := ReadFileAsLines(path)
	if err != nil {
		log.Fatalf("ReadFileAsLines() failed with '%s'\n", err)
	}
	fmt.Printf("There are %d lines in '%s'\n", len(lines), path)
}

---
@url: https://repl.it/@kjk1/book-iter-lines-in-file
main.go:+792
package main

import (
  "fmt"
  "os"
  "bufio"
)

// :show start
func IterLinesInFile(filePath string, process func (s string) bool) error {
    file, err := os.Open(filePath)
    if err != nil {
        return err
    }
    defer file.Close()
    scanner := bufio.NewScanner(file)
    // Scan() reads next line and returns false when reached end or error
    for scanner.Scan() {
        line := scanner.Text()
        if !process(line) {
          return nil
        }
        // process the line
    }
    // check if Scan() finished because of error or because it reached end of file
    return scanner.Err()
}
// :show end

func main() {
  nLines := 0
  IterLinesInFile("main.go", func(s string) bool {
    nLines++
    return true
  })
  fmt.Printf("%d lines in 'main.go'\n", nLines)
}
---
@url: https://repl.it/@kjk1/book-normalize-newlines
main.go:+503
package main

import (
	"bytes"
	"fmt"
)

// :show start
// NormalizeNewLines normalizes \r\n (windows) and \r (mac)
// into \n (unix)
func NormalizeNewlines(d []byte) []byte {
	// replace CR LF \r\n (windows) with LF \n (unix)
	d = bytes.Replace(d, []byte{13, 10}, []byte{10}, -1)
	// replace CF \r (mac) with LF \n (unix)
	d = bytes.Replace(d, []byte{13}, []byte{10}, -1)
	return d
}

// :show end

func main() {
	d := []byte("new\r\nline")
	d = NormalizeNewlines(d)
	fmt.Printf("%#v\n", string(d))
}

---
@url: https://repl.it/@kjk1/book-pointers-basic
main.go:+746
// no output
package main

// :show start

// We'll show how pointers work in contrast to values with
// 2 functions: `zeroval` and `zeroptr`. `zeroval` has an
// `int` parameter, so arguments will be passed to it by
// value. `zeroval` will get a copy of `ival` distinct
// from the one in the calling function.
func zeroval(ival int) {
	ival = 0
}

// `zeroptr` in contrast has an `*int` parameter, meaning
// that it takes an `int` pointer. The `*iptr` code in the
// function body then _dereferences_ the pointer from its
// memory address to the current value at that address.
// Assigning a value to a dereferenced pointer changes the
// value at the referenced address.
func zeroptr(iptr *int) {
	*iptr = 0
}

// :show end

func main() {
}
---
@url: https://repl.it/@kjk1/book-pointers-basic-2
main.go:+1163
package main

import "fmt"

// We'll show how pointers work in contrast to values with
// 2 functions: `zeroval` and `zeroptr`. `zeroval` has an
// `int` parameter, so arguments will be passed to it by
// value. `zeroval` will get a copy of `ival` distinct
// from the one in the calling function.
func zeroval(ival int) {
	ival = 0
}

// `zeroptr` in contrast has an `*int` parameter, meaning
// that it takes an `int` pointer. The `*iptr` code in the
// function body then _dereferences_ the pointer from its
// memory address to the current value at that address.
// Assigning a value to a dereferenced pointer changes the
// value at the referenced address.
func zeroptr(iptr *int) {
	*iptr = 0
}

func main() {
	// :show start
	i := 1
	fmt.Println("initial:", i)

	zeroval(i)
	fmt.Println("zeroval:", i)
	// `i` is still equal to 1 because `zeroval` edited
	// a "copy" of `i`, not the original.

	// The `&i` syntax gives the memory address of `i`,
	// i.e. a pointer to `i`. When calling `zeroptr`,
	// it will edit the "original" `i`.
	zeroptr(&i)
	fmt.Println("zeroptr:", i)

	// Pointers can be printed too.
	fmt.Println("pointer:", &i)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-pointer-dereference
main.go:+481
package main

import "fmt"

// :show start
type Person struct {
	Name string
}

func main() {
	c := new(Person) // returns pointer
	c.Name = "Catherine"
	fmt.Println(c.Name) // prints: Catherine
	d := c
	d.Name = "Daniel"
	fmt.Println(c.Name) // prints: Daniel
	// Adding an Asterix before a pointer dereferences the pointer
	i := *d
	i.Name = "Ines"
	fmt.Println(c.Name) // prints: Daniel
	fmt.Println(d.Name) // prints: Daniel
	fmt.Println(i.Name) // prints: Ines
	// :show end
}
---
@url: https://repl.it/@kjk1/book-pointer-methods
main.go:+518

package main

import "fmt"

// :show start
type Foo struct {
	Bar int
}

func (f *Foo) Increment() {
	f.Bar++
}

func main() {
	var f Foo

	// Calling `f.Increment` is automatically changed to `(&f).Increment` by the compiler.
	f = Foo{}
	fmt.Printf("f.Bar is %d\n", f.Bar)
	f.Increment()
	fmt.Printf("f.Bar is %d\n", f.Bar)

	// As you can see, calling `(&f).Increment` directly does the same thing.
	f = Foo{}
	fmt.Printf("f.Bar is %d\n", f.Bar)
	(&f).Increment()
	fmt.Printf("f.Bar is %d\n", f.Bar)
}

// :show end
---
@url: https://repl.it/@kjk1/book-value-methods
main.go:+655
package main

import "fmt"

// :show start
type Foo struct {
	Bar int
}

func (f Foo) Increment() {
	f.Bar++
}

func main() {
	var p *Foo

	// Calling `p.Increment` is automatically changed to `(*p).Increment` by the compiler.
	// (Note that `*p` is going to remain at 0 because a copy of `*p`, and not the original `*p` are being edited)
	p = &Foo{}
	fmt.Printf("(*p).Bar is %d\n", (*p).Bar)
	p.Increment()
	fmt.Printf("(*p).Bar is %d\n", (*p).Bar)

	// As you can see, calling `(*p).Increment` directly does the same thing.
	p = &Foo{}
	fmt.Printf("(*p).Bar is %d\n", (*p).Bar)
	(*p).Increment()
	fmt.Printf("(*p).Bar is %d\n", (*p).Bar)
}

// :show end
---
@url: https://repl.it/@kjk1/book-array-create
main.go:+1534
package main

import "fmt"

func main() {
	// :show start
	// Creating arrays of 6 elements of type int,
	// and put elements 1, 2, 3, 4, 5 and 6 inside it, in this exact order:
	var array1 = [6]int{1, 2, 3, 4, 5, 6}   // classical way
	var array2 = [6]int{1, 2, 3, 4, 5, 6}   // a less verbose way
	var array3 = [...]int{1, 2, 3, 4, 5, 6} // the compiler will count the array elements by itself

	fmt.Println("array1:", array1) // > [1 2 3 4 5 6]
	fmt.Println("array2:", array2) // > [1 2 3 4 5 6]
	fmt.Println("array3:", array3) // > [1 2 3 4 5 6]

	// Creating arrays with default values inside:
	zeros := [8]int{}       // Create a list of 8 int filled with 0
	ptrs := [8]*int{}       // a list of int pointers, filled with 8 nil references ( <nil> )
	emptystr := [8]string{} // a list of string filled with 8 times ""

	fmt.Println("zeroes:", zeros)      // > [0 0 0 0 0 0 0 0]
	fmt.Println("ptrs:", ptrs)         // > [<nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil>]
	fmt.Println("emptystr:", emptystr) // > [       ]
	// values are empty strings, separated by spaces,
	// so we can just see separating spaces

	// Arrays are also working with a personalized type
	type Data struct {
		Number int
		Text   string
	}

	// Creating an array with 8 'Data' elements
	// All the 8 elements will be like {0, ""} (Number = 0, Text = "")
	structs := [8]Data{}

	fmt.Println("structs:", structs) // > [{0 } {0 } {0 } {0 } {0 } {0 } {0 } {0 }]
	// prints {0 } because Number are 0 and Text are empty; separated by a space
	// :show end
}
---
@url: https://repl.it/@kjk1/book-array-indexes
main.go:+492

package main

import "fmt"

func main() {
	// :show start
	var array = [6]int{1, 2, 3, 4, 5, 6}

	// doesn't work: invalid array index -1 (index must be non-negative)
	// fmt.Println(array[-42])
	fmt.Println(array[0]) // > 1
	fmt.Println(array[1]) // > 2
	fmt.Println(array[2]) // > 3
	fmt.Println(array[3]) // > 4
	fmt.Println(array[4]) // > 5
	fmt.Println(array[5]) // > 6
	// doesn't work: invalid array index 6 (out of bounds for 6-element array)
	//fmt.Println(array[6])
	// :show end
}
---
@url: https://repl.it/@kjk1/book-array-indexes-2
main.go:+475
package main

import "fmt"

func main() {
	// :show start
	var array = [6]int{1, 2, 3, 4, 5, 6}

	fmt.Println(array) // > [1 2 3 4 5 6]

	array[0] = 6
	fmt.Println(array) // > [6 2 3 4 5 6]

	array[1] = 5
	fmt.Println(array) // > [6 5 3 4 5 6]

	array[2] = 4
	fmt.Println(array) // > [6 5 4 4 5 6]

	array[3] = 3
	fmt.Println(array) // > [6 5 4 3 5 6]

	array[4] = 2
	fmt.Println(array) // > [6 5 4 3 2 6]

	array[5] = 1
	fmt.Println(array) // > [6 5 4 3 2 1]
	// :show end
}
---
@url: https://repl.it/@kjk1/book-array-multidimension
main.go:+688
package main

import "fmt"

func main() {
	// :show start
	// Defining a 2d Array to represent a matrix like
	// 1 2 3     So with 2 lines and 3 columns;
	// 4 5 6
	multiDimArray := [2] /*lines*/ [3] /*columns*/ int{[3]int{1, 2, 3}, [3]int{4, 5, 6}}

	// That can be simplified like this:
	var simplified = [2][3]int{{1, 2, 3}, {4, 5, 6}}

	// What does it looks like ?
	fmt.Println(multiDimArray)
	// > [[1 2 3] [4 5 6]]

	fmt.Println(multiDimArray[0])
	// > [1 2 3]    (first line of the array)

	fmt.Println(multiDimArray[0][1])
	// > 2          (cell of line 0 (the first one), column 1 (the 2nd one))

	// :show end

	// silence compiler error about unused variable
	_ = simplified
}
---
@url: https://repl.it/@kjk1/book-array-multidimension-2
main.go:+778

package main

import "fmt"

func main() {
	// :show start
	// We can also define array with as much dimensions as we need
	// here, initialized with all zeros
	var multiDimArray = [2][4][3][2]string{}

	// the data is:
	// > [[[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]]
	//   [[[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]]
	// :show end

	fmt.Printf("%#v\n", multiDimArray)
}
---
@url: https://repl.it/@kjk1/book-array-multidimension-3
main.go:+937
package main

import "fmt"

func main() {
	// :show start

	var multiDimArray = [2][4][3][2]string{}

	// We can set some values in the array's cells
	multiDimArray[0][0][0][0] = "All zero indexes"   // Setting the first value
	multiDimArray[1][3][2][1] = "All indexes to max" // Setting the value at extreme location

	// The data looks like:
	// > [[[["All zero indexes" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]]
	//   [[[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" "All indexes to max"]]]]

	// :show end

	fmt.Printf("%#v\n", multiDimArray)
}
---
@url: https://repl.it/@kjk1/book-slice-add
main.go:+176
package main

import "fmt"

func main() {
	// :show start
	a := []string{"!"}
	a2 := []string{"Hello", "world"}
	a = append(a, a2...)
	fmt.Printf("a: %#v\n", a)
	// :show end
}
---
@url: https://repl.it/@kjk1/book-slice-filter-simple
main.go:+333
package main

import "fmt"

// :show start
func filterEvenValues(a []int) []int {
	var res []int
	for _, el := range a {
		if el%2 == 0 {
			continue
		}
		res = append(res, el)
	}
	return res
}

// :show end

func main() {
	// :show start
	a := []int{1, 2, 3, 4}
	res := filterEvenValues(a)
	fmt.Printf("%#v\n", res)
	// :show end
}
---
@url: https://repl.it/@kjk1/book-slice-filter
main.go:+399
package main

import "fmt"

func filterEvenValuesInPlace(a []int) []int {
	// create a zero-length slice with the same underlying array
	res := a[:0]

	for _, v := range a {
		if v%2 == 0 {
			// collect only wanted values
			res = append(res, v)
		}
	}
	return res
}

func main() {
	// :show start
	a := []int{1, 2, 3, 4}
	res := filterEvenValuesInPlace(a)
	fmt.Printf("%#v\n", res)
	// :show end
}
---
@url: https://repl.it/@kjk1/book-slice-duplicate
main.go:+205
package main

import "fmt"

func main() {
	// :show start
	src := []int{1, 2, 3}
	dst := make([]int, len(src))
	copy(dst, src)
	fmt.Printf("src: %#v\n", src)
	fmt.Printf("dst: %#v\n", dst)
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-map-zero-value
main.go:+176
package main

import "fmt"

func main() {
	// :show start
	var m map[string]string
	fmt.Printf("m == nil ? %v\n", m == nil)
	fmt.Printf("len(m) = %d\n", len(m))
	// :show end
}
---
@url: https://repl.it/@kjk1/gobok-map-zero-value-2
main.go:+310
// allow error
package main

import "fmt"

func main() {
	// :show start
	var m map[string]string

	// you can read read from un-initialized map
	fmt.Printf(`m["foo"] = %s`+"\n", m["foo"])
	_, ok := m["foo"]
	fmt.Printf("ok: %v\n", ok)

	// writing to uninitialized map panics
	m["foo"] = "bar"
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-map-copy
main.go:+218
// no output
package main

func main() {
	// :show start
	src := make(map[string]int)
	src["one"] = 1
	src["two"] = 2

	dst := make(map[string]int)

	for key, value := range src {
		dst[key] = value
	}

	// :show end
}
---
@url: https://repl.it/@kjk1/book-map-iterate-key-value
main.go:+233
package main

import "fmt"

func main() {
	// :show start
	people := map[string]int{
		"john": 30,
		"jane": 29,
		"mark": 11,
	}

	for key, value := range people {
		fmt.Printf("key: %s, value: %d\n", key, value)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/go-book-iterate-keys
main.go:+208
package main

import "fmt"

func main() {
	// :show start
	people := map[string]int{
		"john": 30,
		"jane": 29,
		"mark": 11,
	}

	for key := range people {
		fmt.Printf("key: %s\n", key)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/go-book-iterate-values
main.go:+217
package main

import "fmt"

func main() {
	// :show start
	people := map[string]int{
		"john": 30,
		"jane": 29,
		"mark": 11,
	}

	for _, value := range people {
		fmt.Printf("value: %d\n", value)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-map-as-set
main.go:+367
package main

import "fmt"

func main() {
	// :show start
	greetings := map[string]struct{}{
		"hi":    {},
		"hello": {},
	}

	// delete a value from set
	delete(greetings, "hi")

	// add a value to set
	greetings["hey"] = struct{}{}

	// check if a value is in the set:
	if _, ok := greetings["hey"]; ok {
		fmt.Printf("'hey' is in greetings\n")
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-map-concurrent
main.go:+947
// no output
package main

import "sync"

type RWMap struct {
	sync.RWMutex
	m map[string]int
}

// Get is a wrapper for getting the value from the underlying map
func (r *RWMap) Get(key string) int {
	r.RLock()
	defer r.RUnlock()
	return r.m[key]
}

// Set is a wrapper for setting the value of a key in the underlying map
func (r *RWMap) Set(key string, val int) {
	r.Lock()
	defer r.Unlock()
	r.m[key] = val
}

// Inc increases the value in the RWMap for a key.
//   This is more pleasant than r.Set(key, r.Get(key)++)
func (r *RWMap) Inc(key string) {
	r.Lock()
	defer r.Unlock()
	r.m[key]++
}

func main() {

	counter := RWMap{m: make(map[string]int)}

	// Get a Read Lock
	counter.RLock()
	_ = counter.Get("Key")
	counter.RUnlock()

	// the above could be replaced with
	_ = counter.Get("Key")

	// Get a write Lock
	counter.Lock()
	counter.m["some_key"]++
	counter.Unlock()

	// above would need to be written as
	counter.Inc("some_key")
}

---
@url: https://repl.it/@kjk1/gobook-struct-declare
main.go:+726
package main

import (
	"fmt"
)

// :show start
// User describes a user
type User struct {
	FirstName, LastName string
	Email               string
	Age                 int
	userID              int
}

// FullName returns full name of a user
func (u *User) FullName() string {
	return fmt.Sprintf("%s %s", u.FirstName, u.LastName)
}

func main() {
	// zero value of struct
	var u User
	fmt.Printf("u: %#v\n\n", u)

	// pu is *User i.e. a pointer to User struct
	pu := new(User)
	pu.Age = 33
	fmt.Printf("*pu: %#v\n", *pu)

	// &User{} is the same as new(User)
	pu = &User{}
	pu.Age = 18
	fmt.Printf("*pu: %#v\n", *pu)

	pu.FirstName, pu.LastName = "Jane", "Doe"
	fmt.Printf("pu.FullName(): %s\n", pu.FullName())
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-struct-anonymous
main.go:+186
package main

import "fmt"

func main() {
	// :show start
	data := struct {
		Number int
		Text   string
	}{
		42,
		"Hello world!",
	}

	fmt.Printf("data: %+v\n", data)
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-struct-methods
main.go:+296
package main

import "fmt"

// :show start

type User struct {
	name string
}

func (u User) Name() string {
	return u.name
}

func (u *User) SetName(newName string) {
	u.name = newName
}

func main() {
	var me User

	me.SetName("Slim Shady")
	fmt.Println("My name is", me.Name())
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-interface-verify-implements
main.go:+227
// allow error
package main

import "io"

// :show start
type MyReadCloser struct {
}

func (rc *MyReadCloser) Read(d []byte) (int, error) {
	return 0, nil
}

var _ io.ReadCloser = &MyReadCloser{}

// :show end

func main() {
}
---
@url: https://repl.it/@kjk1/gobook-interface-type-assertion
main.go:+745
// allow error
package main

import (
	"fmt"
)

// :show start
func printTypeAndValue(iv interface{}) {
	if v, ok := iv.(string); ok {
		fmt.Printf("iv is of type string and has value '%s'\n", v)
		return
	}
	if v, ok := iv.(int); ok {
		fmt.Printf("iv is of type int and has value '%d'\n", v)
		return
	}
	if v, ok := iv.(*int); ok {
		fmt.Printf("iv is of type *int and has value '%s'\n", v)
		return
	}
}

func panicOnInvalidConversion() {
	var iv interface{} = "string"

	v := iv.(int)
	fmt.Printf("v is int of value: %d\n", v)
}

func main() {
	// pass a string
	printTypeAndValue("string")
	i := 5
	// pass an int
	printTypeAndValue(i)
	// pass a pointer to int i.e. *int
	printTypeAndValue(&i)

	panicOnInvalidConversion()
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-interface-type-assertion-2
main.go:+236
// allow error
package main

import (
	"fmt"
)

// :show start
func panicOnInvalidConversion(iv interface{}) {
	v := iv.(int)
	fmt.Printf("v is int of value: %d\n", v)
}

func main() {
	panicOnInvalidConversion("string")
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-interface-type-switch
main.go:+748
package main

import (
	"fmt"
	"strconv"
)

// :show start
func smartConvertToInt(iv interface{}) (int, error) {
	// inside case statements, v is of type matching case type
	switch v := iv.(type) {
	case int:
		return v, nil
	case string:
		return strconv.Atoi(v)
	case float64:
		return int(v), nil
	default:
		return 0, fmt.Errorf("unsupported type: %T", iv)
	}
}

func printSmartConvertToInt(iv interface{}) {
	i, err := smartConvertToInt(iv)
	if err != nil {
		fmt.Printf("Failed to convert %#v to int\n", iv)
		return
	}
	fmt.Printf("%#v of type %T converted to %d\n", iv, iv, i)
}

func main() {
	printSmartConvertToInt("5")
	printSmartConvertToInt(4)
	printSmartConvertToInt(int32(8))
	printSmartConvertToInt("not valid int")
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-if
main.go:+461
package main

import "fmt"

// :show start
func retVals(ok bool) (int, bool) {
	return 5, ok
}

func main() {
	a := 5
	b := 5
	if a == b {
		fmt.Print("a is equal to b\n")
	} else {
		fmt.Print("a is not equal to b\n")
	}

	if n, ok := retVals(true); ok {
		fmt.Print("ok is true, n: %d\n", n)
	} else {
		fmt.Print("ok is false, n: %d\n", n)
	}

	// n is only visible within if loop, so this would fail compilation
	// fmt.Printf("n: %d\n", n)
}

// :show end

---
@url: https://repl.it/@kjk1/gobook-case
main.go:+221

package main

import "fmt"

func main() {
	// :show start
	a := 1
	switch a {
	case 1, 3:
		fmt.Printf("a is 1 or 3\n")
	case 2:
		fmt.Printf("a is 2\n")
	default:
		fmt.Printf("default: a is %d\n", a)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-fallthrough
main.go:+178
package main

import "fmt"

func main() {
	// :show start
	a := 1
	switch a {
	case 1:
		fmt.Printf("case 1\n")
		fallthrough
	case 2:
		fmt.Printf("caes 2\n")
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-switch-strings
main.go:+184
package main

import "fmt"

func main() {
	// :show start
	s := "foo"
	switch s {
	case "foo":
		fmt.Printf("s is 'foo'\n")
	case "bar":
		fmt.Printf("s is 'bar'\n")
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-switch-empty
main.go:+350
package main

import (
	"fmt"
)

// :show start
func check(n int) {
	switch {
	case n > 0 && n%3 == 0:
		fmt.Printf("n is %d, divisible by 3\n", n)
	case n >= 4:
		fmt.Printf("n is %d (>= 4)\n", n)
	default:
		fmt.Printf("default: n is %d\n", n)
	}
}

// :show end
func main() {
	// :show start
	check(3)
	check(4)
	check(6)
	check(1)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-switch-assign
main.go:+392
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	// without seeding rand.Intn will always return the same sequence
	rand.Seed(time.Now().UnixNano())
	// :show start
	switch n := rand.Intn(9); n {
	case 1, 2, 3:
		fmt.Printf("case 1, 2, 3: n is %d\n", n)
	case 4, 5:
		fmt.Printf("case 4, 5: n is %d\n", n)
	default:
		fmt.Printf("default: n is %d\n", n)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-goto
main.go:+269
package main

import "fmt"

// :show start
func printIsOdd(n int) {
	if n%2 == 1 {
		goto isOdd
	}
	fmt.Printf("%d is even\n", n)
	return

isOdd:
	fmt.Printf("%d is odd\n", n)
}

// :show end

func main() {
	// :show start
	printIsOdd(5)
	printIsOdd(18)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-goto-2
main.go:+137
// allow error
package main

import "fmt"

func main() {
	// :show start
	goto end
	a := 3
	fmt.Printf("a: %d\n", a)
end:
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-for
main.go:+133
package main

import "fmt"

func main() {
	// :show start
	for i := 0; i < 5; i += 2 {
		fmt.Printf("i: %d\n", i)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-for-2
main.go:+135
package main

import "fmt"

func main() {
	// :show start
	i := 0
	for ; i < 5; i += 2 {
		fmt.Printf("i: %d\n", i)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-for-3
main.go:+158

package main

import "fmt"

func main() {
	// :show start
	i := 0
	for ; ; i += 2 {
		fmt.Printf("i: %d\n", i)
		if i >= 5 {
			break
		}
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-for-4
main.go:+134
package main

import "fmt"

func main() {
	// :show start
	for i := 0; i < 5; {
		fmt.Printf("i: %d\n", i)
		i += 2
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-for-5
main.go:+157

package main

import "fmt"

func main() {
	// :show start
	i := 0
	for {
		fmt.Printf("i: %d\n", i)
		i += 2
		if i >= 5 {
			break
		}
	}

	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-for-6
main.go:+176
package main

import "fmt"

func main() {
	// :show start
	a := []int{1, 3, 5}
	for idx, value := range a {
		fmt.Printf("idx: %d, value: %d\n", idx, value)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-range-string-basic
main.go:+171
package main

import "fmt"

func main() {
	// :show start
	s := "Hey 世界"
	for idx, rune := range s {
		fmt.Printf("idx: %d, rune: %d\n", idx, rune)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-range-slice-basic
main.go:+173
package main

import "fmt"

func main() {
	// :show start
	a := []int{3, 15, 8}
	for idx, el := range a {
		fmt.Printf("idx: %d, element: %d\n", idx, el)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-range-map-basics
main.go:+208
package main

import "fmt"

func main() {
	// :show start
	m := map[string]int{
		"three": 3,
		"five":  5,
	}
	for key, value := range m {
		fmt.Printf("key: %s, value: %d\n", key, value)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-function-basics
main.go:+552
package main

import (
	"fmt"
)

// :show start
// addCheckOverflow adds two int16 numbers and additionally
// returns true if the result overflowed
func addCheckOverflow(a, b uint16) (uint16, bool) {
	res := a + b
	overflowed := res < a || res < b
	return res, overflowed
}

func main() {
	res, overflowed := addCheckOverflow(1, 3)
	fmt.Printf("%5d + %5d = %5d, overflowed: %v\n\n", 1, 3, res, overflowed)
	res, overflowed = addCheckOverflow(65520, 10000)
	fmt.Printf("%5d + %5d = %5d, overflowed: %v\n", 65550, 10000, res, overflowed)
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-methods-basics
main.go:+274
package main

import "fmt"

// :show start
type Person struct {
	FirstName string
	LastName  string
}

func (p *Person) PrintFullName() {
	fmt.Printf("%s %s\n", p.FirstName, p.LastName)
}

func main() {
	p := &Person{
		"John",
		"Doe",
	}
	p.PrintFullName()
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-methods-value-vs-pointer
main.go:+490
package main

import "fmt"

// :show start
type Person struct {
	FirstName string
	LastName  string
}

func (p Person) PrintFullNameValue() {
	fmt.Printf("PrintFullNameValue:   address of p is %p\n", &p)
}

func (p *Person) PrintFullNamePointer() {
	fmt.Printf("PrintFullNamePointer: p is            %p\n", p)
}

func main() {
	p := Person{
		"John",
		"Doe",
	}
	fmt.Printf("address of p:                         %p\n", &p)
	p.PrintFullNamePointer()
	p.PrintFullNameValue()
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-error-handilng-basics
main.go:+448
package main

import (
	"fmt"
	"math"
)

// :show start
func sqrt(n float64) (float64, error) {
	if n < 0 {
		return 0, fmt.Errorf("invalid argument '%f', must be >= 0", n)
	}
	return math.Sqrt(n), nil
}

func printSqrt(n float64) {
	if res, err := sqrt(n); err == nil {
		fmt.Printf("sqrt of %f is %f\n", n, res)
	} else {
		fmt.Printf("sqrt of %f returned error '%s'\n", n, err)
	}

}

func main() {
	printSqrt(16)
	printSqrt(-16)
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-break
main.go:+151
package main

import "fmt"

func main() {
	// :show start
	i := 0
	for {
		i++
		if i > 2 {
			break
		}
		fmt.Printf("i: %d\n", i)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-continue
main.go:+159

package main

import "fmt"

func main() {
	// :show start
	for i := 0; i < 4; i++ {
		if i < 2 {
			continue
		}
		fmt.Printf("i: %d\n", i)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-range-string
main.go:+176
package main

import "fmt"

func main() {
	// :show start
	s := "Hey 世界"
	for idx := range s {
		b := s[idx]
		fmt.Printf("idx: %d, byte: %d\n", idx, b)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-range-string-2
main.go:+171
package main

import "fmt"

func main() {
	// :show start
	s := "Hey 世界"
	for idx, rune := range s {
		fmt.Printf("idx: %d, rune: %d\n", idx, rune)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-range-slice
main.go:+172
package main

import "fmt"

func main() {
	// :show start
	a := []int{3, 15, 8}
	for idx, el := range a {
		fmt.Printf("idx: %d, element: %d\n", idx, el)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-range-slice-2
main.go:+151
package main

import "fmt"

func main() {
	// :show start
	a := []int{3, 15, 8}
	for idx := range a {
		fmt.Printf("idx: %d\n", idx)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-range-3
main.go:+157
package main

import "fmt"

func main() {
	// :show start
	a := []int{3, 15, 8}
	for _, el := range a {
		fmt.Printf("element: %d\n", el)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-range-map
main.go:+208
package main

import "fmt"

func main() {
	// :show start
	m := map[string]int{
		"three": 3,
		"five":  5,
	}
	for key, value := range m {
		fmt.Printf("key: %s, value: %d\n", key, value)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-range-map-2
main.go:+182
package main

import "fmt"

func main() {
	// :show start
	m := map[string]int{
		"three": 3,
		"five":  5,
	}
	for key := range m {
		fmt.Printf("key: %s\n", key)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-range-map-3
main.go:+192
package main

import "fmt"

func main() {
	// :show start
	m := map[string]int{
		"three": 3,
		"five":  5,
	}
	for _, value := range m {
		fmt.Printf("value: %d\n", value)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-range-channel
main.go:+302
package main

import "fmt"

// :show start
func fillAndCloseChannel(ch chan int) {
	for i := 0; i < 3; i++ {
		ch <- i + 3
	}
	close(ch)
}

// :show end

func main() {
	// :show start
	ch := make(chan int)
	go fillAndCloseChannel(ch)

	for v := range ch {
		fmt.Printf("v: %d\n", v)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-range-channel-2
main.go:+299

package main

import "fmt"

func fillAndCloseChannel(ch chan int) {
	for i := 0; i < 3; i++ {
		ch <- i + 3
	}
	close(ch)
}

func main() {
	// :show start
	ch := make(chan int)
	go fillAndCloseChannel(ch)

	for {
		v, ok := <-ch
		if !ok {
			break
		}
		fmt.Printf("v: %d\n", v)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-function-parameters
main.go:+255
package main

import (
	"fmt"
)

// :show start
func SayHelloToMe(firstName, lastName string, age int) {
	fmt.Printf("Hello, %s %s!\n", firstName, lastName)
	fmt.Printf("You are %d\n", age)
}

func main() {
	SayHelloToMe("John", "Doe", 35)
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-function-returned-values
main.go:+307
package main

import "fmt"

// :show start
func Add(a, b int) int {
	return a + b
}

func AddAndMultiply(a, b int) (int, int) {
	return a + b, a * b
}

func main() {
	sum, mult := AddAndMultiply(5, 8)
	fmt.Printf("5+8=%d, 5*8=%d\n", sum, mult)
	sum = Add(6, 12)
	fmt.Printf("6+12=%d\n", sum)
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-named-returned-values
main.go:+333
package main

import "fmt"

// :show start
func inverse(v float32) (reciprocal float32) {
	if v == 0 {
		return
	}
	reciprocal = 1 / v
	return
}

// function can return multiple values
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}

func main() {
	fmt.Printf("inverse(5)=%.2f\n", inverse(5))
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-function-variadic
main.go:+401
package main

import (
	"fmt"
)

// :show start
func variadic(strs ...string) {
	// strs is a slice of string
	for i, str := range strs {
		fmt.Printf("%d: %s\n", i, str)
	}
	fmt.Print("\n")
}

func main() {
	variadic("Hello", "Goodbye")
	variadic("Str1", "Str2", "Str3")

	// you can also give a slice to a variadic function, with `...`:
	strs := []string{"a", "b"}
	variadic(strs...)
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-function-literal
main.go:+111
package main

import "fmt"

// :show start
func main() {
	func() {
		fmt.Println("Hello!")
	}()
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-function-literal-2
main.go:+124
package main

import "fmt"

// :show start
func main() {
	func(str string) {
		fmt.Println(str)
	}("Hello!")
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-function-literal-3
main.go:+123
package main

import "fmt"

// :show start
func main() {
	str := "Hello!"
	func() {
		fmt.Println(str)
	}()
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-function-variable
main.go:+458

package main

import "fmt"

// :show start
// intOp is a variable whose type is function that takes
// 2 integers as arguments and returns an integer
var intOp func(int, int) int

func intAdd(a, b int) int {
	return a + b
}

func main() {
	intOp = intAdd
	fmt.Printf("intOp(2, 3) = %d\n", intOp(2, 3))

	// we can assign literal functions as well
	intOp = func(a, b int) int {
		return a * b
	}
	fmt.Printf("intOp(2, 3) = %d\n", intOp(2, 3))
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-function-variable-2
main.go:+349
package main

import "fmt"

// :show start
func funcAdd(a, b int) int {
	return a + b
}

func runFunc(a, b int, intOp func(int, int) int) {
	fmt.Printf("intOp(%d, %d) = %d\n", a, b, intOp(a, b))
}

func main() {
	runFunc(2, 3, funcAdd)

	// we can pass literal functions as well
	runFunc(2, 3, func(a, b int) int {
		return a * b
	})
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-error-handling-custom-errors
main.go:+322
package main

import (
	"fmt"
)

// :show start

// MyError is a custom error type
type MyError struct {
	msg string
}

func (e *MyError) Error() string {
	return e.msg
}

// :show end

func main() {
	// :show start
	var err error = &MyError{msg: "This is custom error type"}
	fmt.Printf("err: %s\n", err)
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-error-handling-errors-in-short-programs
main.go:+1008
// allow error
package main

import (
	"errors"
	"fmt"
)

// :show start
// FmtArgs formats args as a string. First argument should be format string
// and the rest are arguments to the format
func FmtArgs(args ...interface{}) string {
	if len(args) == 0 {
		return ""
	}
	format := args[0].(string)
	if len(args) == 1 {
		return format
	}
	return fmt.Sprintf(format, args[1:]...)
}

func panicWithMsg(defaultMsg string, args ...interface{}) {
	s := FmtArgs(args...)
	if s == "" {
		s = defaultMsg
	}
	fmt.Printf("%s\n", s)
	panic(s)
}

// PanicIf panics if cond is true
func PanicIf(cond bool, args ...interface{}) {
	if !cond {
		return
	}
	panicWithMsg("PanicIf: condition failed", args...)
}

// PanicIfErr panics if err is not nil
func PanicIfErr(err error, args ...interface{}) {
	if err == nil {
		return
	}
	panicWithMsg(err.Error(), args...)
}

func main() {
	PanicIfErr(nil)                              // nothing happens
	PanicIfErr(errors.New("there was an error")) // will panic
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-error-handling-add-callstack
main.go:+531

package main

import (
	"errors"
	"fmt"

	pkgerrors "github.com/pkg/errors"
)

// :show start

func wrappedError() error {
	err := errors.New("Original error")
	// create a new error value which wraps original err and
	// adds calls tack
	return pkgerrors.WithStack(err)
}

func main() {
	// %+v prints original error add callstack
	fmt.Printf("err: %+v\n\n", wrappedError())

	// errors created with pkg/errors include callstack by default
	fmt.Printf("err: %+v\n", pkgerrors.New("error created with pkg/errors"))
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-concurrency-basics
main.go:+592
package main

import (
	"fmt"
	"sync"
)

// :show start
var wg sync.WaitGroup

func pow2Worker(chIn chan int, chOut chan int) {
	fmt.Printf("sqrtWorker started\n")
	for i := range chIn {
		sqrt := i * i
		chOut <- sqrt
	}
	fmt.Printf("sqrtWorker finished\n")
	wg.Done()
}

func main() {
	chIn := make(chan int)
	chOut := make(chan int)
	for i := 0; i < 2; i++ {
		wg.Add(1)
		go pow2Worker(chIn, chOut)
	}

	go func() {
		chIn <- 2
		chIn <- 4
		close(chIn)
	}()

	go func() {
		wg.Wait()
		close(chOut)
	}()

	for sqrt := range chOut {
		fmt.Printf("Got sqrt: %d\n", sqrt)
	}
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-channels-basics
main.go:+332
package main

import (
	"fmt"
	"math/rand"
)

// :show start

func genInts(chInts chan int) {
	chInts <- rand.Intn(1000)
}

func main() {
	chInts := make(chan int)
	for i := 0; i < 2; i++ {
		go genInts(chInts)
	}
	n := <-chInts
	fmt.Printf("n: %d\n", n)

	select {
	case n := <-chInts:
		fmt.Printf("n: %d\n", n)
	}
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-mutex-basics
main.go:+798
package main

import (
	"fmt"
	"sync"
	"time"
)

// :show start
var cache map[int]int
var mu sync.Mutex

func expensiveOperation(n int) int {
	// in real code this operation would be very expensive
	return n * n
}

func getCached(n int) int {
	mu.Lock()
	v, isCached := cache[n]
	mu.Unlock()
	if isCached {
		return v
	}

	v = expensiveOperation(n)

	mu.Lock()
	cache[n] = v
	mu.Unlock()
	return v
}

func accessCache() {
	total := 0
	for i := 0; i < 5; i++ {
		n := getCached(i)
		total += n
	}
	fmt.Printf("total: %d\n", total)
}

// :show end

func main() {
	// :show start
	cache = make(map[int]int)
	go accessCache()
	accessCache()
	// :show end

	// for simplicity of the example
	// don't use time.Sleep() to coordinate goroutines
	// in production code
	time.Sleep(100 * time.Millisecond)
}
---
@url: https://repl.it/@kjk1/gobook-file-basics
main.go:+448

// no playground
package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
)

func exitIfError(err error) {
	if err != nil {
		fmt.Printf("Error: '%s'\n", err)
		os.Exit(1)
	}
}

func main() {
	// :show start
	path := "main.go"
	f, err := os.Open(path)
	exitIfError(err)
	defer f.Close()

	d, err := ioutil.ReadAll(f)
	exitIfError(err)

	lines := bytes.Split(d, []byte{'\n'})
	fmt.Printf("File %s has %d lines\n", path, len(lines))
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-cmdline-args-basics
main.go:+591
// :run go run $file -echo echo-arg additional arg
// no playground
package main

import (
	"flag"
	"fmt"
	"os"
)

// :show start
var (
	flgHelp bool
	flgEcho string
)

func parseCmdLineFlags() {
	flag.BoolVar(&flgHelp, "help", false, "if true, show help")
	flag.StringVar(&flgEcho, "echo", "", "")
	flag.Parse()
}

func main() {
	parseCmdLineFlags()
	if flgHelp {
		flag.Usage()
		os.Exit(0)
	}
	if flgEcho != "" {
		fmt.Printf("flag -echo: '%s'\n", flgEcho)
	}

	remainingArgs := flag.Args()
	for _, arg := range remainingArgs {
		fmt.Printf("Remainig arg: '%s'\n", arg)
	}
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-logging-log
main.go:+125
package main

import "log"

func main() {
	// :show start
	log.Printf("Logging")
	log.Printf("Second line\n")
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-logging-log-file
main.go:+349
// no output
package main

import (
	"log"
	"os"
)

func main() {
	// :show start
	logfile, err := os.OpenFile("test.log", os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
	if err != nil {
		log.Fatalf("os.OpenFile() failed with '%s\n", err)
	}
	defer logfile.Close()

	log.SetOutput(logfile)
	log.Println("Log entry")
	// :show end
	os.Remove("test.log")
}
---
@url: https://repl.it/@kjk1/gobook-log-syslog
main.go:+263

// no output
package main

import (
	"log"
	"log/syslog"
)

func main() {
	// :show start
	syslogger, err := syslog.New(syslog.LOG_INFO, "syslog_example")
	if err != nil {
		log.Fatalln(err)
	}

	log.SetOutput(syslogger)
	log.Println("Log entry")
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-exec-basics
main.go:+308
// no playground
package main

import (
	"fmt"
	"log"
	"os/exec"
)

func main() {
	// :show start
	cmd := exec.Command("go", "version")
	out, err := cmd.CombinedOutput()
	if err != nil {
		log.Fatalf("cmd.CombinedOutput() failed with '%s'\n", err)
	}
	fmt.Printf("Output:\n%s\n", string(out))
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-exec-basics-2
main.go:+512
// no playground
package main

import (
	"bytes"
	"fmt"
	"log"
	"os/exec"
)

func main() {
	// :show start
	var stdout, stderr bytes.Buffer
	cmd := exec.Command("go", "version")
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	err := cmd.Start()
	if err != nil {
		log.Fatalf("cmd.Start() failed with '%s'\n", err)
	}

	err = cmd.Wait()
	if err != nil {
		log.Fatalf("cmd.Wait() failed with '%s'\n", err)
	}
	out := append(stdout.Bytes(), stderr.Bytes()...)
	fmt.Printf("Output:\n%s\n", string(out))
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-json-serialize
main.go:+656
package main

import (
	"encoding/json"
	"fmt"
	"log"
)

// :show start
type Person struct {
	fullName string
	Name     string
	Age      int    `json:"age"`
	City     string `json:"city"`
}

// :show end

func main() {
	// :show start
	p := Person{
		Name: "John",
		Age:  37,
		City: "SF",
	}
	d, err := json.Marshal(&p)
	if err != nil {
		log.Fatalf("json.MarshalIndent failed with '%s'\n", err)
	}
	fmt.Printf("Person in compact JSON: %s\n", string(d))

	d, err = json.MarshalIndent(p, "", "  ")
	if err != nil {
		log.Fatalf("json.MarshalIndent failed with '%s'\n", err)
	}
	fmt.Printf("Person in pretty-printed JSON:\n%s\n", string(d))
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-json-deserialize
main.go:+549
package main

import (
	"encoding/json"
	"fmt"
	"log"
)

// :show start
type Person struct {
	Name       *string `json:"name"`
	Age        int     `json:"age"`
	City       string
	Occupation string
}

var jsonStr = `{
	"name": "Jane",
	"age": 24,
	"city": "ny"
}`

// :show end

func main() {
	// :show start
	var p Person
	err := json.Unmarshal([]byte(jsonStr), &p)
	if err != nil {
		log.Fatalf("json.Unmarshal failed with '%s'\n", err)
	}
	fmt.Printf("Person struct parsed from JSON: %#v\n", p)
	fmt.Printf("Name: %#v\n", *p.Name)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-xml-unmarshal-simple
main.go:+824
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start
var xmlStr = `
<people>
	<person age="34">
		<first-name>John</first-name>
		<address>
			<city>San Francisco</city>
			<state>CA</state>
		</address>
	</person>

	<person age="23">
		<first-name>Julia</first-name>
	</person>
</people>`

type People struct {
	Person []Person `xml:"person"`
}

type Person struct {
	Age       int     `xml:"age,attr"`
	FirstName string  `xml:"first-name"`
	Address   Address `xml:"address"`
}

type Address struct {
	City  *string `xml:"city"`
	State string  `xml:"state"`
}

// :show end

func main() {
	// :show start
	var people People
	data := []byte(xmlStr)
	err := xml.Unmarshal(data, &people)
	if err != nil {
		log.Fatalf("xml.Unmarshal failed with '%s'\n", err)
	}
	fmt.Printf("%#v\n\n", people)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-xml-marshal-simple
main.go:+983
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start
type People struct {
	XMLName        xml.Name `xml:"people"`
	Person         []Person `xml:"person"`
	noteSerialized int
}

type Person struct {
	Age       int     `xml:"age,attr"`
	FirstName string  `xml:"first-name"`
	Address   Address `xml:"address"`
}

type Address struct {
	City  string `xml:"city"`
	State string `xml:"state"`
}

// :show end

func main() {
	// :show start
	people := People{
		Person: []Person{
			Person{
				Age:       34,
				FirstName: "John",
				Address:   Address{City: "San Francisco", State: "CA"},
			},
		},
		noteSerialized: 8,
	}
	d, err := xml.Marshal(&people)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("Compact XML: %s\n\n", string(d))

	d, err = xml.MarshalIndent(&people, "", "  ")
	if err != nil {
		log.Fatalf("xml.MarshalIndent failed with '%s'\n", err)
	}
	fmt.Printf("Pretty printed XML:\n%s\n", string(d))

	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-csv-read
main.go:+605
// no playground
package main

import (
	"encoding/csv"
	"fmt"
	"io"
	"log"
	"os"
)

func main() {
	// :show start
	f, err := os.Open("stocks.csv")
	if err != nil {
		log.Fatalf("os.Open() failed with '%s'\n", err)
	}
	defer f.Close()

	r := csv.NewReader(f)
	var record []string
	nRecords := 0
	for {
		record, err = r.Read()
		if err != nil {
			if err == io.EOF {
				err = nil
			}
			break
		}
		nRecords++
		if nRecords < 5 {
			fmt.Printf("Record: %#v\n", record)
		}
	}
	if err != nil {
		log.Fatalf("r.Read() failed with '%s'\n", err)
	}
	fmt.Printf("Read %d records\n", nRecords)
	// :show end
}
stocks.csv:+223
date,open,high,low,close,volume,Name
2013-02-08,15.07,15.12,14.63,14.75,8407500,AAL
2013-02-11,14.89,15.01,14.26,14.46,8882000,AAL
2013-02-12,14.45,14.51,14.1,14.27,8126000,AAL
2013-02-13,14.3,14.94,14.25,14.66,10259500,AAL
---
@url: https://repl.it/@kjk1/gobook-csv-write
main.go:+1066
// no playground
package main

import (
	"encoding/csv"
	"fmt"
	"io/ioutil"
	"log"
	"os"
)

// :show start
func writeCSV() error {
	f, err := os.Create("stocks_tmp.csv")
	if err != nil {
		return err
	}

	w := csv.NewWriter(f)
	records := [][]string{
		{"date", "price", "name"},
		{"2013-02-08", "15,07", "GOOG"},
		{"2013-02-09", "15,09", "GOOG"},
	}
	for _, rec := range records {
		err = w.Write(rec)
		if err != nil {
			f.Close()
			return err
		}
	}

	// csv.Writer might buffer writes for performance so we must
	// Flush to ensure all data has been written to underlying
	// writer
	w.Flush()

	// Flush doesn't return an error. If it failed to write, we
	// can get the error with Error()
	err = w.Error()
	if err != nil {
		return err
	}
	// Close might also fail due to flushing out buffered writes
	err = f.Close()
	return err
}

// :show end

func main() {
	writeCSV()
	d, err := ioutil.ReadFile("stocks_tmp.csv")
	if err != nil {
		log.Fatalf("ioutil.ReadAll() failed with '%s'\n", err)
	}
	fmt.Printf("%s\n", string(d))
	os.Remove("stocks_tmp.csv")
}
---
@url: https://repl.it/@kjk1/gobook-yaml-deserialize
data.yml:+177
dependencies:
  - name: apache
    version: 1.2.3
    repository: http://example.com/charts
  - name: mysql
    version: 3.2.1
    repository: http://another.example.com/charts

main.go:+728
// no playground
package main

import (
	"fmt"
	"log"
	"os"

	"gopkg.in/yaml.v2"
)

// :show start
// Dependency describes a dependency
type Dependency struct {
	Name          string
	Version       string
	RepositoryURL string `yaml:"repository"`
}

type YAMLFile struct {
	Dependencies []Dependency `yaml:"dependencies"`
}

// :show end

func main() {
	// :show start
	f, err := os.Open("data.yml")
	if err != nil {
		log.Fatalf("os.Open() failed with '%s'\n", err)
	}
	defer f.Close()

	dec := yaml.NewDecoder(f)

	var yamlFile YAMLFile
	err = dec.Decode(&yamlFile)
	if err != nil {
		log.Fatalf("dec.Decode() failed with '%s'\n", err)
	}

	fmt.Printf("Decoded YAML dependencies: %#v\n", yamlFile.Dependencies)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-yaml-serialize
main.go:+484
// no playground
package main

import (
	"fmt"
	"log"

	yaml "gopkg.in/yaml.v2"
)

// :show start
type Person struct {
	fullName string
	Name     string
	Age      int    `yaml:"age"`
	City     string `yaml:"city"`
}

// :show end

func main() {
	// :show start
	p := Person{
		Name: "John",
		Age:  37,
		City: "SF",
	}
	d, err := yaml.Marshal(&p)
	if err != nil {
		log.Fatalf("yaml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("Person in YAML:\n%s\n", string(d))
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-http-client-go
main.go:+1329
// no playground
package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
)

func main() {
	// :show start
	uri := "https://httpbin.org/html"
	resp, err := http.Get(uri)
	if err != nil {
		log.Fatalf("http.Get() failed with '%s'\n", err)
	}

	// it's important to close resp.Body or else we'll leak network connection
	// it must be done after checking for error because in error case
	// resp.Body can be nil
	defer resp.Body.Close()
	d, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("ioutil.ReadAll() failed with '%s'\n", err)
	}

	contentType := resp.Header.Get("Content-Type")
	fmt.Printf("http.Get() returned content of type '%s' and size %d bytes.\nStatus code: %d\n", contentType, len(d), resp.StatusCode)

	// getting page that doesn't exist return 404
	uri = "https://httpbin.org/page-doesnt-exist"
	resp, err = http.Get(uri)
	if err != nil {
		log.Fatalf("http.Get() failed with '%s'\n", err)
	}

	contentType = resp.Header.Get("Content-Type")
	fmt.Printf("\nhttp.Get() returned content of type '%s' and size %d bytes.\nStatus code: %d\n", contentType, len(d), resp.StatusCode)

	// acessing non-existent host fails
	uri = "http://website.not-exists.as/index.html"
	resp, err = http.Get(uri)
	if err != nil {
		fmt.Printf("\nhttp.Get() failed with: '%s'\nresp: %v\n", err, resp)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-http-client-get-custom-client
main.go:+354
// allow error, no playground
package main

import (
	"log"
	"net/http"
	"time"
)

func main() {
	// :show start
	client := &http.Client{}
	client.Timeout = time.Millisecond * 100

	uri := "https://httpbin.org/delay/3"
	resp, err := client.Get(uri)
	if err != nil {
		log.Fatalf("http.Get() failed with '%s'\n", err)
	}
	// :show end
	resp.Body.Close()
}
---
@url: https://repl.it/@kjk1/gobook-http-client-post
main.go:+657
// no playground
package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"time"
)

func main() {
	// :show start
	client := &http.Client{}
	client.Timeout = time.Second * 15

	uri := "https://httpbin.org/post"
	body := bytes.NewBufferString("text we send")
	resp, err := client.Post(uri, "text/plain", body)
	if err != nil {
		log.Fatalf("client.Post() failed with '%s'\n", err)
	}
	defer resp.Body.Close()
	d, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("http.Get() failed with '%s'\n", err)
	}
	fmt.Printf("http.Post() returned statuts code %d, truncated text:\n%s...\n", resp.StatusCode, string(d)[:93])
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-template-basics
main.go:+804
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
var tmplStr = `User {{.User}} has {{.TotalTweets}} tweets.
{{- $tweetCount := len .RecentTweets }}
Recent tweets:
{{range $idx, $tweet := .RecentTweets}}Tweet {{$idx}} of {{$tweetCount}}: '{{.}}'
{{end -}}
Most recent tweet: '{{index .RecentTweets 0}}'
`

// :show end

func main() {
	// :show start
	t := template.New("tweets")
	t, err := t.Parse(tmplStr)
	if err != nil {
		log.Fatalf("template.Parse() failed with '%s'\n", err)
	}
	data := struct {
		User         string
		TotalTweets  int
		RecentTweets []string
	}{
		User:         "kjk",
		TotalTweets:  124,
		RecentTweets: []string{"hello", "there"},
	}
	err = t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-template-basics-2
main.go:+485
package main

import (
	"log"
	"os"
	"text/template"
)

func main() {
	// :show start
	tmplStr := "Data: {{.}}\n"
	t := template.Must(template.New("simple").Parse(tmplStr))
	execWithData := func(data interface{}) {
		err := t.Execute(os.Stdout, data)
		if err != nil {
			log.Fatalf("t.Execute() failed with '%s'\n", err)
		}
	}

	execWithData(5)
	execWithData("foo")
	st := struct {
		Number int
		Str    string
	}{
		Number: 3,
		Str:    "hello",
	}
	execWithData(st)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-reflection-basics
main.go:+357
package main

import (
	"fmt"
	"reflect"
)

func main() {
	// :show start
	var v interface{} = 4
	var reflectVal reflect.Value = reflect.ValueOf(v)

	var typ reflect.Type = reflectVal.Type()
	fmt.Printf("Type '%s' of size: %d bytes\n", typ.Name(), typ.Size())
	if typ.Kind() == reflect.Int {
		fmt.Printf("v contains value of type int\n")
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-http-client-timeout
main.go:+570
// allow error, no playground
package main

import (
	"context"
	"log"
	"net/http"
	"time"
)

func main() {
	// :show start

	uri := "https://httpbin.org/delay/3"
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		log.Fatalf("http.NewRequest() failed with '%s'\n", err)
	}

	ctx, _ := context.WithTimeout(context.TODO(), time.Millisecond*100)
	req = req.WithContext(ctx)

	resp, err := http.DefaultClient.Do(req.WithContext(ctx))
	if err != nil {
		log.Fatalf("http.DefaultClient.Do() failed with:\n'%s'\n", err)
	}
	defer resp.Body.Close()
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-defer-basics
main.go:+295
package main

import "fmt"

// :show start
func logExit(name string) {
	fmt.Printf("Function %s returned\n", name)
}

func main() {
	fmt.Println("First main statement")
	defer logExit("main") // position of defer statement here does not matter
	fmt.Println("Last main statement")
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-defer-basics-2
main.go:+383
// allow error
package main

import "fmt"

// :show start
func logNum(i int) {
	fmt.Printf("Num %d\n", i)
}

func main() {
	defer logNum(1)
	fmt.Println("First main statement")
	defer logNum(2)
	defer logNum(3)
	panic("panic occurred")

	fmt.Println("Last main statement") // not printed

	// not deferred since execution flow never reaches this line
	defer logNum(3)
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-defer-basics-3
main.go:+344
package main

import "fmt"

// :show start

func logNum(i int) {
	fmt.Printf("Num %d\n", i)
}

func main() {
	i := 1
	defer logNum(i) // deferred function call: logNum(1)
	fmt.Println("First main statement")
	i++
	defer logNum(i)     // deferred function call: logNum(2)
	defer logNum(i * i) // deferred function call: logNum(4)
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-defer-basics-4
main.go:+341
package main

import "fmt"

// :show start

func plusOne(i int) (result int) {
	// anonymous function must be called by adding ()
	defer func() { result++ }()

	// i is returned as result, which is updated by deferred function above
	// after execution of below return
	return i
}

func main() {
	fmt.Println(plusOne(1)) // 2
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-defer-gotcha
main.go:+171
package main

import "fmt"

// :show start

func main() {
	fmt.Print("Before if\n")
	if true {
		defer fmt.Print("inside if\n")
	}

	fmt.Print("Ater if\n")
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-defer-gotcha-2
main.go:+150
package main

import "fmt"

// :show start

func main() {
	for i := 0; i < 2; i++ {
		defer func() {
			fmt.Printf("%d\n", i)
		}()
	}
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-defer-gotcha-3
main.go:+158
package main

import "fmt"

// :show start

func main() {
	for i := 0; i < 2; i++ {
		defer func(i2 int) {
			fmt.Printf("%d\n", i2)
		}(i)
	}
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-panic
main.go:+193
// allow error
package main

import "fmt"

// :show start
func foo() {
	defer fmt.Println("Exiting foo")
	panic("bar")
}

func main() {
	defer fmt.Println("Exiting main")
	foo()
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-recover
main.go:+368
// allow error
package main

import "fmt"

// :show start
func foo() {
	panic("bar")
}

func bar() {
	defer func() {
		if msg := recover(); msg != nil {
			fmt.Printf("Recovered with message %s\n", msg)
		}
	}()
	foo()
	fmt.Println("Never gets executed")
}

func main() {
	fmt.Println("Entering main")
	bar()
	fmt.Println("Exiting main the normal way")
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-recover-from-panic
main.go:+524
package main

import (
	"fmt"
	"runtime"
)

// :show start
type Foo struct {
	Is []int
}

func (fp *Foo) Panic() (err error) {
	defer PanicRecovery(&err)
	fp.Is[0] = 5
	return nil
}

func PanicRecovery(err *error) {

	if r := recover(); r != nil {
		if _, ok := r.(runtime.Error); ok {
			//fmt.Println("Panicing")
			//panic(r)
			*err = r.(error)
		} else {
			*err = r.(error)
		}
	}
}

func main() {
	fp := &Foo{}
	if err := fp.Panic(); err != nil {
		fmt.Printf("Error: %v\n", err)
	}
	fmt.Println("ok")
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-concurrency-hello-world
main.go:+367
package main

import (
	"fmt"
	"time"
)

// :show start
func main() {
	// create new channel of type string
	ch := make(chan string)

	// start new anonymous goroutine
	go func() {
		time.Sleep(time.Second)
		// send "Hello World" to channel
		ch <- "Hello World"
	}()
	// read from channel
	msg, ok := <-ch
	fmt.Printf("msg='%s', ok='%v'\n", msg, ok)
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-concurrency-create-goroutine
main.go:+362
package main

import (
	"fmt"
	"time"
)

// :show start
func mult(x, y int) {
	fmt.Printf("%d * %d = %d\n", x, y, x*y)
}

// :show end

func main() {
	// :show start
	go mult(1, 2) // first execution, non-blocking
	go mult(3, 4) // second execution, also non-blocking
	// :show end

	// that's not how you do it in real code
	time.Sleep(200 * time.Millisecond)
}
---
@url: https://repl.it/@kjk1/gobook-concurrency-wait-goroutine-finish
main.go:+314
package main

import (
	"fmt"
	"sync"
)

// :show start
var wg sync.WaitGroup // 1

func routine(i int) {
	defer wg.Done() // 3
	fmt.Printf("routine %v finished\n", i)
}

func main() {
	wg.Add(10) // 2
	for i := 0; i < 10; i++ {
		go routine(i) // *
	}
	wg.Wait() // 4
	fmt.Println("main finished")
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-concurrency-limit-with-semaphore
main.go:+951
package main

import (
	"fmt"
	"sync"
	"time"
)

// :show start

var (
	semaphoreSize = 4

	mu                 sync.Mutex
	totalTasks         int
	curConcurrentTasks int
	maxConcurrentTasks int
)

func timeConsumingTask() {
	mu.Lock()
	totalTasks++
	curConcurrentTasks++
	if curConcurrentTasks > maxConcurrentTasks {
		maxConcurrentTasks = curConcurrentTasks
	}
	mu.Unlock()

	// in real system this would be a CPU intensive operation
	time.Sleep(10 * time.Millisecond)

	mu.Lock()
	curConcurrentTasks--
	mu.Unlock()
}

func main() {
	sem := make(chan struct{}, semaphoreSize)
	var wg sync.WaitGroup
	for i := 0; i < 32; i++ {
		// acquire semaphore
		sem <- struct{}{}
		wg.Add(1)

		go func() {
			timeConsumingTask()
			// release semaphore
			<-sem
			wg.Done()
		}()
	}

	// wait for all task to finish
	wg.Wait()

	fmt.Printf("total tasks         : %d\n", totalTasks)
	fmt.Printf("max concurrent tasks: %d\n", maxConcurrentTasks)
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-channels-range
main.go:+247
package main

import (
	"fmt"
)

// :show start

func foo(ch chan int) {
	ch <- 1
	ch <- 2
	close(ch)
}

func main() {
	ch := make(chan int)
	go foo(ch)
	for n := range ch {
		fmt.Println(n)
	}
	fmt.Println("channel is now closed")
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-channels-timeout
main.go:+390
package main

import (
	"fmt"
	"time"
)

// :show start

func main() {
	chResult := make(chan int, 1)

	go func() {
		time.Sleep(1 * time.Second)
		chResult <- 5
		fmt.Printf("Worker finished")
	}()

	select {
	case res := <-chResult:
		fmt.Printf("Got %d from worker\n", res)
	case <-time.After(100 * time.Millisecond):
		fmt.Printf("Timed out before worker finished\n")
	}
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-channels-close
main.go:+409
package main

import (
	"fmt"
	"time"
)

func main() {
	// :show start
	ch := make(chan string)

	go func() {
		for s := range ch {
			fmt.Printf("received from channel: %s\n", s)
		}
		fmt.Print("range loop finished because ch was closed\n")
	}()

	ch <- "foo"
	close(ch)
	// :show end

	// only to simplify example, don't sleep to coordinate
	// goroutines in real code
	time.Sleep(100 * time.Millisecond)
}
---
@url: https://repl.it/@kjk1/gobook-channels-close-2
main.go:+221
package main

import (
	"fmt"
)

func main() {
	// :show start
	ch := make(chan string)
	close(ch)
	v := <-ch
	fmt.Printf("Receive from closed channel immediately returns zero value of the type: %#v\n", v)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-channels-close-3
main.go:+312

package main

import (
	"fmt"
)

func main() {
	// :show start
	ch := make(chan int)
	go func() {
		ch <- 1
		close(ch)
	}()
	v, isClosed := <-ch
	fmt.Printf("received %d, is channel closed: %v\n", v, isClosed)
	v, isClosed = <-ch
	fmt.Printf("received %d, is channel closed: %v\n", v, isClosed)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-channels-close-4
main.go:+121
// allow error
package main

func main() {
	// :show start
	ch := make(chan string)
	close(ch)
	close(ch)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-channels-close-5
main.go:+126
// allow error
package main

func main() {
	// :show start
	ch := make(chan int)
	close(ch)
	ch <- 5 // panics
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-channels-buffered
main.go:+815
package main

import (
	"fmt"
	"time"
)

// :show start

func producer(ch chan int) {
	for i := 0; i < 5; i++ {
		if i%2 == 0 {
			time.Sleep(10 * time.Millisecond)
		} else {
			time.Sleep(1 * time.Millisecond)
		}
		ch <- i
	}
}

func consumer(ch chan int) {
	total := 0
	for i := 0; i < 5; i++ {
		if i%2 == 1 {
			time.Sleep(10 * time.Millisecond)
		} else {
			time.Sleep(1 * time.Millisecond)
		}
		total += <-ch
	}
}

func unbuffered() {
	timeStart := time.Now()
	ch := make(chan int)
	go producer(ch)
	consumer(ch)
	fmt.Printf("Unbuffered version took %s\n", time.Since(timeStart))
}

func buffered() {
	timeStart := time.Now()
	ch := make(chan int, 5)
	go producer(ch)
	consumer(ch)
	fmt.Printf("Buffered version took %s\n", time.Since(timeStart))
}

func main() {
	unbuffered()
	buffered()
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-channels-non-blocking-wait
main.go:+418
package main

import (
	"fmt"
	"time"
)

// :show start
func main() {
	ch := make(chan int, 1)

end:
	for {
		select {
		case n := <-ch:
			fmt.Printf("Received %d from a channel\n", n)
			break end
		default:
			fmt.Print("Channel is empty\n")
			ch <- 8
		}
		// wait for channel to be filled with values
		// don't use time.Sleep() like that in production code
		time.Sleep(20 * time.Millisecond)
	}
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-channels-signal
main.go:+473
package main

import (
	"fmt"
)

// :show start
func worker(ch chan int, chQuit chan struct{}) {
	for {
		select {
		case v := <-ch:
			fmt.Printf("Got value %d\n", v)
		case <-chQuit:
			fmt.Printf("Signalled on quit channel. Finishing\n")
			chQuit <- struct{}{}
			return
		}
	}
}
func main() {
	ch, chQuit := make(chan int), make(chan struct{})
	go worker(ch, chQuit)
	ch <- 3
	chQuit <- struct{}{}

	// wait to be signalled back by the worker
	<-chQuit
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-rwmutex
main.go:+802
package main

import (
	"fmt"
	"sync"
	"time"
)

// :show start
var cache map[int]int
var mu sync.RWMutex

func expensiveOperation(n int) int {
	// in real code this operation would be very expensive
	return n * n
}

func getCached(n int) int {
	mu.RLock()
	v, isCached := cache[n]
	mu.RUnlock()
	if isCached {
		return v
	}

	v = expensiveOperation(n)

	mu.Lock()
	cache[n] = v
	mu.Unlock()
	return v
}

func accessCache() {
	total := 0
	for i := 0; i < 5; i++ {
		n := getCached(i)
		total += n
	}
	fmt.Printf("total: %d\n", total)
}

// :show end

func main() {
	// :show start
	cache = make(map[int]int)
	go accessCache()
	accessCache()
	// :show end

	// for simplicity of the example
	// don't use time.Sleep() to coordinate goroutines
	// in production code
	time.Sleep(100 * time.Millisecond)
}
---
@url: https://repl.it/@kjk1/gobook-mutex-data-race
main.go:+457
// :run go run -race $file
// allow error
package main

import (
	"fmt"
	"runtime"
	"sync"
	"time"
)

// :show start
var (
	n int
)

func main() {
	var wg sync.WaitGroup
	nCPU := runtime.NumCPU()
	nIter := 100
	for i := 0; i < nCPU; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for j := 0; j < nIter; j++ {
				n++
				time.Sleep(time.Microsecond * 10)
			}
		}()
	}
	wg.Wait()
	fmt.Printf("n is: %d, expected: %d\n", n, nCPU*nIter)
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-file-read-lines
main.go:+724
// no playground
package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
)

// :show start

// ReadLines reads all lines from a file
func ReadLines(filePath string) ([]string, error) {
	file, err := os.OpenFile(filePath, os.O_RDONLY, 0666)
	if err != nil {
		return nil, err
	}
	defer file.Close()
	scanner := bufio.NewScanner(file)
	res := make([]string, 0)
	for scanner.Scan() {
		line := scanner.Bytes()
		res = append(res, string(line))
	}
	if err = scanner.Err(); err != nil {
		return nil, err
	}
	return res, nil
}

func main() {
	path := "main.go"
	lines, err := ReadLines(path)
	if err != nil {
		log.Fatalf("ReadLines failed with '%s'\n", err)
	}
	fmt.Printf("File %s has %d lines\n", path, len(lines))
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-file-get-size
main.go:+494
// no playground
package main

import (
	"fmt"
	"log"
	"os"
)

// :show start

// GetFileSize returns file size or error if e.g. file doesn't exist
func GetFileSize(path string) (int64, error) {
	st, err := os.Lstat(path)
	if err != nil {
		return -1, err
	}
	return st.Size(), nil
}

func main() {
	path := "main.go"
	size, err := GetFileSize(path)
	if err != nil {
		log.Fatalf("GetFileSize failed with '%s'\n", err)
	}
	fmt.Printf("File %s is %d bytes in size\n", path, size)
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-file-get-info
main.go:+356
// no playground
package main

import (
	"fmt"
	"log"
	"os"
)

// :show start

func main() {
	st, err := os.Stat("main.go")
	if err != nil {
		log.Fatalf("GetFileSize failed with '%s'\n", err)
	}
	fmt.Printf(`Name: %s
Size: %d
IsDir: %v
Mode: %x
ModTime: %s
OS info: %#v
`, st.Name(), st.Size(), st.IsDir(), st.Mode, st.ModTime(), st.Sys())
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-file-exists
main.go:+767
// no playground
package main

import (
	"fmt"
	"os"
)

// :show start

// IsPathxists returns true if a given path exists, false if it doesn't.
// It might return an error if e.g. file exists but you don't have
// access
func IsPathxists(path string) (bool, error) {
	_, err := os.Lstat(path)
	if err == nil {
		return true, nil
	}
	if os.IsNotExist(err) {
		return false, nil
	}
	// error other than not existing e.g. permission denied
	return false, err
}

func printExists(path string) {
	exists, err := IsPathxists(path)
	if err == nil {
		fmt.Printf("File '%s' exists: %v\n", path, exists)
	} else {
		fmt.Printf("IsFileExists('%s') failed with '%s'\n", path, err)
	}
}
func main() {
	printExists("main.go")
	printExists("non-existent-file.txt")
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-file-copy
main.go:+687
// no output
package main

import (
	"io"
	"log"
	"os"
)

// :show start
// CopyFile copies a src file to dst
func CopyFile(dst, src string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	_, err = io.Copy(dstFile, srcFile)
	err2 := dstFile.Close()
	if err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		// delete the destination if copy failed
		os.Remove(dst)
	}
	return err
}

// :show end

func main() {
	src := "main.go"
	dst := "main_copy.go"
	err := CopyFile(dst, src)
	if err != nil {
		log.Fatalf("CopyFile failed with '%s'\n", err)
	}
	os.Remove(dst)
}
---
@url: https://repl.it/@kjk1/gobook-file-list-files
main.go:+393
// no playground
package main

import (
	"fmt"
	"io/ioutil"
	"log"
)

// :show start
func main() {
	dir := "."
	fileInfos, err := ioutil.ReadDir(dir)
	if err != nil {
		log.Fatalf("ioutil.ReadDir('%s') failed with '%s'\n", dir, err)
	}
	for i, fi := range fileInfos {
		if i < 4 {
			fmt.Printf("Path: %s, is dir: %v, size: %d bytes\n", fi.Name(), fi.IsDir(), fi.Size())
		}
	}
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-file-filepathwalk
main.go:+457
package main

import (
	"fmt"
	"os"
	"path/filepath"
)

// :show start
func main() {
	nShown := 0
	err := filepath.Walk(".", func(path string, fi os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if nShown > 4 {
			return nil
		}
		nShown++
		fmt.Printf("Path: %s, is dir: %v, size: %d bytes\n", fi.Name(), fi.IsDir(), fi.Size())
		return nil
	})

	if err != nil {
		fmt.Printf("filepath.Walk failed with '%s'\n", err)
	}
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-time-format
main.go:+370
package main

import (
	"fmt"
	"time"
)

func main() {
	// :show start
	t := time.Date(2017, 9, 4, 3, 38, 45, 0, time.UTC)
	fmt.Println(t.Format("2006-02-01 15:04:05.000 MST"))
	fmt.Println(t.Format("2006-02-1 15pm"))
	fmt.Println(t.Format("Jan 06 Mon 2 01"))
	fmt.Println(t.Format("January 6 Mon 2 1"))
	fmt.Println(t.Format("Month: Jan '1', '01', _2"))
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-time-parse
main.go:+334
package main

import (
	"fmt"
	"log"
	"time"
)

func main() {
	// :show start
	s := "2017-04-09 03:38:45.000 UTC"
	t, err := time.Parse("2006-02-01 15:04:05.000 MST", s)
	if err != nil {
		log.Fatalf("time.Parse() failed wiht '%s'\n", err)
	}
	fmt.Printf("year: %d, month: %d, day: %d\n", t.Year(), t.Month(), t.Day())
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-time-strftime
main.go:+252
// no playground
package main

import (
	"fmt"
	"time"

	strftime "github.com/jehiah/go-strftime"
)

func main() {
	// :show start
	t := time.Date(2017, 9, 4, 3, 38, 45, 0, time.UTC)
	fmt.Println(strftime.Format("%Y-%m-%d %H:%M:%S", t))
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-cmdline-args-raw
main.go:+303
// :run go run $file -echo echo-arg additional arg
// no playground
package main

import (
	"fmt"
	"os"
)

// :show start
func main() {
	fmt.Printf("Name of executable: '%s'\n", os.Args[0])
	args := os.Args[1:]
	for i, arg := range args {
		fmt.Printf("Arg %d, value: '%s'\n", i, arg)
	}
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-exec-timeout
main.go:+570
// no playground
package main

import (
	"fmt"
	"log"
	"os/exec"
	"sync/atomic"
	"time"
)

func main() {
	// :show start
	cmd := exec.Command("go", "version")

	err := cmd.Start()
	if err != nil {
		log.Fatalf("cmd.Start() failed with '%s'\n", err)
	}

	var timedOut int32
	timeout := 1 * time.Millisecond
	stopTimer := time.AfterFunc(timeout, func() {
		cmd.Process.Kill()
		atomic.StoreInt32(&timedOut, 1)
	})

	err = cmd.Wait()
	stopTimer.Stop()
	didTimeout := atomic.LoadInt32(&timedOut) != 0
	fmt.Printf("didTimeout: %v, err: %v\n", didTimeout, err)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-exec-reuse-cmd
main.go:+398
// no playground, allow error
package main

import (
	"log"
	"os/exec"
)

func main() {
	// :show start
	cmd := exec.Command("go", "version")
	_, err := cmd.CombinedOutput()
	if err != nil {
		log.Fatalf("first cmd.CombintedOutput() failed with '%s'\n", err)
	}

	_, err = cmd.CombinedOutput()
	if err != nil {
		log.Fatalf("second cmd.CombintedOutput() failed with '%s'\n", err)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-hex
main.go:+403
package main

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"log"
)

func main() {
	// :show start
	d := []byte{0x01, 0xff, 0x3a, 0xcd}
	s := hex.EncodeToString(d)
	fmt.Printf("Hex: %s\n", s)

	d2, err := hex.DecodeString(s)
	if err != nil {
		log.Fatalf("hex.DecodeString() failed with '%s'\n", err)
	}
	if !bytes.Equal(d, d2) {
		log.Fatalf("decoded version is different than original")
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-hex-sprintf
main.go:+467
package main

import (
	"bytes"
	"fmt"
	"log"
)

func main() {
	// :show start
	d := []byte{0x01, 0xff, 0x3a, 0xcd}
	s := fmt.Sprintf("%x", d)
	fmt.Printf("Hex: %s\n", s)

	var decoded []byte
	_, err := fmt.Sscanf(s, "%x", &decoded)
	if err != nil {
		log.Fatalf("fmt.Sscanf() failed with '%s'\n", err)
	}
	if !bytes.Equal(d, decoded) {
		log.Fatalf("decoded version is different than original")
	}

	n := 3824
	fmt.Printf("%d in hex is 0x%x\n", n, n)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-hex-streaming
main.go:+693
package main

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"log"
)

func main() {
	// :show start
	d := []byte{0x01, 0xff, 0x3a, 0xcd}

	writer := &bytes.Buffer{}
	hexWriter := hex.NewEncoder(writer)

	_, err := hexWriter.Write(d)
	if err != nil {
		log.Fatalf("hexWriter.Write() failed with '%s'\n", err)
	}

	encoded := writer.Bytes()
	fmt.Printf("Hex: %s\n", string(encoded))

	reader := bytes.NewBuffer(encoded)
	hexReader := hex.NewDecoder(reader)

	decoded, err := ioutil.ReadAll(hexReader)
	if err != nil {
		fmt.Printf("ioutil.ReadAll() failed with '%s'\n", err)
	}

	if !bytes.Equal(d, decoded) {
		log.Fatalf("decoded version is different than original")
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-base64
main.go:+440

package main

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"log"
)

func main() {
	// :show start
	d := []byte{0x01, 0xff, 0x3a, 0xcd}
	s := base64.StdEncoding.EncodeToString(d)
	fmt.Printf("base64: %s\n", s)

	d2, err := base64.StdEncoding.DecodeString(s)
	if err != nil {
		log.Fatalf("hex.DecodeString() failed with '%s'\n", err)
	}
	if !bytes.Equal(d, d2) {
		log.Fatalf("decoded version is different than original")
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-base64-urlsafe
main.go:+439
package main

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"log"
)

func main() {
	// :show start
	d := []byte{0x01, 0xff, 0x3a, 0xcd}
	s := base64.URLEncoding.EncodeToString(d)
	fmt.Printf("base64: %s\n", s)

	d2, err := base64.URLEncoding.DecodeString(s)
	if err != nil {
		log.Fatalf("hex.DecodeString() failed with '%s'\n", err)
	}
	if !bytes.Equal(d, d2) {
		log.Fatalf("decoded version is different than original")
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-base64-streaming
main.go:+869
package main

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"log"
)

func main() {
	// :show start
	d := []byte{0x01, 0xff, 0x3a, 0xcd}

	writer := &bytes.Buffer{}
	base64Writer := base64.NewEncoder(base64.StdEncoding, writer)

	_, err := base64Writer.Write(d)
	if err != nil {
		log.Fatalf("base64Writer.Write() failed with '%s'\n", err)
	}
	err = base64Writer.Close()
	if err != nil {
		log.Fatalf("base64Writer.Close() failed with '%s'\n", err)
	}

	encoded := writer.Bytes()
	fmt.Printf("Base64: %s\n", string(encoded))

	reader := bytes.NewBuffer(encoded)
	base64Reader := base64.NewDecoder(base64.StdEncoding, reader)

	decoded, err := ioutil.ReadAll(base64Reader)
	if err != nil {
		fmt.Printf("ioutil.ReadAll() failed with '%s'\n", err)
	}

	if !bytes.Equal(d, decoded) {
		log.Fatalf("decoded version is different than original")
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-json-parse-arbitrary
main.go:+526
package main

import (
	"encoding/json"
	"fmt"
	"log"
)

// :show start
var jsonStr = `{
	"name": "Jane",
	"age": 24,
	"city": "ny"
}`

// :show end

func main() {
	// :show start
	var doc map[string]interface{}
	err := json.Unmarshal([]byte(jsonStr), &doc)
	if err != nil {
		log.Fatalf("json.Unmarshal failed with '%s'\n", err)
	}
	fmt.Printf("doc: %#v\n", doc)
	name, ok := doc["name"].(string)
	if !ok {
		log.Fatalf("doc has no key 'name' or its value is not string\n")
	}
	fmt.Printf("name: %#v\n", name)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-json-anon-structs
main.go:+1243
package main

import (
	"encoding/json"
	"fmt"
)

// :show start
var jsonBlob = []byte(`
{
  "_total": 1,
  "_links": {
	"self": "https://api.twitch.tv/kraken/channels/foo/subscriptions?direction=ASC&limit=25&offset=0",
	"next": "https://api.twitch.tv/kraken/channels/foo/subscriptions?direction=ASC&limit=25&offset=25"
  },
  "subscriptions": [
	{
	  "created_at": "2011-11-23T02:53:17Z",
	  "_id": "abcdef0000000000000000000000000000000000",
	  "_links": {
		"self": "https://api.twitch.tv/kraken/channels/foo/subscriptions/bar"
	  },
	  "user": {
		"display_name": "bar",
		"_id": 123456,
		"name": "bar",
		"created_at": "2011-06-16T18:23:11Z",
		"updated_at": "2014-10-23T02:20:51Z",
		"_links": {
		  "self": "https://api.twitch.tv/kraken/users/bar"
		}
	  }
	}
  ]
}
`)

// :show end

func main() {
	// :show start
	var js struct {
		Total int `json:"_total"`
		Links struct {
			Next string `json:"next"`
		} `json:"_links"`
		Subs []struct {
			Created string `json:"created_at"`
			User    struct {
				Name string `json:"name"`
				ID   int    `json:"_id"`
			} `json:"user"`
		} `json:"subscriptions"`
	}

	err := json.Unmarshal(jsonBlob, &js)
	if err != nil {
		fmt.Println("error:", err)
	}
	fmt.Printf("%+v", js)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-json-file
main.go:+1193
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
)

// :show start
type Student struct {
	Name     string
	Standard int `json:"Standard"`
}

func decodeFromReader(r io.Reader) ([]*Student, error) {
	var res []*Student

	dec := json.NewDecoder(r)
	err := dec.Decode(&res)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func decodeFromString(s string) ([]*Student, error) {
	r := bytes.NewBufferString(s)
	return decodeFromReader(r)
}

func decodeFromFile(path string) ([]*Student, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return decodeFromReader(f)
}

// :show end

const jsonStr = `
[
    {
        "Name" : "John Doe",
        "Standard" : 4
    },
    {
        "Name" : "Peter Parker",
        "Standard" : 11
    },
    {
        "Name" : "Bilbo Baggins",
        "Standard" : 150
    }
]
`

func main() {
	// studentList, err := decodeFromFile("data.json")
	studentList, err := decodeFromString(jsonStr)
	if err != nil {
		log.Fatalf("decodeFromString() failed with '%s'\n", err)
	}
	for _, student := range studentList {
		fmt.Printf("Student: %s, standard: %d\n", student.Name, student.Standard)
	}
}
---
@url: https://repl.it/@kjk1/gobook-json-custom-marshal
main.go:+1414
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"time"
)

func notCustom() {
	// :show start
	type Event struct {
		What string
		When time.Time
	}
	e := Event{
		What: "earthquake",
		When: time.Now(),
	}
	d, err := json.Marshal(&e)
	if err != nil {
		log.Fatalf("json.MarshalIndent failed with '%s'\n", err)
	}
	fmt.Printf("Standard time JSON: %s\n", string(d))
	// :show end
}

// :show start
type customTime time.Time

const customTimeFormat = `"2006-02-01"`

func (ct customTime) MarshalJSON() ([]byte, error) {
	t := time.Time(ct)
	s := t.Format(customTimeFormat)
	return []byte(s), nil
}

func (ct *customTime) UnmarshalJSON(d []byte) error {
	t, err := time.Parse(customTimeFormat, string(d))
	if err != nil {
		return err
	}
	*ct = customTime(t)
	return nil
}

type Event2 struct {
	What string
	When customTime
}

// :show end

func custom() {
	// :show start
	e := Event2{
		What: "earthquake",
		When: customTime(time.Now()),
	}
	d, err := json.Marshal(&e)
	if err != nil {
		log.Fatalf("json.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("\nCustom time JSON: %s\n", string(d))
	var decoded Event2
	err = json.Unmarshal(d, &decoded)
	if err != nil {
		log.Fatalf("json.Unmarshal failed with '%s'\n", err)
	}
	t := time.Time(decoded.When)
	fmt.Printf("Decoded custom time: %s\n", t.Format(customTimeFormat))
	// :show end
}

func main() {
	// :show start
	notCustom()
	custom()
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-json-marshal-private
main.go:+608
package main

import (
	"encoding/json"
	"fmt"
	"log"
)

// :show start
type MyStruct struct {
	uuid string
	Name string
}

func (m MyStruct) MarshalJSON() ([]byte, error) {
	j, err := json.Marshal(struct {
		Uuid string
		Name string
	}{
		Uuid: m.uuid,
		Name: m.Name,
	})
	if err != nil {
		return nil, err
	}
	return j, nil
}

// :show end

func main() {
	// :show start
	s := MyStruct{
		uuid: "uid-john",
		Name: "John",
	}
	d, err := json.Marshal(&s)
	if err != nil {
		log.Fatalf("json.MarshalIndent failed with '%s'\n", err)
	}
	fmt.Printf("Person in compact JSON: %s\n", string(d))

	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-json-type-mappings
main.go:+669
package main

import (
	"encoding/json"
	"fmt"
	"log"
)

// :show start
func printSerialized(v interface{}) {
	d, err := json.Marshal(v)
	if err != nil {
		log.Fatalf("json.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("%T: %s\n", v, string(d))
}

// :show end

func main() {
	// :show start
	printSerialized(nil)
	printSerialized(5)
	printSerialized(8.23)
	printSerialized("john")
	ai := []int{5, 4, 18}
	printSerialized(ai)
	a := []interface{}{4, "string"}
	printSerialized(a)
	d := map[string]interface{}{
		"i": 5,
		"s": "foo",
	}
	printSerialized(d)
	s := struct {
		Name string
		Age  int
	}{
		Name: "John",
		Age:  37,
	}
	printSerialized(s)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-xml-pull-streaming-parsing
main.go:+1392
package main

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"io"
)

// :show start
var xmlStr = `
<people>
	<person age="34">
		<first-name>John</first-name>
		<address>
			<city>San Francisco</city>
			<state>CA</state>
		</address>
	</person>
	<!-- sample comment -->
	<person age="23">
		<first-name>Julia</first-name>
	</person>
</people>`

// :show end

func main() {
	// :show start
	r := bytes.NewBufferString(xmlStr)
	decoder := xml.NewDecoder(r)
	inCityElement := false
	for {
		t, err := decoder.Token()
		if err == io.EOF {
			// io.EOF is a successful end
			break
		}
		if err != nil {
			fmt.Printf("decoder.Token() failed with '%s'\n", err)
			break
		}

		switch v := t.(type) {

		case xml.StartElement:
			if v.Name.Local == "person" {
				for _, attr := range v.Attr {
					if attr.Name.Local == "age" {
						fmt.Printf("Element: '<person>', attribute 'age' has value '%s'\n", attr.Value)
					}
				}
			} else if v.Name.Local == "city" {
				inCityElement = true
			}

		case xml.EndElement:
			if v.Name.Local == "city" {
				inCityElement = false
			}

		case xml.CharData:
			if inCityElement {
				fmt.Printf("City: %s\n", string(v))
			}

		case xml.Comment:
			fmt.Printf("Comment: %s\n", string(v))

		case xml.ProcInst:
			// handle XML processing instruction like <?target inst?>

		case xml.Directive:
			// handle XML directive like <!text>
		}
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-xml-hybrid-parsing
main.go:+1053
package main

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"io"
)

// :show start
var xmlStr = `
<people>
	<person age="34">
		<first-name>John</first-name>
		<address>
			<city>San Francisco</city>
			<state>CA</state>
		</address>
	</person>
	<person age="23">
		<address>
			<city>Austin</city>
			<state>TX</state>
		</address>
	</person>
</people>`

type Address struct {
	City  string `xml:"city"`
	State string `xml:"state"`
}

// :show end

func main() {
	// :show start
	r := bytes.NewBufferString(xmlStr)
	decoder := xml.NewDecoder(r)
	for {
		t, err := decoder.Token()
		if err == io.EOF {
			// io.EOF is a successful end
			break
		}
		if err != nil {
			fmt.Printf("decoder.Token() failed with '%s'\n", err)
			break
		}

		switch v := t.(type) {

		case xml.StartElement:
			if v.Name.Local == "address" {
				var address Address
				err = decoder.DecodeElement(&address, &v)
				if err != nil {
					fmt.Printf("decoder.DecodeElement() failed with '%s'\n", err)
					break
				}
				fmt.Printf("%+#v\n", address)
			}
		}
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-xml-parse-from-file
main.go:+1252
package main

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"io"
	"log"
	"os"
)

var xmlStr = `
<people>
	<person age="34">
		<first-name>John</first-name>
		<address>
			<city>San Francisco</city>
			<state>CA</state>
		</address>
	</person>

	<person age="23">
		<first-name>Julia</first-name>
	</person>
</people>`

type People struct {
	Person []Person `xml:"person"`
}

type Person struct {
	Age       int     `xml:"age,attr"`
	FirstName string  `xml:"first-name"`
	Address   Address `xml:"address"`
}

type Address struct {
	City  *string `xml:"city"`
	State string  `xml:"state"`
}

// :show start
func decodeFromReader(r io.Reader) (*People, error) {
	var people People
	decoder := xml.NewDecoder(r)
	err := decoder.Decode(&people)
	if err != nil {
		return nil, err
	}
	return &people, nil
}

func decodeFromString(s string) (*People, error) {
	r := bytes.NewBufferString(s)
	return decodeFromReader(r)
}

func decodeFromFile(path string) (*People, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return decodeFromReader(f)
}

// :show end

func main() {
	people, err := decodeFromString(xmlStr)
	if err != nil {
		log.Fatalf("decodeFromString failed with '%s'\n", err)
	}
	fmt.Printf("%#v\n\n", people)
}
---
@url: https://repl.it/@kjk1/gobook-xml-show-xmlname
main.go:+434
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start

type ShowXMLName struct {
	XMLName xml.Name `xml:"data"`
	N       int      `xml:"n"`
}

// :show end

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	// :show start
	v := &ShowXMLName{
		N: 5,
	}
	printXML(v)

	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-xml-show-omit
main.go:+478
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start
type ShowOmit struct {
	Name          string `xml:"name"`
	NotSerialized string `xml:"-"`
}

// :show end

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	// :show start
	v := &ShowOmit{
		Name:          "John",
		NotSerialized: "Connor",
	}
	printXML(v)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-xml-show-omit-empty
main.go:+484
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start

type ShowOmitEmpty struct {
	NonEmpty string `xml:",omitempty"`
	Empty    string `xml:",omitempty"`
}

// :show end

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	// :show start
	v := &ShowOmitEmpty{
		NonEmpty: "non empty",
		Empty:    "",
	}
	printXML(v)

	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-xml-show-attr
main.go:+394
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start
type ShowAttr struct {
	B bool `xml:"n,attr"`
}

// :show end

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	// :show start
	v := &ShowAttr{
		B: true,
	}
	printXML(v)

	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-xml-show-chardata
main.go:+408
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start
type ShowCharData struct {
	S string `xml:",chardata"`
}

// :show end

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	// :show start
	v := &ShowCharData{
		S: "str",
	}
	printXML(v)

	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-xml-show-cdata
main.go:+402
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start

type ShowCData struct {
	S string `xml:",cdata"`
}

// :show end

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	// :show start
	v := &ShowCData{
		S: "cdata",
	}
	printXML(v)

	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-show-innerxml
main.go:+464
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start
type ShowInnerXML struct {
	Str string `xml:"s"`
	Raw string `xml:",innerxml"`
}

// :show end

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	// :show start
	v := &ShowInnerXML{
		Str: "<foo></foo>",
		Raw: "<foo></foo>",
	}
	printXML(v)

	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-xml-show-comment
main.go:+413
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start
type ShowComment struct {
	Str string `xml:",comment"`
}

// :show end

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	// :show start
	v := &ShowComment{
		Str: "comment",
	}
	printXML(v)

	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-xml-show-nesting
main.go:+409
package main

import (
	"encoding/xml"
	"fmt"
	"log"
)

// :show start

type ShowNesting struct {
	Str string `xml:"a>b>str"`
}

// :show end

func printXML(v interface{}) {
	d, err := xml.Marshal(v)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("XML: %s\n\n", string(d))
}

func main() {
	// :show start
	v := &ShowNesting{
		Str: "str",
	}
	printXML(v)

	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-xml-custom-marshal
main.go:+1547
package main

import (
	"encoding/xml"
	"fmt"
	"log"
	"time"
)

func notCustom() {
	// :show start
	type Event struct {
		What string
		When time.Time
	}
	e := Event{
		What: "earthquake",
		When: time.Now(),
	}
	d, err := xml.Marshal(&e)
	if err != nil {
		log.Fatalf("json.MarshalIndent failed with '%s'\n", err)
	}
	fmt.Printf("Standard time JSON: %s\n", string(d))
	// :show end
}

// :show start
type customTime time.Time

const customTimeFormat = `2006-02-01`

func (ct customTime) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	t := time.Time(ct)
	v := t.Format(customTimeFormat)
	return e.EncodeElement(v, start)
}

func (ct *customTime) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var s string
	err := d.DecodeElement(&s, &start)
	if err != nil {
		return err
	}
	t, err := time.Parse(customTimeFormat, s)
	if err != nil {
		return err
	}
	*ct = customTime(t)
	return nil
}

type Event2 struct {
	What string
	When customTime
}

// :show end

func custom() {
	// :show start
	e := Event2{
		What: "earthquake",
		When: customTime(time.Now()),
	}
	d, err := xml.Marshal(&e)
	if err != nil {
		log.Fatalf("xml.Marshal failed with '%s'\n", err)
	}
	fmt.Printf("\nCustom time XML: %s\n", string(d))
	var decoded Event2
	err = xml.Unmarshal(d, &decoded)
	if err != nil {
		log.Fatalf("xml.Unmarshal failed with '%s'\n", err)
	}
	t := time.Time(decoded.When)
	fmt.Printf("Decoded custom time: %s\n", t.Format(customTimeFormat))
	// :show end
}

func main() {
	// :show start
	notCustom()
	custom()
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-http-client-post-url-encoded
main.go:+689
// no playground
package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"time"
)

func main() {
	// :show start
	client := &http.Client{}
	client.Timeout = time.Second * 15

	uri := "https://httpbin.org/post"
	data := url.Values{
		"name":  []string{"John"},
		"email": []string{"john@gmail.com"},
	}
	resp, err := client.PostForm(uri, data)
	if err != nil {
		log.Fatalf("client.PosFormt() failed with '%s'\n", err)
	}
	defer resp.Body.Close()
	_, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("ioutil.ReadAll() failed with '%s'\n", err)
	}

	fmt.Printf("PostForm() sent '%s'. Response status code: %d\n", data.Encode(), resp.StatusCode)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-http-client-put-json
main.go:+1037
// no playground
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"time"
)

type User struct {
	Name  string
	Email string
}

func main() {
	// :show start
	user := User{
		Name:  "John Doe",
		Email: "johndoe@example.com",
	}

	d, err := json.Marshal(user)
	if err != nil {
		log.Fatalf("json.Marshal() failed with '%s'\n", err)
	}

	client := &http.Client{}
	client.Timeout = time.Second * 15

	uri := "https://httpbin.org/put"
	body := bytes.NewBuffer(d)
	req, err := http.NewRequest(http.MethodPut, uri, body)
	if err != nil {
		log.Fatalf("http.NewRequest() failed with '%s'\n", err)
	}

	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	resp, err := client.Do(req)
	if err != nil {
		log.Fatalf("client.Do() failed with '%s'\n", err)
	}

	defer resp.Body.Close()
	d, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("ioutil.ReadAll() failed with '%s'\n", err)
	}

	fmt.Printf("Response status code: %d, text:\n%s\n", resp.StatusCode, string(d))
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-http-client-get-json
main.go:+1325
// no playground
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"time"
)

// :show start
type postItem struct {
	Score int    `json:"score"`
	Link  string `json:"link"`
}

type postsType struct {
	Items []postItem `json:"items"`
}

// :show end
func main() {
	// :show start
	values := url.Values{
		"order": []string{"desc"},
		"sort":  []string{"activity"},
		"site":  []string{"stackoverflow"},
	}

	// URL parameters can also be programmatically set
	values.Set("page", "1")
	values.Set("pagesize", "10")

	uri := "https://api.stackexchange.com/2.2/posts?"
	client := &http.Client{
		Timeout: 15 * time.Second,
	}
	resp, err := client.Get(uri + values.Encode())
	if err != nil {
		log.Fatalf("http.Get() failed with '%s'\n", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		d, _ := ioutil.ReadAll(resp.Body)
		log.Fatalf("Request was '%s' (%d) and not OK (200). Body:\n%s\n", resp.Status, resp.StatusCode, string(d))
	}

	dec := json.NewDecoder(resp.Body)
	var p postsType
	err = dec.Decode(&p)
	if err != nil {
		log.Fatalf("dec.Decode() failed with '%s'\n", err)
	}

	fmt.Println("Top 10 most recently active StackOverflow posts:")
	fmt.Println("Score", "Link")
	for _, post := range p.Items {
		fmt.Println(post.Score, post.Link)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-http-client-user-agent
main.go:+775
// no playground
package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"time"
)

func main() {
	// :show start
	userAgent := "Special Agent v 1.0.16"

	client := &http.Client{}
	client.Timeout = time.Second * 15

	uri := "https://httpbin.org/user-agent"
	req, err := http.NewRequest(http.MethodGet, uri, nil)
	if err != nil {
		log.Fatalf("http.NewRequest() failed with '%s'\n", err)
	}
	req.Header.Set("User-Agent", userAgent)
	resp, err := client.Do(req)
	if err != nil {
		log.Fatalf("client.Do() failed with '%s'\n", err)
	}

	defer resp.Body.Close()
	d, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("ioutil.ReadAll() failed with '%s'\n", err)
	}

	fmt.Printf("Response status code: %d, text:\n%s\n", resp.StatusCode, string(d))
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-template-methods-as-data
main.go:+587
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
var tmplStr = `Data from a field: '{{ .Field }}'
Data from a method: '{{ .Method }}'
`

// :show end

type Data struct {
	Field int
}

func (d Data) Method() string {
	return "data from a method"
}

func main() {
	// :show start
	t := template.New("method")
	t, err := t.Parse(tmplStr)
	if err != nil {
		log.Fatalf("template.Parse() failed with '%s'\n", err)
	}

	data := Data{
		Field: 5,
	}

	err = t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-template-if
main.go:+510
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
const tmplStr = `{{range . -}}
{{if .IsNew}}'{{.Name}}' is new{{else}}'{{.Name}}' is not new{{end}}
{{end}}`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("if").Parse(tmplStr))

	data := []struct {
		Name  string
		IsNew bool
	}{
		{"Bridge", false},
		{"Electric battery", true},
	}

	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-template-if-2
main.go:+867
package main

import (
	"log"
	"math"
	"os"
	"text/template"
)

// :show start
const tmplStr = `{{range . -}}
{{printf "%- 16s" .Name}} is: {{if .Value}}true{{else}}false{{end}}
{{end}}`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("if").Parse(tmplStr))

	var nilPtr *string = nil
	var nilSlice []float32
	emptySlice := []int{}

	data := []struct {
		Name  string
		Value interface{}
	}{
		{"bool false", false},
		{"bool true", true},
		{"integer 0", 0},
		{"integer 1", 1},
		{"float32 0", float32(0)},
		{"float64 NaN", math.NaN},
		{"empty string", ""},
		{"non-empty string", "haha"},
		{"nil slice", nilSlice},
		{"empty slice", emptySlice},
		{"non-empty slice", []int{3}},
		{"nil pointer", nilPtr},
	}

	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-template-if-empty-slice
main.go:+774
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
type UserTweets struct {
	User   string
	Tweets []string
}

const tmplStr = `
{{- if not .Tweets -}}
User '{{.User}}' has no tweets.
{{ else -}}
User '{{.User}}' has {{ len .Tweets }} tweets:
{{ range .Tweets -}}
  '{{ . }}'
{{ end }}
{{- end}}`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("if").Parse(tmplStr))

	data := UserTweets{
		User: "kjk",
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

	data = UserTweets{
		User:   "masa",
		Tweets: []string{"tweet one", "tweet two"},
	}
	err = t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-template-range-slice
main.go:+531
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
const tmplStr = `Elements of arrays or slice: {{ range . }}{{ . }} {{end}}
`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("range").Parse(tmplStr))

	array := [...]int{3, 8}
	err := t.Execute(os.Stdout, array)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

	slice := []int{12, 5}
	err = t.Execute(os.Stdout, slice)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-template-range-map
main.go:+436
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
const tmplStr = `Elements of map:
{{ range $k, $v := . }}{{ $k }}: {{ $v }}
{{end}}`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("range").Parse(tmplStr))

	data := map[string]int{
		"one":  1,
		"five": 5,
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-template-range-channel
main.go:+460
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
const tmplStr = `Elements of a channel: {{ range . }}{{ . }} {{end}}
`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("range").Parse(tmplStr))

	ch := make(chan int)
	go func() {
		for i := 0; i < 3; i++ {
			ch <- i
		}
		close(ch)
	}()
	err := t.Execute(os.Stdout, ch)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-template-and-or
main.go:+578
package main

import (
	"log"
	"os"
	"text/template"
)

type Data struct {
	True  bool
	False bool
}

// :show start
const tmplStr = `Or:  {{ if or .True .False }}true{{ else }}false{{ end }}
And: {{ if and .True .False }}true{{ else }}false{{ end }}
Not: {{ if not .False }}true{{ else }}false{{ end }}
`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("and_or_not").Parse(tmplStr))

	data := Data{True: true, False: false}

	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-template-index-func
main.go:+659
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
const tmplStr = `Slice[0]: {{ index .Slice 0 }}
SliceNested[1][0]: {{ index .SliceNested 1 0 }}
Map["key"]: {{ index .Map "key" }}
`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("index").Parse(tmplStr))

	data := struct {
		Slice       []string
		SliceNested [][]int
		Map         map[string]int
	}{
		Slice: []string{"first", "second"},
		SliceNested: [][]int{
			{3, 1},
			{2, 3},
		},
		Map: map[string]int{
			"key": 5,
		},
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-template-len
main.go:+701
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
const tmplStr = `len(nil)       : {{ len .SliceNil }}
len(emptySlice): {{ len .SliceEmpty }}
len(slice)     : {{ len .Slice }}
len(map)       : {{ len .Map }}
`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("len").Parse(tmplStr))

	data := struct {
		SliceNil   []int
		SliceEmpty []string
		Slice      []bool
		Map        map[int]bool
	}{
		SliceNil:   nil,
		SliceEmpty: []string{},
		Slice:      []bool{true, true, false},
		Map:        map[int]bool{5: true, 3: false},
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-template-print
main.go:+501
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
const tmplStr = `print:   {{ print .Str .Num }}
println: {{ println .Str .Num }}
printf:  {{ printf "%s %#v %d" .Str .Str .Num }}
`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("print").Parse(tmplStr))

	data := struct {
		Str string
		Num int
	}{
		Str: "str",
		Num: 8,
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-template-js-html-url-escape
main.go:+586
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
const tmplStr = `js escape  : {{ js .JS }}
html escape: {{ html .HTML }}
url escape : {{ urlquery .URL }}
`

// :show end

func main() {
	// :show start
	t := template.Must(template.New("print").Parse(tmplStr))

	data := struct {
		JS   string
		HTML string
		URL  string
	}{
		JS:   `function me(s) { return "foo"; }`,
		HTML: `<div>text</div>`,
		URL:  `http://www.programming-books.io`,
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-template-custom-function
main.go:+506
package main

import (
	"log"
	"os"
	"text/template"
)

// :show start
const tmplStr = `5 + 5 = {{ sum 5 .Arg }}
`

// :show end

func sum(x, y int) int {
	return x + y
}

func main() {
	// :show start
	customFunctions := template.FuncMap{
		"sum": sum,
	}

	t := template.Must(template.New("func").Funcs(customFunctions).Parse(tmplStr))

	data := struct {
		Arg int
	}{
		Arg: 5,
	}
	err := t.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-template-html
main.go:+776
package main

import (
	"fmt"
	html_template "html/template"
	"log"
	"os"
	text_template "text/template"
)

// :show start
const tmplStr = `<div onlick="{{ .JS }}">{{ .HTML }}</div>
`

// :show end

func main() {
	// :show start
	txt := text_template.Must(text_template.New("text").Parse(tmplStr))

	html := html_template.Must(html_template.New("html").Parse(tmplStr))

	data := struct {
		JS   string
		HTML string
		URL  string
	}{
		JS:   `foo`,
		HTML: `<span>text</span>`,
		URL:  `http://www.programming-books.io`,
	}

	err := txt.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

	fmt.Println()

	err = html.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-template-html-raw
main.go:+747
package main

import (
	"fmt"
	"html/template"
	"log"
	"os"
)

// :show start
const tmplStr = `<div onlick="{{ .JS }}">{{ .HTML }}</div>
`

// :show end

func main() {
	// :show start

	html := template.Must(template.New("html").Parse(tmplStr))

	data := struct {
		JS   string
		HTML string
	}{
		JS:   `foo`,
		HTML: `<span>text</span>`,
	}

	fmt.Printf("Escaped:\n")
	err := html.Execute(os.Stdout, data)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

	fmt.Printf("\nUnescaped:\n")
	data2 := struct {
		JS   template.JS
		HTML template.HTML
	}{
		JS:   `foo`,
		HTML: `<span>text</span>`,
	}
	err = html.Execute(os.Stdout, data2)
	if err != nil {
		log.Fatalf("t.Execute() failed with '%s'\n", err)
	}

	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-reflection-get-type
main.go:+632
package main

import (
	"fmt"
	"reflect"
)

// :show start

func printType(v interface{}) {
	rv := reflect.ValueOf(v)
	typ := rv.Type()
	typeName := ""
	switch rv.Kind() {
	case reflect.Ptr:
		typeName = "pointer"
	case reflect.Int:
		typeName = "int"
	case reflect.Int32:
		typeName = "int32"
	case reflect.String:
		typeName = "string"
	// ... handle more cases
	default:
		typeName = "unrecognized type"
	}
	fmt.Printf("v is of type '%s'. Size: %d bytes\n", typeName, typ.Size())
}

// :show end

func main() {
	// :show start
	printType(int32(3))
	printType("")
	i := 3
	printType(&i) // *int i.e. pointer to int
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-reflection-get-value
main.go:+328

// allow error
package main

import (
	"fmt"
	"reflect"
)

// :show start

func getIntValue(v interface{}) {
	var reflectValue = reflect.ValueOf(v)
	n := reflectValue.Int()
	fmt.Printf("Int value is: %d\n", n)
}

// :show end

func main() {
	// :show start
	getIntValue(3)
	getIntValue(int8(4))
	getIntValue("")
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-reflection-get-value
main.go:+327
// allow error
package main

import (
	"fmt"
	"reflect"
)

// :show start

func getIntValue(v interface{}) {
	var reflectValue = reflect.ValueOf(v)
	n := reflectValue.Int()
	fmt.Printf("Int value is: %d\n", n)
}

// :show end

func main() {
	// :show start
	getIntValue(3)
	getIntValue(int8(4))
	getIntValue("")
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-reflection-set-value
main.go:+1125
package main

import (
	"fmt"
	"reflect"
)

// :show start
type S struct {
	N int
}

func setIntPtr() {
	var n int = 2
	reflect.ValueOf(&n).Elem().SetInt(4)
	fmt.Printf("setIntPtr: n=%d\n", n)
}

func setStructFieldDirect() {
	var s S
	reflect.ValueOf(&s.N).Elem().SetInt(5)
	fmt.Printf("setStructFieldDirect: n=%d\n", s.N)
}

func setStructPtrField() {
	var s S
	reflect.ValueOf(&s).Elem().Field(0).SetInt(6)
	fmt.Printf("setStructPtrField: s.N: %d\n", s.N)
}

func handlePanic(funcName string) {
	if msg := recover(); msg != nil {
		fmt.Printf("%s panicked with '%s'\n", funcName, msg)
	}
}

func setStructField() {
	defer handlePanic("setStructField")
	var s S
	reflect.ValueOf(s).Elem().Field(0).SetInt(4)
	fmt.Printf("s.N: %d\n", s.N)
}

func setInt() {
	defer handlePanic("setInt")
	var n int = 2
	rv := reflect.ValueOf(n)
	rv.Elem().SetInt(4)
}

func setIntPtrWithString() {
	defer handlePanic("setIntPtrWithString")
	var n int = 2
	reflect.ValueOf(&n).Elem().SetString("8")
}

// :show end

func main() {
	setIntPtr()
	setStructFieldDirect()
	setStructPtrField()

	setInt()
	setStructField()

	setIntPtrWithString()
}
---
@url: https://repl.it/@kjk1/gobook-reflection-pointers
main.go:+525

package main

import (
	"fmt"
	"reflect"
)

// :show start
func printIntResolvingPointers(v interface{}) {
	rv := reflect.ValueOf(v)
	typeName := rv.Type().String()
	name := ""
	for rv.Kind() == reflect.Ptr {
		name = "pointer to " + name
		rv = rv.Elem()
	}
	name += rv.Type().String()
	fmt.Printf("Value: %d. Type: '%s' i.e. '%s'.\n\n", rv.Int(), name, typeName)
}

func main() {
	n := 3
	printIntResolvingPointers(n)

	n = 4
	printIntResolvingPointers(&n)

	n = 5
	np := &n
	printIntResolvingPointers(&np)
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-reflection-enum-struct-fields-simple
main.go:+884
package main

import (
	"fmt"
	"reflect"
)

// :show start

type S struct {
	FirstName string `my_tag:"first-name"`
	lastName  string
	Age       int `json:"age",xml:"AgeXml`
}

func describeStructSimple(rv reflect.Value) {
	structType := rv.Type()
	for i := 0; i < rv.NumField(); i++ {
		v := rv.Field(i)
		structField := structType.Field(i)
		name := structField.Name
		typ := structField.Type
		tag := structField.Tag
		jsonTag := tag.Get("json")
		isExported := structField.PkgPath == ""
		if isExported {
			fmt.Printf("name: '%s',\ttype: '%s', value: %v,\ttag: '%s',\tjson tag: '%s'\n", name, typ, v.Interface(), tag, jsonTag)
		} else {
			fmt.Printf("name: '%s',\ttype: '%s',\tvalue: not accessible\n", name, v.Type().Name())
		}
	}
}

func main() {
	s := S{
		FirstName: "John",
		lastName:  "Doe",
		Age:       27,
	}
	describeStructSimple(reflect.ValueOf(s))
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-reflection-enum-struct-fields
main.go:+1694
package main

import (
	"fmt"
	"reflect"
	"strings"
)

// :show start
type Inner struct {
	N int
}

type S struct {
	Inner
	NamedInner Inner
	PtrInner   *Inner
	unexported int
	N          int8
}

func indentStr(level int) string {
	return strings.Repeat("  ", level)
}

// if sf is not nil, this is a field of a struct
func describeStruct(level int, rv reflect.Value, sf *reflect.StructField) {
	structType := rv.Type()
	nFields := rv.NumField()
	typ := rv.Type()
	if sf == nil {
		fmt.Printf("%sstruct %s, %d field(s), size: %d bytes\n", indentStr(level), structType.Name(), nFields, typ.Size())
	} else {
		fmt.Printf("%sname: '%s' type: 'struct %s', offset: %d, %d field(s), size: %d bytes, embedded: %v\n", indentStr(level), sf.Name, structType.Name(), sf.Offset, nFields, typ.Size(), sf.Anonymous)
	}

	for i := 0; i < nFields; i++ {
		fv := rv.Field(i)
		sf := structType.Field(i)
		describeType(level+1, fv, &sf)
	}
}

// if sf is not nil, this is a field of a struct
func describeType(level int, rv reflect.Value, sf *reflect.StructField) {
	switch rv.Kind() {

	case reflect.Int, reflect.Int8:
		// in real code we would handle more primitive types
		i := rv.Int()
		typ := rv.Type()
		if sf == nil {
			fmt.Printf("%stype: '%s', value: '%d'\n", indentStr(level), typ.Name(), i)
		} else {
			fmt.Printf("%s name: '%s' type: '%s', value: '%d', offset: %d, size: %d\n", indentStr(level), sf.Name, typ.Name(), i, sf.Offset, typ.Size())
		}

	case reflect.Ptr:
		fmt.Printf("%spointer\n", indentStr(level))
		describeType(level+1, rv.Elem(), nil)

	case reflect.Struct:
		describeStruct(level, rv, sf)
	}
}

func main() {
	var s S
	describeType(0, reflect.ValueOf(s), nil)
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-reflection-slice
main.go:+566
package main

import (
	"fmt"
	"reflect"
)

func main() {
	// :show start
	a := []int{3, 1, 8}
	rv := reflect.ValueOf(a)

	fmt.Printf("len(a): %d\n", rv.Len())
	fmt.Printf("cap(a): %d\n", rv.Cap())

	fmt.Printf("slice kind: '%s'\n", rv.Kind().String())

	fmt.Printf("element type: '%s'\n", rv.Type().Elem().Name())

	el := rv.Index(0).Interface()
	fmt.Printf("a[0]: %v\n", el)

	elRef := rv.Index(1)
	fmt.Printf("elRef.CanAddr(): %v\n", elRef.CanAddr())
	fmt.Printf("elRef.CanSet(): %v\n", elRef.CanSet())

	elRef.SetInt(5)
	fmt.Printf("a: %v\n", a)

	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-reflection-create-slice
main.go:+315

package main

import (
	"fmt"
	"reflect"
)

func main() {
	// :show start
	typ := reflect.SliceOf(reflect.TypeOf("example"))
	// create slice with capacity 10 and length 1
	rv := reflect.MakeSlice(typ, 1, 10)
	rv.Index(0).SetString("foo")

	a := rv.Interface().([]string)
	fmt.Printf("a: %#v\n", a)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-context-with-value
main.go:+844
package main

import (
	"context"
	"fmt"
)

// :show start
type User struct {
	Name       string
	IsLoggedIn bool
}

type userKeyType int

var userKey userKeyType

func contextWithUser(ctx context.Context, user *User) context.Context {
	return context.WithValue(ctx, userKey, user)
}

// returns nil if not set
func getUserFromContext(ctx context.Context) *User {
	user, ok := ctx.Value(userKey).(*User)
	if !ok {
		return nil
	}
	return user
}

// will panic if not set
func mustGetUserFromContext(ctx context.Context) *User {
	return ctx.Value(userKey).(*User)
}

func printUser(ctx context.Context) {
	user := getUserFromContext(ctx)
	fmt.Printf("User: %#v\n", user)
}

func main() {
	ctx := context.Background()
	user := &User{
		Name:       "John",
		IsLoggedIn: false,
	}
	ctx = contextWithUser(ctx, user)

	printUser(ctx)
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-context-cancellable-function
main.go:+752

package main

import (
	"context"
	"fmt"
	"time"
)

// :show start
func longMathOp(ctx context.Context, n int) (int, error) {
	res := n
	for i := 0; i < 100; i++ {
		select {
		case <-ctx.Done():
			return 0, ctx.Err()
		default:
			res += i
			// simulate long operation by sleeping
			time.Sleep(time.Millisecond)
		}
	}
	return res, nil
}

func main() {
	ctx, _ := context.WithTimeout(context.Background(), time.Millisecond*200)
	res, err := longMathOp(ctx, 5)
	fmt.Printf("Called longMathOp() with 200ms timeout. res; %d, err: %v\n", res, err)

	ctx, _ = context.WithTimeout(context.Background(), time.Millisecond*10)
	res, err = longMathOp(ctx, 5)
	fmt.Printf("Called longMathOp() with 10ms timeout. res: %d, err: %v\n", res, err)
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-oo-interface-polymorhism
main.go:+604
package main

import (
	"fmt"
)

type Runner interface {
	Run()
}

type Admin struct {
	Username, Password string
}

func (admin Admin) Run() {
	fmt.Println("Admin ==> Run()")
}

type User struct {
	ID              uint64
	FullName, Email string
}

func (user User) Run() {
	fmt.Println("User ==> Run()")
}

// RunnerExample takes any type that fullfils the Runner interface
func RunnerExample(r Runner) {
	r.Run()
}

func main() {
	admin := Admin{
		"zola",
		"supersecretpassword",
	}

	user := User{
		1,
		"Zelalem Mekonen",
		"zola.mk.27@gmail.com",
	}

	RunnerExample(admin)

	RunnerExample(user)
}
---
@url: https://repl.it/@kjk1/gobook-cryptography-encrypt-decrypt
main.go:+2280
package main

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"log"

	"golang.org/x/crypto/scrypt"
)

func aesKeyFromPassword(password string) ([]byte, error) {
	// DO NOT use this salt value; generate your own random salt. 8 bytes is
	// a good length. Keep the salt secret.
	secretSalt := []byte{0xbc, 0x1e, 0x07, 0xd7, 0xb2, 0xa2, 0x5e, 0x2c}
	return scrypt.Key([]byte(password), secretSalt, 32768, 8, 1, 32)
}

func aesGcmEncrypt(unencrypted []byte, password string) ([]byte, error) {
	key, err := aesKeyFromPassword(password)
	if err != nil {
		return nil, err
	}
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	// generate a random nonce (makes encryption stronger)
	nonce := make([]byte, gcm.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, err
	}

	encrypted := gcm.Seal(nil, nonce, unencrypted, nil)
	// we need nonce for decryption so we put it at the beginning
	// of encrypted text
	return append(nonce, encrypted...), nil
}

func aesGcmDecrypt(encrypted []byte, password string) ([]byte, error) {
	key, err := aesKeyFromPassword(password)
	if err != nil {
		return nil, err
	}

	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	if len(encrypted) < gcm.NonceSize() {
		return nil, errors.New("Invalid data")
	}

	// extract random nonce we added to the beginning of the file
	nonce := encrypted[:gcm.NonceSize()]
	encrypted = encrypted[gcm.NonceSize():]

	return gcm.Open(nil, nonce, encrypted, nil)
}

func main() {
	password := "my password"
	d, err := ioutil.ReadFile("encrypt_decrypt.go")
	if err != nil {
		log.Fatalf("ioutil.ReadFile() failed with %s\n", err)
	}
	encrypted, err := aesGcmEncrypt(d, password)
	if err != nil {
		log.Fatalf("aesGcmEncrypt() failed with %s\n", err)
	}
	decrypted, err := aesGcmDecrypt(encrypted, password)
	if err != nil {
		log.Fatalf("aesGcmDecrypt() failed with %s\n", err)
	}
	if !bytes.Equal(d, decrypted) {
		log.Fatalf("decryption created data different than original\n")
	} else {
		fmt.Printf("Encryption in decryption worked!\n")
	}
}
---
@url: https://repl.it/@kjk1/gobook-cryptography-encrypt-decrypt
main.go:+2269
package main

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"log"

	"golang.org/x/crypto/scrypt"
)

func aesKeyFromPassword(password string) ([]byte, error) {
	// DO NOT use this salt value; generate your own random salt. 8 bytes is
	// a good length. Keep the salt secret.
	secretSalt := []byte{0xbc, 0x1e, 0x07, 0xd7, 0xb2, 0xa2, 0x5e, 0x2c}
	return scrypt.Key([]byte(password), secretSalt, 32768, 8, 1, 32)
}

func aesGcmEncrypt(unencrypted []byte, password string) ([]byte, error) {
	key, err := aesKeyFromPassword(password)
	if err != nil {
		return nil, err
	}
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	// generate a random nonce (makes encryption stronger)
	nonce := make([]byte, gcm.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, err
	}

	encrypted := gcm.Seal(nil, nonce, unencrypted, nil)
	// we need nonce for decryption so we put it at the beginning
	// of encrypted text
	return append(nonce, encrypted...), nil
}

func aesGcmDecrypt(encrypted []byte, password string) ([]byte, error) {
	key, err := aesKeyFromPassword(password)
	if err != nil {
		return nil, err
	}

	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	if len(encrypted) < gcm.NonceSize() {
		return nil, errors.New("Invalid data")
	}

	// extract random nonce we added to the beginning of the file
	nonce := encrypted[:gcm.NonceSize()]
	encrypted = encrypted[gcm.NonceSize():]

	return gcm.Open(nil, nonce, encrypted, nil)
}

func main() {
	password := "my password"
	d, err := ioutil.ReadFile("main.go")
	if err != nil {
		log.Fatalf("ioutil.ReadFile() failed with %s\n", err)
	}
	encrypted, err := aesGcmEncrypt(d, password)
	if err != nil {
		log.Fatalf("aesGcmEncrypt() failed with %s\n", err)
	}
	decrypted, err := aesGcmDecrypt(encrypted, password)
	if err != nil {
		log.Fatalf("aesGcmDecrypt() failed with %s\n", err)
	}
	if !bytes.Equal(d, decrypted) {
		log.Fatalf("decryption created data different than original\n")
	} else {
		fmt.Printf("Encryption in decryption worked!\n")
	}
}
---
