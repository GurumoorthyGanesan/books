@url: https://repl.it/@kjk1/getting-started-hello-world
main.go:+74
package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}

---
@url: https://repl.it/@kjk1/getting-started-hello-world
main.go:+80
package main

import "fmt"

func main() {
	fmt.Println("Hello there, 世界")
}

---
@url: https://repl.it/@kjk1/getting-started-hello-world
main.go:+74
package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}

---
@url: https://repl.it/@kjk1/book-booleans
main.go:+229
package main

import "fmt"

func main() {
	// :show start
	var b bool = true
	fmt.Printf("b is: '%v'\n", b)
	b = false
	fmt.Printf("b is: '%v'\n", b)
	var b2 bool
	fmt.Printf("zero value of bool is: '%v'\n", b2)
	// :show end
}


---
@url: https://repl.it/@kjk1/book-booleans2
main.go:+155
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	// :show start
	b := true
	fmt.Printf("size of bool is: %d\n", unsafe.Sizeof(b))
	// :show end
}

---
@url: https://repl.it/@kjk1/book-int-to-str-itoa
main.go:+218
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// :show start
	var i1 int = -38
	fmt.Printf("i1: %s\n", strconv.Itoa(i1))

	var i2 int32 = 148
	fmt.Printf("i2: %s\n", strconv.Itoa(int(i2)))
	// :show end
}

---
@url: https://repl.it/@kjk1/book-int-to-str-sprintf
main.go:+231
package main

import (
	"fmt"
)

func main() {
	// :show start
	var i1 int = -38
	s1 := fmt.Sprintf("%d", i1)
	fmt.Printf("i1: %s\n", s1)

	var i2 int32 = 148
	s2 := fmt.Sprintf("%d", i2)
	fmt.Printf("i2: %s\n", s2)
	// :show end
}
---
@url: https://repl.it/@kjk1/book-int-from-string-atoi
main.go:+238
package main

import (
	"fmt"
	"log"
	"strconv"
)

func main() {
	// :show start
	s := "-48"
	i1, err := strconv.Atoi(s)
	if err != nil {
		log.Fatalf("strconv.Atoi() failed with %s\n", err)
	}
	fmt.Printf("i1: %d\n", i1)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-int-to-str-sscanf
main.go:+242
package main

import (
	"fmt"
	"log"
)

func main() {
	// :show start
	s := "348"
	var i int
	_, err := fmt.Sscanf(s, "%d", &i)
	if err != nil {
		log.Fatalf("fmt.Sscanf failed with '%s'\n", err)
	}
	fmt.Printf("i1: %d\n", i)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-floating-point
main.go:+336
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// :show start
	var f32 float32 = 1.3
	bitSize := 32
	s1 := strconv.FormatFloat(float64(f32), 'E', -1, bitSize)
	fmt.Printf("f32: %s\n", s1)

	var f64 float64 = 8.1234
	bitSize = 64
	s2 := strconv.FormatFloat(f64, 'e', -1, bitSize)
	fmt.Printf("f64: %s\n", s2)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-floating-point-2
main.go:+158
package main

import "fmt"

func main() {
	// :show start
	var f64 float64 = 1.54
	s := fmt.Sprintf("%f", f64)
	fmt.Printf("f is: '%s'\n", s)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-floating-point-3
main.go:+262
package main

import (
	"fmt"
	"log"
	"strconv"
)

func main() {
	// :show start
	s := "1.2341"
	f64, err := strconv.ParseFloat(s, 64)
	if err != nil {
		log.Fatalf("strconv.ParseFloat() failed with '%s'\n", err)
	}
	fmt.Printf("f64: %f\n", f64)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-floating-point-4
main.go:+248
package main

import (
	"fmt"
	"log"
)

func main() {
	// :show start
	s := "1.2341"
	var f float64
	_, err := fmt.Sscanf(s, "%f", &f)
	if err != nil {
		log.Fatalf("fmt.Sscanf failed with '%s'\n", err)
	}
	fmt.Printf("f: %f\n", f)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-characters
main.go:+191
package main

import "fmt"

func main() {
	// :show start
	s := "str"
	for i := 0; i < len(s); i++ {
		c := s[i]
		fmt.Printf("Byte at index %d is '%c' (0x%x)\n", i, c, c)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-characters-2
main.go:+188
package main

import "fmt"

func main() {
	// :show start
	s := "日本語"
	for i, runeChar := range s {
		fmt.Printf("Rune at byte position %d is %#U\n", i, runeChar)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-strings
main.go:+286
package main

import "fmt"

func main() {
	// :show start
	var s string // empty string ""
	s1 := "string\nliteral\nwith\tescape characters\n"
	s2 := `raw string literal
which doesnt't recgonize escape characters like \n
`
	fmt.Printf("sum of strings\n'%s'\n", s+s1+s2)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-constants
main.go:+414
// no output
package main

// :show start
const (
	i  int = 32       // int constant
	s      = "string" // string constant
	i2     = 33       // untyped number constant
)

var (
	// values that are not read-only (like slices or maps or structs) cannot be
	// constants
	// we can declare them as top-level variables
	b = []byte{3, 4} // this could not be a constant
)

// :show end

func main() {
	// do nothing
}

---
@url: https://repl.it/@kjk1/book-array-basics
main.go:+289
package main

import "fmt"

func main() {
	// :show start
	var a1 = [2]byte{3, 8} // array of 2 bytes
	// when using [...] size will be deduced from { ... }
	a2 := [...]int{1, 2, 3} // array of 3 integers

	fmt.Printf("Size of a1: %d.\nSize of a2: %d\n", len(a1), len(a2))
	// :show end
}

---
@url: https://repl.it/@kjk1/book-map-basics
main.go:+545
package main

import "fmt"

func main() {
	// :show start
	m := make(map[string]int)
	m["number3"] = 3

	checkKey := func(k string) {
		if n, ok := m[k]; ok {
			fmt.Printf("value for key '%s' is %d\n", k, n)
		} else {
			fmt.Printf("key '%s' doesn't exist in map\n", k)
		}
	}

	// get value for a key that exists
	checkKey("number3")

	// get value for a key that doesn't exist
	checkKey("number4")

	// remove a key
	delete(m, "number3")
	fmt.Printf("deleted key 'number3\n")
	checkKey("number3") // and now it doesn't exist
	// :show end
}

---
@url: https://repl.it/@kjk1/book-structs-basics
main.go:+182
// no output
package main

// :show start
type MyStruct struct {
	IntVal           int
	StringVal        string
	unexportedIntVal int
}

// :show end

func main() {
	// do nothing
}

---
@url: https://repl.it/@kjk1/book-pointers-basics
main.go:+180
package main

import "fmt"

func main() {
	// :show start
	var a int = 4
	pa := &a
	fmt.Printf("Address of a variable in memory is %p. Its value is: %d\n", pa, *pa)
	// :show end
}
---
@url: https://repl.it/@kjk1/book-channels-basics
main.go:+364
package main

import "fmt"

func main() {
	// :show start
	// create unbuffered channel of int values with capacity of 1
	ch := make(chan int)
	// start a new goroutine that sends value 3 over a channel
	go func() { ch <- 3 }()
	// read the value from a channel
	// it waits until goroutine above sends a value
	n := <-ch
	fmt.Printf("n: %d\n", n)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-zero-values
main.go:+1008
package main

import "fmt"

func main() {
	// :show start
	var zeroBool bool
	var zeroInt int
	var zeroF32 float32
	var zeroF64 float64
	var zeroStr string
	var zeroPtr *int
	var zeroSlice []uint32
	var zeroMap map[string]int
	var zeroInterface interface{}
	var zeroChan chan bool
	var zeroArray [5]int
	type struc struct {
		a int
		b string
	}
	var zeroStruct struc
	var zeroFunc func(bool)

  fmt.Println("zero values for basic types:")
	fmt.Printf("bool:       %v\n", zeroBool)
	fmt.Printf("int:        %v\n", zeroInt)
	fmt.Printf("float32:    %v\n", zeroF32)
	fmt.Printf("float64:    %v\n", zeroF64)
	fmt.Printf("string:     %#v\n", zeroStr)
	fmt.Printf("pointer:    %v\n", zeroPtr)
	fmt.Printf("slice:      %v\n", zeroSlice)
	fmt.Printf("map:        %#v\n", zeroMap)
	fmt.Printf("interface:  %v\n", zeroInterface)
	fmt.Printf("channel:    %v\n", zeroChan)
	fmt.Printf("array:      %v\n", zeroArray)
	fmt.Printf("struct:     %#v\n", zeroStruct)
	fmt.Printf("function:   %v\n", zeroFunc)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-type-casting-basics
main.go:+521
// no output
package main

func main() {
	// :show start
	// you can cast between numbers i.e. integers of various sizes and floating point numbers
	var i1 int32 = 3
	var i2 int = int(i1) // we must explicitly cast from int32 to int
	var f float64 = float64(i1)

	s := "string"
	// we can cast between string and []byte and vice-versa
	// note that unless optimizted by the compiler, this involves allocation
	var d []byte = []byte(s)
	// :show end

	_, _, _ = i2, f, d // silence compiler error about unused variables
}

---
@url: https://repl.it/@kjk1/book-define-variables
main.go:+1130
package main

import (
	"bytes"
	"fmt"
	"io"
)

// :show start
// declaration of a single top-level variable
var topLevel int64 = 5

// grouping of multiple top-level declarations
var (
	intVal int            // value is initialized with zero-value
	str    string = "str" // assigning

	// functions are first-class values so can be assigned to variables
	// fn is variable of type func(a int) string
	// it's uninitialized so is nil (zero-value for function variables)
	fn func(a int) string
)

func f() {
	// shorthand using local type inference
	// type of `i` is int and is inferred from the value
	// note: this is not allowed at top-level
	i := 4

	// grouping inside a function
	var (
		i2 int
		s  string
	)

	// _ is like a variable whose value is discarded. It's called blank identifier.
	// Useful when we don't care about one of the values returned by a function
	_, err := io.Copy(dst, src) // don't care how many bytes were written
	// ...

	fmt.Printf("i: %d, i2: %d, s: %s, err: %v\n", i, i2, s, err)
}

// :show end

var (
	dst io.Writer = &bytes.Buffer{}
	src io.Reader = &bytes.Buffer{}
)

func main() {
	f()
}

---
@url: https://repl.it/@kjk1/book-constants-2
main.go:+319
// no output
package main

// :show start
// Greeting is an exported (public) string constant
const Greeting string = "Hello World"

// we can group const declarations
const (
	// years is an unexported (package private) int constant
	years int  = 10
	truth bool = true
)

// :show end

func main() {
	// do  nothing
}

---
@url: https://repl.it/@kjk1/book-constants-3
main.go:+536
package main

import (
	"fmt"
	"math"
)

const s string = "constant"

func main() {
	fmt.Println(s) // constant

	// A `const` statement can appear anywhere a `var` statement can.
	const n = 10
	fmt.Println(n)                           // 10
	fmt.Printf("n=%d is of type %T\n", n, n) // n=10 is of type int

	const m float64 = 4.3
	fmt.Println(m) // 4.3

	// An untyped constant takes the type needed by its context.
	// For example, here `math.Sin` expects a `float64`.
	const x = 10
	fmt.Println(math.Sin(x)) // -0.5440211108893699
}

---
@url: https://repl.it/@kjk1/book-basic-variable
main.go:+702
// no output
package main

type Person struct {
	FirstName string
	LastName  string
}

func main() {
	// :show start
	// Basic variable declaration. Declares a variable of type specified on the right.
	// The variable is initialized to the zero value of the respective type.
	var x int
	var s string
	var p Person // Assuming type Person struct {}

	// Assignment of a value to a variable
	x = 3

	// Short declaration using := infers the type
	y := 4

	u := int64(100)    // declare variable of type int64 and init with 100
	var u2 int64 = 100 // declare variable of type int64 and init with 100
	// :show end

	// silence compiler error about unused variables
	_, _, _, _, _, _ = x, s, p, y, u, u2
}

---
@url: https://repl.it/@kjk1/book-multiple-variables
main.go:+476
// no output
package main

func main() {
	// :show start
	// You can declare multiple variables of the same type in one line
	var a, b, c string

	var d, e string = "Hello", "world!"

	// You can also use short declaration to assign multiple variables
	x, y, z := 1, 2, 3

	foo, bar := 4, "stack" // `foo` is type `int`, `bar` is type `string`
	// :show end

	// silence compiler error about unused variables
	_, _, _, _, _, _, _, _, _, _ = a, b, c, d, e, x, y, z, foo, bar
}

---
@url: https://repl.it/@kjk1/book-multiple-variable
main.go:+331
package main

import "fmt"

// :show start
func multipleReturn() (int, int) {
	return 1, 2
}

func multipleReturn2() (a int, b int) {
	a = 3
	b = 4
	return
}

func main() {
	x, y := multipleReturn()  // x = 1, y = 2
	w, z := multipleReturn2() // w = 3, z = 4
	fmt.Printf("x: %d, y: %d\nw: %d, z: %d\n", x, y, w, z)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-blank-identifier
main.go:+256
package main

import "fmt"

// :show start
func SumProduct(a, b int) (int, int) {
	return a + b, a * b
}

func main() {
	// only need the sum
	sum, _ := SumProduct(1, 2) // the product gets discarded
	fmt.Println(sum)           // prints 3
}

// :show end

---
@url: https://repl.it/@kjk1/book-blank-identifier-2
main.go:+263
package main

import "fmt"

// :show start
func main() {
	pets := []string{"dog", "cat", "fish"}

	// range returns both the current index and value
	// but sometimes we only need one or the other
	for _, pet := range pets {
		fmt.Println(pet)
	}
}

// :show end

---
@url: https://repl.it/@kjk1/book-typed-vs-untyped
main.go:+687
// allow error
package main

func main() {
	// :show start
	const untypedNumber = 345

	// if this was a variable declaration, untypedNumber would have its type
	// inferred as int.
	// since it's a const, it remains untyped until it's e.g. assigned to a variable
	var i int = untypedNumber      // no need to cast to int
	var u16 uint16 = untypedNumber // no need to cast to uint16
	var f float64 = untypedNumber  // no need to cast to float64

	// incompatible assignments are detected by the compiler
	// 345 is too big to fit in int8 and compiler detects that
	var b int8 = untypedNumber

	// :show end

	// silence compiler error about unused variables
	_, _, _, _ = i, u16, f, b
}

---
@url: https://repl.it/@kjk1/book-iota
main.go:+182

package main

import "fmt"

func main() {
	// :show start
	const (
		Low = iota
		Medium
		High
	)
	fmt.Printf("Low: %d\nMedium: %d\nHigh: %d\n", Low, Medium, High)

	// :show end
}
---
@url: https://repl.it/@kjk1/book-iota-2
main.go:+414
package main

import "fmt"

func main() {
	// :show start
	const (
		Secure = 1 << iota // 0b001
		Authn              // 0b010
		Ready              // 0b100
	)

	ConnState := Secure | Authn // 0b011: Connection is secure and authenticated, but not yet Ready

	fmt.Printf("Secure: 0x%x (0b%03b)\nAuthn: 0x%x (0b%03b)\nConnState: 0x%x (0b%03b)\n", Secure, Secure, Authn, Authn, ConnState, ConnState)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-iota-3
main.go:+310
package main

import "fmt"

func main() {
	// :show start
	const ( // iota is reset to 0
		a = 1 << iota // a == 1
		b = 1 << iota // b == 2
		c = 3         // c == 3  (iota is not used but still incremented)
		d = 1 << iota // d == 8
	)
	fmt.Printf("a: %d, b: %d, c: %d, d: %d\n", a, b, c, d)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-iota-4
main.go:+196
package main

import "fmt"

func main() {
	// :show start
	const (
		a = iota // a = 0
		_        // iota is incremented
		b        // b = 2
	)
	fmt.Printf("a: %d, b: %d\n", a, b)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-iota-5
main.go:+440
package main

import "fmt"

func main() {
	// :show start
	const (
		bit0, mask0 = 1 << iota, 1<<iota - 1 // bit0 == 1, mask0 == 0
		bit1, mask1                          // bit1 == 2, mask1 == 1
		_, _                                 // skips iota == 2
		bit3, mask3                          // bit3 == 8, mask3 == 7
	)
	fmt.Printf("bit0: %d, mask0: 0x%x\n", bit0, mask0)
	fmt.Printf("bit3: %d, mask3: 0x%x\n", bit3, mask3)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-iota-6
main.go:+263
package main

import "fmt"

func main() {
	// :show start
	type ByteSize int

	const (
		_           = iota // ignore first value by assigning to blank identifier
		KB ByteSize = 1 << (10 * iota)
		MB
		GB
		TB
		PB
	)
	fmt.Printf("KB: %d\n", KB)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-strings-basics
main.go:+677
package main

import "fmt"

func main() {
	// :show start
	var s string // empty string ""
	s1 := "string\nliteral\nwith\tescape characters"
	s2 := `raw string literal
	which doesn't recgonize escape characters like \n
	`

	// you can add strings with +
	fmt.Printf("sum of string: %s\n", s+s1+s2)

	// you can compare strings with ==
	if s1 == s2 {
		fmt.Printf("s1 is equal to s2\n")
	} else {
		fmt.Printf("s1 is not equal to s2\n")
	}

	fmt.Printf("substring of s1: %s\n", s1[3:5])
	fmt.Printf("byte (character) at position 3 in s1: %d\n", s1[3])

	// C-style string formatting
	s = fmt.Sprintf("%d + %f = %s", 1, float64(3), "4")
	fmt.Printf("s: %s\n", s)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-pointers-basics-2
main.go:+338
package main

import "fmt"

func main() {
	// :show start
	v := 5

	// pv is a pointer to v
	pv := &v
	fmt.Printf("v: %d, pv: %p\n", v, pv)

	// we change the value of v via pv
	*pv = 4
	fmt.Printf("v: %d\n", v)

	// two pointers to the same value have the same address
	pv2 := &v
	fmt.Printf("pv: %p, pv2: %p\n", pv, pv2)
	// :show end
}
---
@url: https://repl.it/@kjk1/book-array-basic
main.go:+428
package main

import "fmt"

func main() {
	// :show start
	a := [3]int{4, 5} // array of 2 ints

	// access element of array
	fmt.Printf("a[2]: %d\n", a[2])

	// set element of array
	a[1] = 3

	// get size of array
	fmt.Printf("size of array a: %d\n", len(a))

	// when using [...] size will be deduced from { ... }
	a2 := [...]int{4, 8, -1} // array of 3 integers
	fmt.Printf("size of array a2: %d\n", len(a2))
	// :show end
}
---
@url: https://repl.it/@kjk1/book-slice-basics
main.go:+334
package main

import "fmt"

func main() {
	// :show start
	slice := make([]int, 0, 5)
	// append element to end of slice
	slice = append(slice, 5)
	// append multiple elements to end
	slice = append(slice, 3, 4)
	fmt.Printf("length of slice is: %d\n", len(slice))
	fmt.Printf("capacity of slice is: %d\n", cap(slice))
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-map-basics
main.go:+999
package main

import "fmt"

func main() {
	// :show start
	// create an empty map
	m := make(map[string]int)

	// set the value
	m["three"] = 3
	m["four"] = 4

	// get the value and see if the value exists
	key := "four"
	if value, ok := m[key]; ok {
		fmt.Printf("Key '%s' exists and maps to %d\n", key, value)
	} else {
		fmt.Printf("Key '%s' doesn't exists\n", key)
	}

	key = "five"
	if value, ok := m[key]; ok {
		fmt.Printf("Key '%s' exists and maps to %d\n", key, value)
	} else {
		fmt.Printf("Key '%s' doesn't exists\n", key)
	}

	// if value doesn't exist, the result of lookup is zero value. In this case zero value of int is 0
	fmt.Printf("\nValue for non-existing key: %d\n\n", m["not-exists"])

	// iterating over keys and values
	fmt.Printf("All keys and their values:\n")
	for key, value := range m {
		fmt.Printf("%s => %d\n", key, value)
	}

	fmt.Printf("\nBefore deletion: len(m)=%d\n", len(m))
	delete(m, "four")
	fmt.Printf("After deletion: len(m)=%d\n", len(m))
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-struct-basics
main.go:+534
package main

import (
	"fmt"
)

// :show start
// Person describes a person
type Person struct {
	FirstName string
	LastName  string
}

// FullName returns full name of a person
func (p *Person) FullName() string {
	return fmt.Sprintf("%s %s", p.FirstName, p.LastName)
}

func main() {
	// zero value of struct
	var p Person
	fmt.Printf("p: %v\n\n", p)

	p = Person{
		FirstName: "John",
		LastName:  "Doe",
	}
	fmt.Printf("p: %v\n\n", p)

	// call a method on a struct
	fmt.Printf("p.FullName(): %s\n", p.FullName())
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-interface-basics
main.go:+776
package main

import (
	"fmt"
	"strconv"
)

// :show start
// Stringer is an interface with a single method
type Stringer interface {
	String() string
}

// User struct that implements Stringer interface
type User struct {
	Name string
}

func (u *User) String() string {
	return u.Name
}

// Any type can implement an interface. Here we create
// an alias of int type an implement Stringer interface

type MyInt int

func (mi MyInt) String() string {
	return strconv.Itoa(int(mi))
}

// printTypeAndString accepts an interface. 's' can be any value
// that implements Stringer interface
func printTypeAndString(s Stringer) {
	fmt.Printf("%T: %s\n", s, s)
}

func main() {
	u := &User{Name: "John"}
	printTypeAndString(u)

	n := MyInt(5)
	printTypeAndString(n)
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-empty-interface-basics
main.go:+428
package main

import (
	"fmt"
)

// :show start
func printVariableType(v interface{}) {
	switch v.(type) {
	case string:
		fmt.Printf("v is of type 'string'\n")
	case int:
		fmt.Printf("v is of type 'int'\n")
	default:
		// generic fallback
		fmt.Printf("v is of type '%T'\n", v)
	}
}

func main() {
	printVariableType("string") // string
	printVariableType(5)        // int
	printVariableType(int32(5)) // int32
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-if-basics
main.go:+186

package main

import "fmt"

func main() {
	// :show start
	a := 5
	b := 6
	if a == b {
		fmt.Print("a is equal to b\n")
	} else {
		fmt.Print("a is not equal to b\n")
	}
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-switch-basics
main.go:+280

package main

import "fmt"

func main() {
	// :show start
	stmt := "if"
	switch stmt {
	case "if", "for":
		fmt.Printf("stmt ('%s') is either 'if' or 'for'\n", stmt)
	case "else":
		fmt.Printf("stmt is 'else'\n")
	default:
		fmt.Printf("stmt is '%s'\n", stmt)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-finding-strings
main.go:+377
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "where hello is?"
	toFind := "hello"
	idx := strings.Index(s, toFind)
	fmt.Printf("'%s' is in s starting at position %d\n", toFind, idx)

	// when string is not found, result is -1
	idx = strings.Index(s, "not present")
	fmt.Printf("Index of non-existent substring is: %d\n", idx)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-finding-strings-2
main.go:+260
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "hello and second hello"
	toFind := "hello"
	idx := strings.LastIndex(s, toFind)
	fmt.Printf("when searching from end, '%s' is in s at position %d\n", toFind, idx)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-finding-strings-3
main.go:+360
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "first is, second is, third is"
	toFind := "is"
	currStart := 0
	for {
		idx := strings.Index(s, toFind)
		if idx == -1 {
			break
		}
		fmt.Printf("found '%s' at position %d\n", toFind, currStart+idx)
		currStart += idx + len(toFind)
		s = s[idx+len(toFind):]
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-finding-strings-4
main.go:+283
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "is hello there?"
	toFind := "hello"
	if strings.Contains(s, toFind) {
		fmt.Printf("'%s' contains '%s'\n", s, toFind)
	} else {
		fmt.Printf("'%s' doesn't contain '%s'\n", s, toFind)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-finding-strings-5
main.go:+288
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "this is string"
	toFind := "this"
	if strings.HasPrefix(s, toFind) {
		fmt.Printf("'%s' starts with '%s'\n", s, toFind)
	} else {
		fmt.Printf("'%s' doesn't start with '%s'\n", s, toFind)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-finding-strings-6
main.go:+285
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "this is string"
	toFind := "string"
	if strings.HasSuffix(s, toFind) {
		fmt.Printf("'%s' ends with '%s'\n", s, toFind)
	} else {
		fmt.Printf("'%s' doesn't end with '%s'\n", s, toFind)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/book-comparing-strings
main.go:+547
package main

import (
	"fmt"
)

func main() {
	// :show start
	s1 := "string one"
	s2 := "string two"

	if s1 == s2 {
		fmt.Printf("s1 is equal to s2\n")
	} else {
		fmt.Printf("s1 is not equal to s2\n")
	}

	if s1 == s1 {
		fmt.Printf("s1 is equal to s1\n")
	} else {
		fmt.Printf("inconcivable! s1 is not equal to itself\n")
	}

	if s1 > s2 {
		fmt.Printf("s1 is > than s2\n")
	} else {
		fmt.Printf("s1 is not > than s2\n")
	}

	if s1 < s2 {
		fmt.Printf("s1 is < than s2\n")
	} else {
		fmt.Printf("s1 is not < than s2\n")
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-comparing-strings-2
main.go:+295
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s1 := "gone"
	s2 := "GoNe"
	if strings.EqualFold(s1, s2) {
		fmt.Printf("'%s' is equal '%s' when ignoring case\n", s1, s2)
	} else {
		fmt.Printf("'%s' is not equal '%s' when ignoring case\n", s1, s2)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-strings-convert-case
main.go:+271
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "Mixed Case"
	fmt.Printf("ToLower(s): '%s'\n", strings.ToLower(s))
	fmt.Printf("ToUpper(s): '%s'\n", strings.ToUpper(s))
	fmt.Printf("ToTitle(s): '%s'\n", strings.ToTitle(s))
	// :show end
}

---
@url: https://repl.it/@kjk1/book-convert-to-number
main.go:+917
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// :show start
	s := "234"
	i, err := strconv.Atoi(s)
	if err != nil {
		fmt.Printf("strconv.Atoi() failed with: '%s'\n", err)
	}
	fmt.Printf("strconv.Atoi('%s'): %d\n", s, i)

	i, err = strconv.Atoi("not a number")
	if err != nil {
		fmt.Printf("strconv.Atoi('not a number') failed with: '%s'\n", err)
	}

	i64, err := strconv.ParseInt(s, 10, 64)
	if err != nil {
		fmt.Printf("strconv.ParseInt() failed with: '%s'\n", err)
	}
	fmt.Printf("strconv.ParseInt('%s', 64): %d\n", s, i64)

	s = "-3.234"
	f64, err := strconv.ParseFloat(s, 64)
	if err != nil {
		fmt.Printf("strconv.ParseFloat() failed with: '%s'\n", err)
	}
	fmt.Printf("strconv.ParseFloat('%s', 64): %g\n", s, f64)

	var f2 float64
	_, err = fmt.Sscanf(s, "%f", &f2)
	if err != nil {
		fmt.Printf("fmt.Sscanf() failed with: '%s'\n", err)
	}
	fmt.Printf("fmt.Sscanf(): %g\n", f2)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-strings-tirm
main.go:+672
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "  str  "
	fmt.Printf("TrimSpace('%s'): '%s'\n\n", s, strings.TrimSpace(s))

	s = "abacdda"
	cutset := "ab"
	fmt.Printf("Trim('%s', '%s'): '%s'\n\n", s, cutset, strings.Trim(s, cutset))

	fmt.Printf("TrimLeft('%s', '%s'): '%s'\n\n", s, cutset, strings.TrimLeft(s, cutset))

	fmt.Printf("TrimRight('%s', '%s'): '%s'\n\n", s, cutset, strings.TrimRight(s, cutset))

	suffix := "ab"
	fmt.Printf("TrimSuffix('%s', '%s'): '%s'\n\n", s, suffix, strings.TrimSuffix(s, suffix))

	prefix := "ab"
	fmt.Printf("TrimPrefix('%s', '%s'): '%s'\n\n", s, prefix, strings.TrimPrefix(s, prefix))
	// :show end
}

---
@url: https://repl.it/@kjk1/book-string-split-join
main.go:+229

package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "this is a string"
	a := strings.Split(s, " ")
	fmt.Printf("a: %#v\n", a)

	s2 := strings.Join(a, ",")
	fmt.Printf("s2: %#v\n", s2)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-formatting-text
main.go:+213
package main

import (
	"fmt"
)

func main() {
	// :show start
	s := fmt.Sprintf("Hello %s", "World")
	fmt.Printf("s: '%s'\n", s)
	s = fmt.Sprintf("%d + %f = %d", 2, float64(3), 5)
	fmt.Println(s)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-parse-sscanf
main.go:+498
package main

import (
	"fmt"
	"log"
)

func main() {
	// :show start
	// extract int and float from a string
	s := "48 123.45"
	var f float64
	var i int
	nParsed, err := fmt.Sscanf(s, "%d %f", &i, &f)
	if err != nil {
		log.Fatalf("first fmt.Sscanf failed with %s\n", err)
	}
	fmt.Printf("i: %d, f: %f, extracted %d values\n", i, f, nParsed)

	var i2 int
	_, err = fmt.Sscanf(s, "%d %f %d", &i, &f, &i2)
	if err != nil {
		fmt.Printf("second fmt.Sscanf failed with %s\n", err)
	}

	// :show end
}

---
@url: https://repl.it/@kjk1/book-strings-parse-split
main.go:+177
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "this,. is,. a,. string"
	a := strings.Split(s, ",.")
	fmt.Printf("a: %#v\n", a)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-string-replace
main.go:+207
package main

import (
	"fmt"
	"strings"
)

func main() {
	// :show start
	s := "original string original"
	s2 := strings.Replace(s, "original", "replaced", -1)
	fmt.Printf("s2: '%s'\n", s2)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-strings-replace-regex
main.go:+234
package main

import (
	"fmt"
	"regexp"
)

func main() {
	// :show start
	s := "original string original"
	rx := regexp.MustCompile("(?U)or.*al")
	s2 := rx.ReplaceAllString(s, "replaced")
	fmt.Printf("s2: '%s'\n", s2)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-read-file-as-lines
main.go:+558
package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"strings"
)

// :show start
// ReadFileAsLines reads a file and splits it into lines
func ReadFileAsLines(path string) ([]string, error) {
	d, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}
	s := string(d)
	lines := strings.Split(s, "\n")
	return lines, nil
}

// :show end

func main() {
	path := "main.go"
	lines, err := ReadFileAsLines(path)
	if err != nil {
		log.Fatalf("ReadFileAsLines() failed with '%s'\n", err)
	}
	fmt.Printf("There are %d lines in '%s'\n", len(lines), path)
}

---
@url: https://repl.it/@kjk1/book-iter-lines-in-file
main.go:+792
package main

import (
  "fmt"
  "os"
  "bufio"
)

// :show start
func IterLinesInFile(filePath string, process func (s string) bool) error {
    file, err := os.Open(filePath)
    if err != nil {
        return err
    }
    defer file.Close()
    scanner := bufio.NewScanner(file)
    // Scan() reads next line and returns false when reached end or error
    for scanner.Scan() {
        line := scanner.Text()
        if !process(line) {
          return nil
        }
        // process the line
    }
    // check if Scan() finished because of error or because it reached end of file
    return scanner.Err()
}
// :show end

func main() {
  nLines := 0
  IterLinesInFile("main.go", func(s string) bool {
    nLines++
    return true
  })
  fmt.Printf("%d lines in 'main.go'\n", nLines)
}
---
@url: https://repl.it/@kjk1/book-normalize-newlines
main.go:+503
package main

import (
	"bytes"
	"fmt"
)

// :show start
// NormalizeNewLines normalizes \r\n (windows) and \r (mac)
// into \n (unix)
func NormalizeNewlines(d []byte) []byte {
	// replace CR LF \r\n (windows) with LF \n (unix)
	d = bytes.Replace(d, []byte{13, 10}, []byte{10}, -1)
	// replace CF \r (mac) with LF \n (unix)
	d = bytes.Replace(d, []byte{13}, []byte{10}, -1)
	return d
}

// :show end

func main() {
	d := []byte("new\r\nline")
	d = NormalizeNewlines(d)
	fmt.Printf("%#v\n", string(d))
}

---
@url: https://repl.it/@kjk1/book-pointers-basic
main.go:+746
// no output
package main

// :show start

// We'll show how pointers work in contrast to values with
// 2 functions: `zeroval` and `zeroptr`. `zeroval` has an
// `int` parameter, so arguments will be passed to it by
// value. `zeroval` will get a copy of `ival` distinct
// from the one in the calling function.
func zeroval(ival int) {
	ival = 0
}

// `zeroptr` in contrast has an `*int` parameter, meaning
// that it takes an `int` pointer. The `*iptr` code in the
// function body then _dereferences_ the pointer from its
// memory address to the current value at that address.
// Assigning a value to a dereferenced pointer changes the
// value at the referenced address.
func zeroptr(iptr *int) {
	*iptr = 0
}

// :show end

func main() {
}
---
@url: https://repl.it/@kjk1/book-pointers-basic-2
main.go:+1163
package main

import "fmt"

// We'll show how pointers work in contrast to values with
// 2 functions: `zeroval` and `zeroptr`. `zeroval` has an
// `int` parameter, so arguments will be passed to it by
// value. `zeroval` will get a copy of `ival` distinct
// from the one in the calling function.
func zeroval(ival int) {
	ival = 0
}

// `zeroptr` in contrast has an `*int` parameter, meaning
// that it takes an `int` pointer. The `*iptr` code in the
// function body then _dereferences_ the pointer from its
// memory address to the current value at that address.
// Assigning a value to a dereferenced pointer changes the
// value at the referenced address.
func zeroptr(iptr *int) {
	*iptr = 0
}

func main() {
	// :show start
	i := 1
	fmt.Println("initial:", i)

	zeroval(i)
	fmt.Println("zeroval:", i)
	// `i` is still equal to 1 because `zeroval` edited
	// a "copy" of `i`, not the original.

	// The `&i` syntax gives the memory address of `i`,
	// i.e. a pointer to `i`. When calling `zeroptr`,
	// it will edit the "original" `i`.
	zeroptr(&i)
	fmt.Println("zeroptr:", i)

	// Pointers can be printed too.
	fmt.Println("pointer:", &i)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-pointer-dereference
main.go:+481
package main

import "fmt"

// :show start
type Person struct {
	Name string
}

func main() {
	c := new(Person) // returns pointer
	c.Name = "Catherine"
	fmt.Println(c.Name) // prints: Catherine
	d := c
	d.Name = "Daniel"
	fmt.Println(c.Name) // prints: Daniel
	// Adding an Asterix before a pointer dereferences the pointer
	i := *d
	i.Name = "Ines"
	fmt.Println(c.Name) // prints: Daniel
	fmt.Println(d.Name) // prints: Daniel
	fmt.Println(i.Name) // prints: Ines
	// :show end
}
---
@url: https://repl.it/@kjk1/book-pointer-methods
main.go:+518

package main

import "fmt"

// :show start
type Foo struct {
	Bar int
}

func (f *Foo) Increment() {
	f.Bar++
}

func main() {
	var f Foo

	// Calling `f.Increment` is automatically changed to `(&f).Increment` by the compiler.
	f = Foo{}
	fmt.Printf("f.Bar is %d\n", f.Bar)
	f.Increment()
	fmt.Printf("f.Bar is %d\n", f.Bar)

	// As you can see, calling `(&f).Increment` directly does the same thing.
	f = Foo{}
	fmt.Printf("f.Bar is %d\n", f.Bar)
	(&f).Increment()
	fmt.Printf("f.Bar is %d\n", f.Bar)
}

// :show end
---
@url: https://repl.it/@kjk1/book-value-methods
main.go:+655
package main

import "fmt"

// :show start
type Foo struct {
	Bar int
}

func (f Foo) Increment() {
	f.Bar++
}

func main() {
	var p *Foo

	// Calling `p.Increment` is automatically changed to `(*p).Increment` by the compiler.
	// (Note that `*p` is going to remain at 0 because a copy of `*p`, and not the original `*p` are being edited)
	p = &Foo{}
	fmt.Printf("(*p).Bar is %d\n", (*p).Bar)
	p.Increment()
	fmt.Printf("(*p).Bar is %d\n", (*p).Bar)

	// As you can see, calling `(*p).Increment` directly does the same thing.
	p = &Foo{}
	fmt.Printf("(*p).Bar is %d\n", (*p).Bar)
	(*p).Increment()
	fmt.Printf("(*p).Bar is %d\n", (*p).Bar)
}

// :show end
---
@url: https://repl.it/@kjk1/book-array-create
main.go:+1534
package main

import "fmt"

func main() {
	// :show start
	// Creating arrays of 6 elements of type int,
	// and put elements 1, 2, 3, 4, 5 and 6 inside it, in this exact order:
	var array1 = [6]int{1, 2, 3, 4, 5, 6}   // classical way
	var array2 = [6]int{1, 2, 3, 4, 5, 6}   // a less verbose way
	var array3 = [...]int{1, 2, 3, 4, 5, 6} // the compiler will count the array elements by itself

	fmt.Println("array1:", array1) // > [1 2 3 4 5 6]
	fmt.Println("array2:", array2) // > [1 2 3 4 5 6]
	fmt.Println("array3:", array3) // > [1 2 3 4 5 6]

	// Creating arrays with default values inside:
	zeros := [8]int{}       // Create a list of 8 int filled with 0
	ptrs := [8]*int{}       // a list of int pointers, filled with 8 nil references ( <nil> )
	emptystr := [8]string{} // a list of string filled with 8 times ""

	fmt.Println("zeroes:", zeros)      // > [0 0 0 0 0 0 0 0]
	fmt.Println("ptrs:", ptrs)         // > [<nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil>]
	fmt.Println("emptystr:", emptystr) // > [       ]
	// values are empty strings, separated by spaces,
	// so we can just see separating spaces

	// Arrays are also working with a personalized type
	type Data struct {
		Number int
		Text   string
	}

	// Creating an array with 8 'Data' elements
	// All the 8 elements will be like {0, ""} (Number = 0, Text = "")
	structs := [8]Data{}

	fmt.Println("structs:", structs) // > [{0 } {0 } {0 } {0 } {0 } {0 } {0 } {0 }]
	// prints {0 } because Number are 0 and Text are empty; separated by a space
	// :show end
}
---
@url: https://repl.it/@kjk1/book-array-indexes
main.go:+492

package main

import "fmt"

func main() {
	// :show start
	var array = [6]int{1, 2, 3, 4, 5, 6}

	// doesn't work: invalid array index -1 (index must be non-negative)
	// fmt.Println(array[-42])
	fmt.Println(array[0]) // > 1
	fmt.Println(array[1]) // > 2
	fmt.Println(array[2]) // > 3
	fmt.Println(array[3]) // > 4
	fmt.Println(array[4]) // > 5
	fmt.Println(array[5]) // > 6
	// doesn't work: invalid array index 6 (out of bounds for 6-element array)
	//fmt.Println(array[6])
	// :show end
}
---
@url: https://repl.it/@kjk1/book-array-indexes-2
main.go:+475
package main

import "fmt"

func main() {
	// :show start
	var array = [6]int{1, 2, 3, 4, 5, 6}

	fmt.Println(array) // > [1 2 3 4 5 6]

	array[0] = 6
	fmt.Println(array) // > [6 2 3 4 5 6]

	array[1] = 5
	fmt.Println(array) // > [6 5 3 4 5 6]

	array[2] = 4
	fmt.Println(array) // > [6 5 4 4 5 6]

	array[3] = 3
	fmt.Println(array) // > [6 5 4 3 5 6]

	array[4] = 2
	fmt.Println(array) // > [6 5 4 3 2 6]

	array[5] = 1
	fmt.Println(array) // > [6 5 4 3 2 1]
	// :show end
}
---
@url: https://repl.it/@kjk1/book-array-multidimension
main.go:+688
package main

import "fmt"

func main() {
	// :show start
	// Defining a 2d Array to represent a matrix like
	// 1 2 3     So with 2 lines and 3 columns;
	// 4 5 6
	multiDimArray := [2] /*lines*/ [3] /*columns*/ int{[3]int{1, 2, 3}, [3]int{4, 5, 6}}

	// That can be simplified like this:
	var simplified = [2][3]int{{1, 2, 3}, {4, 5, 6}}

	// What does it looks like ?
	fmt.Println(multiDimArray)
	// > [[1 2 3] [4 5 6]]

	fmt.Println(multiDimArray[0])
	// > [1 2 3]    (first line of the array)

	fmt.Println(multiDimArray[0][1])
	// > 2          (cell of line 0 (the first one), column 1 (the 2nd one))

	// :show end

	// silence compiler error about unused variable
	_ = simplified
}
---
@url: https://repl.it/@kjk1/book-array-multidimension-2
main.go:+778

package main

import "fmt"

func main() {
	// :show start
	// We can also define array with as much dimensions as we need
	// here, initialized with all zeros
	var multiDimArray = [2][4][3][2]string{}

	// the data is:
	// > [[[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]]
	//   [[[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]]
	// :show end

	fmt.Printf("%#v\n", multiDimArray)
}
---
@url: https://repl.it/@kjk1/book-array-multidimension-3
main.go:+937
package main

import "fmt"

func main() {
	// :show start

	var multiDimArray = [2][4][3][2]string{}

	// We can set some values in the array's cells
	multiDimArray[0][0][0][0] = "All zero indexes"   // Setting the first value
	multiDimArray[1][3][2][1] = "All indexes to max" // Setting the value at extreme location

	// The data looks like:
	// > [[[["All zero indexes" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]]
	//   [[[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" ""]]]
	//    [[["" ""] ["" ""]] [["" ""] ["" ""]] [["" ""] ["" "All indexes to max"]]]]

	// :show end

	fmt.Printf("%#v\n", multiDimArray)
}
---
@url: https://repl.it/@kjk1/book-slice-add
main.go:+176
package main

import "fmt"

func main() {
	// :show start
	a := []string{"!"}
	a2 := []string{"Hello", "world"}
	a = append(a, a2...)
	fmt.Printf("a: %#v\n", a)
	// :show end
}
---
@url: https://repl.it/@kjk1/book-slice-filter-simple
main.go:+333
package main

import "fmt"

// :show start
func filterEvenValues(a []int) []int {
	var res []int
	for _, el := range a {
		if el%2 == 0 {
			continue
		}
		res = append(res, el)
	}
	return res
}

// :show end

func main() {
	// :show start
	a := []int{1, 2, 3, 4}
	res := filterEvenValues(a)
	fmt.Printf("%#v\n", res)
	// :show end
}
---
@url: https://repl.it/@kjk1/book-slice-filter
main.go:+399
package main

import "fmt"

func filterEvenValuesInPlace(a []int) []int {
	// create a zero-length slice with the same underlying array
	res := a[:0]

	for _, v := range a {
		if v%2 == 0 {
			// collect only wanted values
			res = append(res, v)
		}
	}
	return res
}

func main() {
	// :show start
	a := []int{1, 2, 3, 4}
	res := filterEvenValuesInPlace(a)
	fmt.Printf("%#v\n", res)
	// :show end
}
---
@url: https://repl.it/@kjk1/book-slice-duplicate
main.go:+205
package main

import "fmt"

func main() {
	// :show start
	src := []int{1, 2, 3}
	dst := make([]int, len(src))
	copy(dst, src)
	fmt.Printf("src: %#v\n", src)
	fmt.Printf("dst: %#v\n", dst)
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-map-zero-value
main.go:+176
package main

import "fmt"

func main() {
	// :show start
	var m map[string]string
	fmt.Printf("m == nil ? %v\n", m == nil)
	fmt.Printf("len(m) = %d\n", len(m))
	// :show end
}
---
@url: https://repl.it/@kjk1/gobok-map-zero-value-2
main.go:+310
// allow error
package main

import "fmt"

func main() {
	// :show start
	var m map[string]string

	// you can read read from un-initialized map
	fmt.Printf(`m["foo"] = %s`+"\n", m["foo"])
	_, ok := m["foo"]
	fmt.Printf("ok: %v\n", ok)

	// writing to uninitialized map panics
	m["foo"] = "bar"
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-map-copy
main.go:+218
// no output
package main

func main() {
	// :show start
	src := make(map[string]int)
	src["one"] = 1
	src["two"] = 2

	dst := make(map[string]int)

	for key, value := range src {
		dst[key] = value
	}

	// :show end
}
---
@url: https://repl.it/@kjk1/book-map-iterate-key-value
main.go:+233
package main

import "fmt"

func main() {
	// :show start
	people := map[string]int{
		"john": 30,
		"jane": 29,
		"mark": 11,
	}

	for key, value := range people {
		fmt.Printf("key: %s, value: %d\n", key, value)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/go-book-iterate-keys
main.go:+208
package main

import "fmt"

func main() {
	// :show start
	people := map[string]int{
		"john": 30,
		"jane": 29,
		"mark": 11,
	}

	for key := range people {
		fmt.Printf("key: %s\n", key)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/go-book-iterate-values
main.go:+217
package main

import "fmt"

func main() {
	// :show start
	people := map[string]int{
		"john": 30,
		"jane": 29,
		"mark": 11,
	}

	for _, value := range people {
		fmt.Printf("value: %d\n", value)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-map-as-set
main.go:+367
package main

import "fmt"

func main() {
	// :show start
	greetings := map[string]struct{}{
		"hi":    {},
		"hello": {},
	}

	// delete a value from set
	delete(greetings, "hi")

	// add a value to set
	greetings["hey"] = struct{}{}

	// check if a value is in the set:
	if _, ok := greetings["hey"]; ok {
		fmt.Printf("'hey' is in greetings\n")
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-map-concurrent
main.go:+947
// no output
package main

import "sync"

type RWMap struct {
	sync.RWMutex
	m map[string]int
}

// Get is a wrapper for getting the value from the underlying map
func (r *RWMap) Get(key string) int {
	r.RLock()
	defer r.RUnlock()
	return r.m[key]
}

// Set is a wrapper for setting the value of a key in the underlying map
func (r *RWMap) Set(key string, val int) {
	r.Lock()
	defer r.Unlock()
	r.m[key] = val
}

// Inc increases the value in the RWMap for a key.
//   This is more pleasant than r.Set(key, r.Get(key)++)
func (r *RWMap) Inc(key string) {
	r.Lock()
	defer r.Unlock()
	r.m[key]++
}

func main() {

	counter := RWMap{m: make(map[string]int)}

	// Get a Read Lock
	counter.RLock()
	_ = counter.Get("Key")
	counter.RUnlock()

	// the above could be replaced with
	_ = counter.Get("Key")

	// Get a write Lock
	counter.Lock()
	counter.m["some_key"]++
	counter.Unlock()

	// above would need to be written as
	counter.Inc("some_key")
}

---
@url: https://repl.it/@kjk1/gobook-struct-declare
main.go:+726
package main

import (
	"fmt"
)

// :show start
// User describes a user
type User struct {
	FirstName, LastName string
	Email               string
	Age                 int
	userID              int
}

// FullName returns full name of a user
func (u *User) FullName() string {
	return fmt.Sprintf("%s %s", u.FirstName, u.LastName)
}

func main() {
	// zero value of struct
	var u User
	fmt.Printf("u: %#v\n\n", u)

	// pu is *User i.e. a pointer to User struct
	pu := new(User)
	pu.Age = 33
	fmt.Printf("*pu: %#v\n", *pu)

	// &User{} is the same as new(User)
	pu = &User{}
	pu.Age = 18
	fmt.Printf("*pu: %#v\n", *pu)

	pu.FirstName, pu.LastName = "Jane", "Doe"
	fmt.Printf("pu.FullName(): %s\n", pu.FullName())
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-struct-anonymous
main.go:+186
package main

import "fmt"

func main() {
	// :show start
	data := struct {
		Number int
		Text   string
	}{
		42,
		"Hello world!",
	}

	fmt.Printf("data: %+v\n", data)
	// :show end
}

---
@url: https://repl.it/@kjk1/gobook-struct-methods
main.go:+296
package main

import "fmt"

// :show start

type User struct {
	name string
}

func (u User) Name() string {
	return u.name
}

func (u *User) SetName(newName string) {
	u.name = newName
}

func main() {
	var me User

	me.SetName("Slim Shady")
	fmt.Println("My name is", me.Name())
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-interface-verify-implements
main.go:+227
// allow error
package main

import "io"

// :show start
type MyReadCloser struct {
}

func (rc *MyReadCloser) Read(d []byte) (int, error) {
	return 0, nil
}

var _ io.ReadCloser = &MyReadCloser{}

// :show end

func main() {
}
---
@url: https://repl.it/@kjk1/gobook-interface-type-assertion
main.go:+745
// allow error
package main

import (
	"fmt"
)

// :show start
func printTypeAndValue(iv interface{}) {
	if v, ok := iv.(string); ok {
		fmt.Printf("iv is of type string and has value '%s'\n", v)
		return
	}
	if v, ok := iv.(int); ok {
		fmt.Printf("iv is of type int and has value '%d'\n", v)
		return
	}
	if v, ok := iv.(*int); ok {
		fmt.Printf("iv is of type *int and has value '%s'\n", v)
		return
	}
}

func panicOnInvalidConversion() {
	var iv interface{} = "string"

	v := iv.(int)
	fmt.Printf("v is int of value: %d\n", v)
}

func main() {
	// pass a string
	printTypeAndValue("string")
	i := 5
	// pass an int
	printTypeAndValue(i)
	// pass a pointer to int i.e. *int
	printTypeAndValue(&i)

	panicOnInvalidConversion()
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-interface-type-assertion-2
main.go:+236
// allow error
package main

import (
	"fmt"
)

// :show start
func panicOnInvalidConversion(iv interface{}) {
	v := iv.(int)
	fmt.Printf("v is int of value: %d\n", v)
}

func main() {
	panicOnInvalidConversion("string")
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-interface-type-switch
main.go:+748
package main

import (
	"fmt"
	"strconv"
)

// :show start
func smartConvertToInt(iv interface{}) (int, error) {
	// inside case statements, v is of type matching case type
	switch v := iv.(type) {
	case int:
		return v, nil
	case string:
		return strconv.Atoi(v)
	case float64:
		return int(v), nil
	default:
		return 0, fmt.Errorf("unsupported type: %T", iv)
	}
}

func printSmartConvertToInt(iv interface{}) {
	i, err := smartConvertToInt(iv)
	if err != nil {
		fmt.Printf("Failed to convert %#v to int\n", iv)
		return
	}
	fmt.Printf("%#v of type %T converted to %d\n", iv, iv, i)
}

func main() {
	printSmartConvertToInt("5")
	printSmartConvertToInt(4)
	printSmartConvertToInt(int32(8))
	printSmartConvertToInt("not valid int")
}

// :show end
---
@url: https://repl.it/@kjk1/gobook-if
main.go:+461
package main

import "fmt"

// :show start
func retVals(ok bool) (int, bool) {
	return 5, ok
}

func main() {
	a := 5
	b := 5
	if a == b {
		fmt.Print("a is equal to b\n")
	} else {
		fmt.Print("a is not equal to b\n")
	}

	if n, ok := retVals(true); ok {
		fmt.Print("ok is true, n: %d\n", n)
	} else {
		fmt.Print("ok is false, n: %d\n", n)
	}

	// n is only visible within if loop, so this would fail compilation
	// fmt.Printf("n: %d\n", n)
}

// :show end

---
@url: https://repl.it/@kjk1/gobook-case
main.go:+221

package main

import "fmt"

func main() {
	// :show start
	a := 1
	switch a {
	case 1, 3:
		fmt.Printf("a is 1 or 3\n")
	case 2:
		fmt.Printf("a is 2\n")
	default:
		fmt.Printf("default: a is %d\n", a)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-fallthrough
main.go:+178
package main

import "fmt"

func main() {
	// :show start
	a := 1
	switch a {
	case 1:
		fmt.Printf("case 1\n")
		fallthrough
	case 2:
		fmt.Printf("caes 2\n")
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-switch-strings
main.go:+184
package main

import "fmt"

func main() {
	// :show start
	s := "foo"
	switch s {
	case "foo":
		fmt.Printf("s is 'foo'\n")
	case "bar":
		fmt.Printf("s is 'bar'\n")
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-switch-empty
main.go:+350
package main

import (
	"fmt"
)

// :show start
func check(n int) {
	switch {
	case n > 0 && n%3 == 0:
		fmt.Printf("n is %d, divisible by 3\n", n)
	case n >= 4:
		fmt.Printf("n is %d (>= 4)\n", n)
	default:
		fmt.Printf("default: n is %d\n", n)
	}
}

// :show end
func main() {
	// :show start
	check(3)
	check(4)
	check(6)
	check(1)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-switch-assign
main.go:+392
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	// without seeding rand.Intn will always return the same sequence
	rand.Seed(time.Now().UnixNano())
	// :show start
	switch n := rand.Intn(9); n {
	case 1, 2, 3:
		fmt.Printf("case 1, 2, 3: n is %d\n", n)
	case 4, 5:
		fmt.Printf("case 4, 5: n is %d\n", n)
	default:
		fmt.Printf("default: n is %d\n", n)
	}
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-goto
main.go:+269
package main

import "fmt"

// :show start
func printIsOdd(n int) {
	if n%2 == 1 {
		goto isOdd
	}
	fmt.Printf("%d is even\n", n)
	return

isOdd:
	fmt.Printf("%d is odd\n", n)
}

// :show end

func main() {
	// :show start
	printIsOdd(5)
	printIsOdd(18)
	// :show end
}
---
@url: https://repl.it/@kjk1/gobook-goto-2
main.go:+137
// allow error
package main

import "fmt"

func main() {
	// :show start
	goto end
	a := 3
	fmt.Printf("a: %d\n", a)
end:
	// :show end
}
---
