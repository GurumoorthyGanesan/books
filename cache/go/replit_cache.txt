@url: https://repl.it/@kjk1/getting-started-hello-world
main.go:+74
package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}

---
@url: https://repl.it/@kjk1/getting-started-hello-world
main.go:+80
package main

import "fmt"

func main() {
	fmt.Println("Hello there, 世界")
}

---
@url: https://repl.it/@kjk1/getting-started-hello-world
main.go:+74
package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}

---
@url: https://repl.it/@kjk1/book-booleans
main.go:+229
package main

import "fmt"

func main() {
	// :show start
	var b bool = true
	fmt.Printf("b is: '%v'\n", b)
	b = false
	fmt.Printf("b is: '%v'\n", b)
	var b2 bool
	fmt.Printf("zero value of bool is: '%v'\n", b2)
	// :show end
}


---
@url: https://repl.it/@kjk1/book-booleans2
main.go:+155
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	// :show start
	b := true
	fmt.Printf("size of bool is: %d\n", unsafe.Sizeof(b))
	// :show end
}

---
@url: https://repl.it/@kjk1/book-int-to-str-itoa
main.go:+218
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// :show start
	var i1 int = -38
	fmt.Printf("i1: %s\n", strconv.Itoa(i1))

	var i2 int32 = 148
	fmt.Printf("i2: %s\n", strconv.Itoa(int(i2)))
	// :show end
}

---
@url: https://repl.it/@kjk1/book-int-to-str-sprintf
main.go:+231
package main

import (
	"fmt"
)

func main() {
	// :show start
	var i1 int = -38
	s1 := fmt.Sprintf("%d", i1)
	fmt.Printf("i1: %s\n", s1)

	var i2 int32 = 148
	s2 := fmt.Sprintf("%d", i2)
	fmt.Printf("i2: %s\n", s2)
	// :show end
}
---
@url: https://repl.it/@kjk1/book-int-from-string-atoi
main.go:+238
package main

import (
	"fmt"
	"log"
	"strconv"
)

func main() {
	// :show start
	s := "-48"
	i1, err := strconv.Atoi(s)
	if err != nil {
		log.Fatalf("strconv.Atoi() failed with %s\n", err)
	}
	fmt.Printf("i1: %d\n", i1)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-int-to-str-sscanf
main.go:+242
package main

import (
	"fmt"
	"log"
)

func main() {
	// :show start
	s := "348"
	var i int
	_, err := fmt.Sscanf(s, "%d", &i)
	if err != nil {
		log.Fatalf("fmt.Sscanf failed with '%s'\n", err)
	}
	fmt.Printf("i1: %d\n", i)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-floating-point
main.go:+336
package main

import (
	"fmt"
	"strconv"
)

func main() {
	// :show start
	var f32 float32 = 1.3
	bitSize := 32
	s1 := strconv.FormatFloat(float64(f32), 'E', -1, bitSize)
	fmt.Printf("f32: %s\n", s1)

	var f64 float64 = 8.1234
	bitSize = 64
	s2 := strconv.FormatFloat(f64, 'e', -1, bitSize)
	fmt.Printf("f64: %s\n", s2)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-floating-point-2
main.go:+158
package main

import "fmt"

func main() {
	// :show start
	var f64 float64 = 1.54
	s := fmt.Sprintf("%f", f64)
	fmt.Printf("f is: '%s'\n", s)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-floating-point-3
main.go:+262
package main

import (
	"fmt"
	"log"
	"strconv"
)

func main() {
	// :show start
	s := "1.2341"
	f64, err := strconv.ParseFloat(s, 64)
	if err != nil {
		log.Fatalf("strconv.ParseFloat() failed with '%s'\n", err)
	}
	fmt.Printf("f64: %f\n", f64)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-floating-point-4
main.go:+248
package main

import (
	"fmt"
	"log"
)

func main() {
	// :show start
	s := "1.2341"
	var f float64
	_, err := fmt.Sscanf(s, "%f", &f)
	if err != nil {
		log.Fatalf("fmt.Sscanf failed with '%s'\n", err)
	}
	fmt.Printf("f: %f\n", f)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-characters
main.go:+191
package main

import "fmt"

func main() {
	// :show start
	s := "str"
	for i := 0; i < len(s); i++ {
		c := s[i]
		fmt.Printf("Byte at index %d is '%c' (0x%x)\n", i, c, c)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-characters-2
main.go:+188
package main

import "fmt"

func main() {
	// :show start
	s := "日本語"
	for i, runeChar := range s {
		fmt.Printf("Rune at byte position %d is %#U\n", i, runeChar)
	}
	// :show end
}

---
@url: https://repl.it/@kjk1/book-strings
main.go:+286
package main

import "fmt"

func main() {
	// :show start
	var s string // empty string ""
	s1 := "string\nliteral\nwith\tescape characters\n"
	s2 := `raw string literal
which doesnt't recgonize escape characters like \n
`
	fmt.Printf("sum of strings\n'%s'\n", s+s1+s2)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-constants
main.go:+414
// no output
package main

// :show start
const (
	i  int = 32       // int constant
	s      = "string" // string constant
	i2     = 33       // untyped number constant
)

var (
	// values that are not read-only (like slices or maps or structs) cannot be
	// constants
	// we can declare them as top-level variables
	b = []byte{3, 4} // this could not be a constant
)

// :show end

func main() {
	// do nothing
}

---
@url: https://repl.it/@kjk1/book-array-basics
main.go:+289
package main

import "fmt"

func main() {
	// :show start
	var a1 = [2]byte{3, 8} // array of 2 bytes
	// when using [...] size will be deduced from { ... }
	a2 := [...]int{1, 2, 3} // array of 3 integers

	fmt.Printf("Size of a1: %d.\nSize of a2: %d\n", len(a1), len(a2))
	// :show end
}

---
@url: https://repl.it/@kjk1/book-map-basics
main.go:+545
package main

import "fmt"

func main() {
	// :show start
	m := make(map[string]int)
	m["number3"] = 3

	checkKey := func(k string) {
		if n, ok := m[k]; ok {
			fmt.Printf("value for key '%s' is %d\n", k, n)
		} else {
			fmt.Printf("key '%s' doesn't exist in map\n", k)
		}
	}

	// get value for a key that exists
	checkKey("number3")

	// get value for a key that doesn't exist
	checkKey("number4")

	// remove a key
	delete(m, "number3")
	fmt.Printf("deleted key 'number3\n")
	checkKey("number3") // and now it doesn't exist
	// :show end
}

---
@url: https://repl.it/@kjk1/book-structs-basics
main.go:+182
// no output
package main

// :show start
type MyStruct struct {
	IntVal           int
	StringVal        string
	unexportedIntVal int
}

// :show end

func main() {
	// do nothing
}

---
@url: https://repl.it/@kjk1/book-pointers-basics
main.go:+180
package main

import "fmt"

func main() {
	// :show start
	var a int = 4
	pa := &a
	fmt.Printf("Address of a variable in memory is %p. Its value is: %d\n", pa, *pa)
	// :show end
}
---
@url: https://repl.it/@kjk1/book-channels-basics
main.go:+364
package main

import "fmt"

func main() {
	// :show start
	// create unbuffered channel of int values with capacity of 1
	ch := make(chan int)
	// start a new goroutine that sends value 3 over a channel
	go func() { ch <- 3 }()
	// read the value from a channel
	// it waits until goroutine above sends a value
	n := <-ch
	fmt.Printf("n: %d\n", n)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-zero-values
main.go:+1008
package main

import "fmt"

func main() {
	// :show start
	var zeroBool bool
	var zeroInt int
	var zeroF32 float32
	var zeroF64 float64
	var zeroStr string
	var zeroPtr *int
	var zeroSlice []uint32
	var zeroMap map[string]int
	var zeroInterface interface{}
	var zeroChan chan bool
	var zeroArray [5]int
	type struc struct {
		a int
		b string
	}
	var zeroStruct struc
	var zeroFunc func(bool)

  fmt.Println("zero values for basic types:")
	fmt.Printf("bool:       %v\n", zeroBool)
	fmt.Printf("int:        %v\n", zeroInt)
	fmt.Printf("float32:    %v\n", zeroF32)
	fmt.Printf("float64:    %v\n", zeroF64)
	fmt.Printf("string:     %#v\n", zeroStr)
	fmt.Printf("pointer:    %v\n", zeroPtr)
	fmt.Printf("slice:      %v\n", zeroSlice)
	fmt.Printf("map:        %#v\n", zeroMap)
	fmt.Printf("interface:  %v\n", zeroInterface)
	fmt.Printf("channel:    %v\n", zeroChan)
	fmt.Printf("array:      %v\n", zeroArray)
	fmt.Printf("struct:     %#v\n", zeroStruct)
	fmt.Printf("function:   %v\n", zeroFunc)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-type-casting-basics
main.go:+521
// no output
package main

func main() {
	// :show start
	// you can cast between numbers i.e. integers of various sizes and floating point numbers
	var i1 int32 = 3
	var i2 int = int(i1) // we must explicitly cast from int32 to int
	var f float64 = float64(i1)

	s := "string"
	// we can cast between string and []byte and vice-versa
	// note that unless optimizted by the compiler, this involves allocation
	var d []byte = []byte(s)
	// :show end

	_, _, _ = i2, f, d // silence compiler error about unused variables
}

---
@url: https://repl.it/@kjk1/book-define-variables
main.go:+1130
package main

import (
	"bytes"
	"fmt"
	"io"
)

// :show start
// declaration of a single top-level variable
var topLevel int64 = 5

// grouping of multiple top-level declarations
var (
	intVal int            // value is initialized with zero-value
	str    string = "str" // assigning

	// functions are first-class values so can be assigned to variables
	// fn is variable of type func(a int) string
	// it's uninitialized so is nil (zero-value for function variables)
	fn func(a int) string
)

func f() {
	// shorthand using local type inference
	// type of `i` is int and is inferred from the value
	// note: this is not allowed at top-level
	i := 4

	// grouping inside a function
	var (
		i2 int
		s  string
	)

	// _ is like a variable whose value is discarded. It's called blank identifier.
	// Useful when we don't care about one of the values returned by a function
	_, err := io.Copy(dst, src) // don't care how many bytes were written
	// ...

	fmt.Printf("i: %d, i2: %d, s: %s, err: %v\n", i, i2, s, err)
}

// :show end

var (
	dst io.Writer = &bytes.Buffer{}
	src io.Reader = &bytes.Buffer{}
)

func main() {
	f()
}

---
@url: https://repl.it/@kjk1/book-constants-2
main.go:+319
// no output
package main

// :show start
// Greeting is an exported (public) string constant
const Greeting string = "Hello World"

// we can group const declarations
const (
	// years is an unexported (package private) int constant
	years int  = 10
	truth bool = true
)

// :show end

func main() {
	// do  nothing
}

---
@url: https://repl.it/@kjk1/book-constants-3
main.go:+536
package main

import (
	"fmt"
	"math"
)

const s string = "constant"

func main() {
	fmt.Println(s) // constant

	// A `const` statement can appear anywhere a `var` statement can.
	const n = 10
	fmt.Println(n)                           // 10
	fmt.Printf("n=%d is of type %T\n", n, n) // n=10 is of type int

	const m float64 = 4.3
	fmt.Println(m) // 4.3

	// An untyped constant takes the type needed by its context.
	// For example, here `math.Sin` expects a `float64`.
	const x = 10
	fmt.Println(math.Sin(x)) // -0.5440211108893699
}

---
@url: https://repl.it/@kjk1/book-basic-variable
main.go:+702
// no output
package main

type Person struct {
	FirstName string
	LastName  string
}

func main() {
	// :show start
	// Basic variable declaration. Declares a variable of type specified on the right.
	// The variable is initialized to the zero value of the respective type.
	var x int
	var s string
	var p Person // Assuming type Person struct {}

	// Assignment of a value to a variable
	x = 3

	// Short declaration using := infers the type
	y := 4

	u := int64(100)    // declare variable of type int64 and init with 100
	var u2 int64 = 100 // declare variable of type int64 and init with 100
	// :show end

	// silence compiler error about unused variables
	_, _, _, _, _, _ = x, s, p, y, u, u2
}

---
@url: https://repl.it/@kjk1/book-multiple-variables
main.go:+476
// no output
package main

func main() {
	// :show start
	// You can declare multiple variables of the same type in one line
	var a, b, c string

	var d, e string = "Hello", "world!"

	// You can also use short declaration to assign multiple variables
	x, y, z := 1, 2, 3

	foo, bar := 4, "stack" // `foo` is type `int`, `bar` is type `string`
	// :show end

	// silence compiler error about unused variables
	_, _, _, _, _, _, _, _, _, _ = a, b, c, d, e, x, y, z, foo, bar
}

---
@url: https://repl.it/@kjk1/book-multiple-variable
main.go:+331
package main

import "fmt"

// :show start
func multipleReturn() (int, int) {
	return 1, 2
}

func multipleReturn2() (a int, b int) {
	a = 3
	b = 4
	return
}

func main() {
	x, y := multipleReturn()  // x = 1, y = 2
	w, z := multipleReturn2() // w = 3, z = 4
	fmt.Printf("x: %d, y: %d\nw: %d, z: %d\n", x, y, w, z)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-blank-identifier
main.go:+256
package main

import "fmt"

// :show start
func SumProduct(a, b int) (int, int) {
	return a + b, a * b
}

func main() {
	// only need the sum
	sum, _ := SumProduct(1, 2) // the product gets discarded
	fmt.Println(sum)           // prints 3
}

// :show end

---
@url: https://repl.it/@kjk1/book-blank-identifier-2
main.go:+263
package main

import "fmt"

// :show start
func main() {
	pets := []string{"dog", "cat", "fish"}

	// range returns both the current index and value
	// but sometimes we only need one or the other
	for _, pet := range pets {
		fmt.Println(pet)
	}
}

// :show end

---
@url: https://repl.it/@kjk1/book-typed-vs-untyped
main.go:+687
// allow error
package main

func main() {
	// :show start
	const untypedNumber = 345

	// if this was a variable declaration, untypedNumber would have its type
	// inferred as int.
	// since it's a const, it remains untyped until it's e.g. assigned to a variable
	var i int = untypedNumber      // no need to cast to int
	var u16 uint16 = untypedNumber // no need to cast to uint16
	var f float64 = untypedNumber  // no need to cast to float64

	// incompatible assignments are detected by the compiler
	// 345 is too big to fit in int8 and compiler detects that
	var b int8 = untypedNumber

	// :show end

	// silence compiler error about unused variables
	_, _, _, _ = i, u16, f, b
}

---
@url: https://repl.it/@kjk1/book-iota
main.go:+182

package main

import "fmt"

func main() {
	// :show start
	const (
		Low = iota
		Medium
		High
	)
	fmt.Printf("Low: %d\nMedium: %d\nHigh: %d\n", Low, Medium, High)

	// :show end
}
---
@url: https://repl.it/@kjk1/book-iota-2
main.go:+414
package main

import "fmt"

func main() {
	// :show start
	const (
		Secure = 1 << iota // 0b001
		Authn              // 0b010
		Ready              // 0b100
	)

	ConnState := Secure | Authn // 0b011: Connection is secure and authenticated, but not yet Ready

	fmt.Printf("Secure: 0x%x (0b%03b)\nAuthn: 0x%x (0b%03b)\nConnState: 0x%x (0b%03b)\n", Secure, Secure, Authn, Authn, ConnState, ConnState)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-iota-3
main.go:+310
package main

import "fmt"

func main() {
	// :show start
	const ( // iota is reset to 0
		a = 1 << iota // a == 1
		b = 1 << iota // b == 2
		c = 3         // c == 3  (iota is not used but still incremented)
		d = 1 << iota // d == 8
	)
	fmt.Printf("a: %d, b: %d, c: %d, d: %d\n", a, b, c, d)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-iota-4
main.go:+196
package main

import "fmt"

func main() {
	// :show start
	const (
		a = iota // a = 0
		_        // iota is incremented
		b        // b = 2
	)
	fmt.Printf("a: %d, b: %d\n", a, b)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-iota-5
main.go:+440
package main

import "fmt"

func main() {
	// :show start
	const (
		bit0, mask0 = 1 << iota, 1<<iota - 1 // bit0 == 1, mask0 == 0
		bit1, mask1                          // bit1 == 2, mask1 == 1
		_, _                                 // skips iota == 2
		bit3, mask3                          // bit3 == 8, mask3 == 7
	)
	fmt.Printf("bit0: %d, mask0: 0x%x\n", bit0, mask0)
	fmt.Printf("bit3: %d, mask3: 0x%x\n", bit3, mask3)
	// :show end
}

---
@url: https://repl.it/@kjk1/book-iota-6
main.go:+263
package main

import "fmt"

func main() {
	// :show start
	type ByteSize int

	const (
		_           = iota // ignore first value by assigning to blank identifier
		KB ByteSize = 1 << (10 * iota)
		MB
		GB
		TB
		PB
	)
	fmt.Printf("KB: %d\n", KB)
	// :show end
}

---
