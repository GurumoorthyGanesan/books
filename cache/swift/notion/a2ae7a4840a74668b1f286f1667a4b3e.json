{
  "ID": "a2ae7a48-40a7-4668-b1f2-86f1667a4b3e",
  "Root": {
    "alive": true,
    "content": [
      "7613511c-9e5d-4873-b7b3-641025cad0be",
      "1a6ce0cd-bdc3-4c7c-a5ef-6fa1f1e0bbc0",
      "bb52f5f3-31bd-415f-a641-976d42cef43d",
      "43fad728-fad7-4ed3-a0b8-6649c5e4c397",
      "3f6d711f-057c-4de7-80d5-d37d6ab02d35",
      "877d16b9-61fa-4b1e-bd8e-a46e4eb43a33",
      "0cd8dde0-0282-47cd-86a3-f31872ee9731",
      "a4d945c4-c584-4792-8cab-2406a0d1ff8b",
      "11e53b17-80c5-4daf-9477-0536b360e53a",
      "46936932-570f-4824-8060-f56f4e5f72f5",
      "f66d1937-54c5-4ef0-a9b3-fa2644c66f6b",
      "05aeac02-f7de-46b2-b2a9-308dcab97857",
      "277eb1e2-651d-44b4-a044-c29d9c02bf44",
      "0c0d7863-3b2d-4066-9601-58a0b4e86d10",
      "dffde78b-3044-4c5d-a798-ff341b73bb09",
      "ce37dcd4-d5f4-4209-af4a-30680f0c3e3b"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1552105930060,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "a2ae7a48-40a7-4668-b1f2-86f1667a4b3e",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1552105930060,
    "parent_id": "36fdcbe2-b28e-4eae-96d0-f3255977fddc",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Graph Trie Stack"
        ]
      ]
    },
    "type": "page",
    "version": 3,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1552105930052,
        "id": "7613511c-9e5d-4873-b7b3-641025cad0be",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1552105930052,
        "parent_id": "a2ae7a48-40a7-4668-b1f2-86f1667a4b3e",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Graph",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Graph",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1552105930056,
        "id": "1a6ce0cd-bdc3-4c7c-a5ef-6fa1f1e0bbc0",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1552105930056,
        "parent_id": "a2ae7a48-40a7-4668-b1f2-86f1667a4b3e",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "In computer science, a graph is an abstract data type that is meant to implement the undirected graph and directed graph concepts from mathematics. A graph data structure consists of a finite (and possibly mutable) set of vertices or nodes or points, together with a set of unordered pairs of these vertices for an undirected graph or a set of ordered pairs for a directed graph. These pairs are known as edges, arcs, or lines for an undirected graph and as arrows, directed edges, directed arcs, or directed lines for a directed graph. The vertices may be part of the graph structure, or may be external entities represented by integer indices or references. A graph data structure may also associate to each edge some edge value, such as a symbolic label or a numeric attribute (cost, capacity, length, etc.). (Wikipedia, "
            ],
            [
              "source",
              [
                [
                  "a",
                  "https://en.wikipedia.org/wiki/Graph_(abstract_data_type)"
                ]
              ]
            ],
            [
              ")"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "In computer science, a graph is an abstract data type that is meant to implement the undirected graph and directed graph concepts from mathematics. A graph data structure consists of a finite (and possibly mutable) set of vertices or nodes or points, together with a set of unordered pairs of these vertices for an undirected graph or a set of ordered pairs for a directed graph. These pairs are known as edges, arcs, or lines for an undirected graph and as arrows, directed edges, directed arcs, or directed lines for a directed graph. The vertices may be part of the graph structure, or may be external entities represented by integer indices or references. A graph data structure may also associate to each edge some edge value, such as a symbolic label or a numeric attribute (cost, capacity, length, etc.). (Wikipedia, "
          },
          {
            "Text": "source",
            "Link": "https://en.wikipedia.org/wiki/Graph_(abstract_data_type)"
          },
          {
            "Text": ")"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1552105930057,
        "id": "bb52f5f3-31bd-415f-a641-976d42cef43d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1552105930057,
        "parent_id": "a2ae7a48-40a7-4668-b1f2-86f1667a4b3e",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "//\n//  GraphFactory.swift\n//  SwiftStructures\n//\n//  Created by Wayne Bishop on 6/7/14.\n//  Copyright (c) 2014 Arbutus Software Inc. All rights reserved.\n//\nimport Foundation\n\n\npublic class SwiftGraph {\n   \n    \n    //declare a default directed graph canvas\n    private var canvas: Array\u003cVertex\u003e\n    public var isDirected: Bool\n    \n    \n    init() {\n        canvas = Array\u003cVertex\u003e()\n        isDirected = true\n    }\n    \n    \n    //create a new vertex\n    func addVertex(key: String) -\u003e Vertex {\n        \n        \n        //set the key\n        let childVertex: Vertex = Vertex()\n        childVertex.key = key\n        \n        \n        //add the vertex to the graph canvas\n        canvas.append(childVertex)\n        \n        \n        return childVertex\n    }\n    \n    \n    \n    //add edge to source vertex\n    func addEdge(source: Vertex, neighbor: Vertex, weight: Int) {\n        \n        \n        //create a new edge\n        let newEdge = Edge()\n        \n        \n        //establish the default properties\n        newEdge.neighbor = neighbor\n        newEdge.weight = weight\n        source.neighbors.append(newEdge)\n        \n        \n        print(\"The neighbor of vertex: \\(source.key as String!) is \\(neighbor.key as String!)..\")\n        \n        \n        //check condition for an undirected graph\n        if isDirected == false {\n            \n            \n           //create a new reversed edge\n           let reverseEdge = Edge()\n            \n            \n           //establish the reversed properties\n           reverseEdge.neighbor = source\n           reverseEdge.weight = weight\n           neighbor.neighbors.append(reverseEdge)\n            \n           print(\"The neighbor of vertex: \\(neighbor.key as String!) is \\(source.key as String!)..\")\n            \n        }\n        \n        \n    }\n\n    \n    \n    \n    \n    /* reverse the sequence of paths given the shortest path.\n       process analagous to reversing a linked list. */\n\n    func reversePath(_ head: Path!, source: Vertex) -\u003e Path! {\n        \n        \n        guard head != nil else {\n            return head\n        }\n        \n        //mutated copy\n        var output = head\n        \n        \n        var current: Path! = output\n        var prev: Path!\n        var next: Path!\n        \n        \n        while(current != nil) {\n            next = current.previous\n            current.previous = prev\n            prev = current\n            current = next\n        }\n        \n        \n        //append the source path to the sequence\n        let sourcePath: Path = Path()\n        \n        sourcePath.destination = source\n        sourcePath.previous = prev\n        sourcePath.total = nil\n        \n        output = sourcePath\n        \n        \n        return output\n        \n    }\n\n    \n    \n    \n    //process Dijkstra's shortest path algorthim\n    func processDijkstra(_ source: Vertex, destination: Vertex) -\u003e Path? {\n        \n        \n        var frontier: Array\u003cPath\u003e = Array\u003cPath\u003e()\n        var finalPaths: Array\u003cPath\u003e = Array\u003cPath\u003e()\n        \n        \n        //use source edges to create the frontier\n        for e in source.neighbors {\n            \n            let newPath: Path = Path()\n            \n            \n            newPath.destination = e.neighbor\n            newPath.previous = nil\n            newPath.total = e.weight\n            \n            \n            //add the new path to the frontier\n            frontier.append(newPath)\n            \n        }\n        \n\n        //construct the best path\n        var bestPath: Path = Path()\n        \n        \n        while frontier.count != 0 {\n            \n            //support path changes using the greedy approach\n            bestPath = Path()\n            var pathIndex: Int = 0\n\n            \n            for x in 0..\u003cfrontier.count {\n               \n                let itemPath: Path = frontier[x]\n                \n                if  (bestPath.total == nil) || (itemPath.total \u003c bestPath.total) {\n                    bestPath = itemPath\n                    pathIndex = x\n                }\n                \n            }\n            \n            \n            \n            //enumerate the bestPath edges\n            for e in bestPath.destination.neighbors {\n                \n                let newPath: Path = Path()\n                \n                newPath.destination = e.neighbor\n                newPath.previous = bestPath\n                newPath.total = bestPath.total + e.weight\n                \n                \n                //add the new path to the frontier\n                frontier.append(newPath)\n                \n            }\n            \n            \n            //preserve the bestPath\n            finalPaths.append(bestPath)\n            \n            \n            //remove the bestPath from the frontier\n            //frontier.removeAtIndex(pathIndex) - Swift2\n            frontier.remove(at: pathIndex)\n            \n            \n            \n        } //end while\n        \n        \n    \n        //establish the shortest path as an optional\n        var shortestPath: Path! = Path()\n        \n        \n        for itemPath in finalPaths {\n            \n            if (itemPath.destination.key == destination.key) {\n                \n                if  (shortestPath.total == nil) || (itemPath.total \u003c shortestPath.total) {\n                    shortestPath = itemPath\n                }\n                \n            }\n            \n        }\n        \n        \n        return shortestPath\n        \n    }\n    \n    \n    \n    ///an optimized version of Dijkstra's shortest path algorthim\n    func processDijkstraWithHeap(_ source: Vertex, destination: Vertex) -\u003e Path! {\n        \n        \n        let frontier: PathHeap = PathHeap()\n        let finalPaths: PathHeap = PathHeap()\n        \n        \n        //use source edges to create the frontier\n        for e in source.neighbors {\n            \n            let newPath: Path = Path()\n            \n            \n            newPath.destination = e.neighbor\n            newPath.previous = nil\n            newPath.total = e.weight\n            \n            \n            //add the new path to the frontier\n            frontier.enQueue(newPath)\n            \n        }\n        \n        \n        //construct the best path\n        var bestPath: Path = Path()\n        \n        \n        while frontier.count != 0 {\n                        \n            //use the greedy approach to obtain the best path\n            bestPath = Path()\n            bestPath = frontier.peek()\n            \n            \n            //enumerate the bestPath edges\n            for e in bestPath.destination.neighbors {\n                \n                let newPath: Path = Path()\n                \n                newPath.destination = e.neighbor\n                newPath.previous = bestPath\n                newPath.total = bestPath.total + e.weight\n                \n                \n                //add the new path to the frontier\n                frontier.enQueue(newPath)\n                \n            }\n            \n            \n            //preserve the bestPaths that match destination\n            if (bestPath.destination.key == destination.key) {\n                finalPaths.enQueue(bestPath)\n            }\n            \n            \n            //remove the bestPath from the frontier\n            frontier.deQueue()\n            \n            \n        } //end while\n        \n        \n        \n        //obtain the shortest path from the heap\n        var shortestPath: Path! = Path()\n        shortestPath = finalPaths.peek()\n        \n        \n        return shortestPath\n        \n    }\n    \n    \n    //MARK: traversal algorithms\n    \n    \n    //bfs traversal with inout closure function\n    func traverse(_ startingv: Vertex, formula: (_ node: inout Vertex) -\u003e ()) {\n\n        \n        //establish a new queue\n        let graphQueue: Queue\u003cVertex\u003e = Queue\u003cVertex\u003e()\n        \n        \n        //queue a starting vertex\n        graphQueue.enQueue(startingv)\n        \n        \n        while !graphQueue.isEmpty() {\n            \n            //traverse the next queued vertex\n            var vitem: Vertex = graphQueue.deQueue() as Vertex!\n            \n            \n            //add unvisited vertices to the queue\n            for e in vitem.neighbors {\n                if e.neighbor.visited == false {\n                    print(\"adding vertex: \\(e.neighbor.key!) to queue..\")\n                    graphQueue.enQueue(e.neighbor)\n                }\n            }\n            \n\n            /*\n            notes: this demonstrates how to invoke a closure with an inout parameter.\n            By passing by reference no return value is required.\n            */\n            \n            //invoke formula\n            formula(\u0026vitem)\n            \n            \n        } //end while\n        \n        \n        print(\"graph traversal complete..\")\n        \n        \n    }\n\n    \n    \n    \n    //breadth first search\n    func traverse(_ startingv: Vertex) {\n        \n        \n        //establish a new queue\n        let graphQueue: Queue\u003cVertex\u003e = Queue\u003cVertex\u003e()\n        \n        \n        //queue a starting vertex\n        graphQueue.enQueue(startingv)\n        \n        \n        while !graphQueue.isEmpty() {\n            \n            //traverse the next queued vertex\n            let vitem = graphQueue.deQueue() as Vertex!\n            \n            guard vitem != nil else {\n                return\n            }\n            \n            //add unvisited vertices to the queue\n            for e in vitem!.neighbors {\n                if e.neighbor.visited == false {\n                    print(\"adding vertex: \\(e.neighbor.key!) to queue..\")\n                    graphQueue.enQueue(e.neighbor)\n                }\n            }\n            \n            \n            vitem!.visited = true\n            print(\"traversed vertex: \\(vitem!.key!)..\")\n            \n            \n        } //end while\n        \n        \n        print(\"graph traversal complete..\")\n        \n        \n    } //end function\n    \n    \n    \n    //use bfs with trailing closure to update all values\n    func update(startingv: Vertex, formula:((Vertex) -\u003e Bool)) {\n        \n        \n        //establish a new queue\n        let graphQueue: Queue\u003cVertex\u003e = Queue\u003cVertex\u003e()\n        \n        \n        //queue a starting vertex\n        graphQueue.enQueue(startingv)\n        \n        \n        while !graphQueue.isEmpty() {\n            \n            //traverse the next queued vertex\n            let vitem = graphQueue.deQueue() as Vertex!            \n            \n            guard vitem != nil else {\n                return\n            }\n            \n            //add unvisited vertices to the queue\n            for e in vitem!.neighbors {\n                if e.neighbor.visited == false {\n                    print(\"adding vertex: \\(e.neighbor.key!) to queue..\")\n                    graphQueue.enQueue(e.neighbor)\n                }\n            }\n            \n            \n            //apply formula..\n            if formula(vitem!) == false {\n                print(\"formula unable to update: \\(vitem!.key)\")\n            }\n            else {\n                print(\"traversed vertex: \\(vitem!.key!)..\")\n            }\n            \n            vitem!.visited = true\n            \n            \n        } //end while\n        \n        \n        print(\"graph traversal complete..\")\n        \n        \n    }\n\n    \n\n    \n    \n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "//\n//  GraphFactory.swift\n//  SwiftStructures\n//\n//  Created by Wayne Bishop on 6/7/14.\n//  Copyright (c) 2014 Arbutus Software Inc. All rights reserved.\n//\nimport Foundation\n\n\npublic class SwiftGraph {\n   \n    \n    //declare a default directed graph canvas\n    private var canvas: Array\u003cVertex\u003e\n    public var isDirected: Bool\n    \n    \n    init() {\n        canvas = Array\u003cVertex\u003e()\n        isDirected = true\n    }\n    \n    \n    //create a new vertex\n    func addVertex(key: String) -\u003e Vertex {\n        \n        \n        //set the key\n        let childVertex: Vertex = Vertex()\n        childVertex.key = key\n        \n        \n        //add the vertex to the graph canvas\n        canvas.append(childVertex)\n        \n        \n        return childVertex\n    }\n    \n    \n    \n    //add edge to source vertex\n    func addEdge(source: Vertex, neighbor: Vertex, weight: Int) {\n        \n        \n        //create a new edge\n        let newEdge = Edge()\n        \n        \n        //establish the default properties\n        newEdge.neighbor = neighbor\n        newEdge.weight = weight\n        source.neighbors.append(newEdge)\n        \n        \n        print(\"The neighbor of vertex: \\(source.key as String!) is \\(neighbor.key as String!)..\")\n        \n        \n        //check condition for an undirected graph\n        if isDirected == false {\n            \n            \n           //create a new reversed edge\n           let reverseEdge = Edge()\n            \n            \n           //establish the reversed properties\n           reverseEdge.neighbor = source\n           reverseEdge.weight = weight\n           neighbor.neighbors.append(reverseEdge)\n            \n           print(\"The neighbor of vertex: \\(neighbor.key as String!) is \\(source.key as String!)..\")\n            \n        }\n        \n        \n    }\n\n    \n    \n    \n    \n    /* reverse the sequence of paths given the shortest path.\n       process analagous to reversing a linked list. */\n\n    func reversePath(_ head: Path!, source: Vertex) -\u003e Path! {\n        \n        \n        guard head != nil else {\n            return head\n        }\n        \n        //mutated copy\n        var output = head\n        \n        \n        var current: Path! = output\n        var prev: Path!\n        var next: Path!\n        \n        \n        while(current != nil) {\n            next = current.previous\n            current.previous = prev\n            prev = current\n            current = next\n        }\n        \n        \n        //append the source path to the sequence\n        let sourcePath: Path = Path()\n        \n        sourcePath.destination = source\n        sourcePath.previous = prev\n        sourcePath.total = nil\n        \n        output = sourcePath\n        \n        \n        return output\n        \n    }\n\n    \n    \n    \n    //process Dijkstra's shortest path algorthim\n    func processDijkstra(_ source: Vertex, destination: Vertex) -\u003e Path? {\n        \n        \n        var frontier: Array\u003cPath\u003e = Array\u003cPath\u003e()\n        var finalPaths: Array\u003cPath\u003e = Array\u003cPath\u003e()\n        \n        \n        //use source edges to create the frontier\n        for e in source.neighbors {\n            \n            let newPath: Path = Path()\n            \n            \n            newPath.destination = e.neighbor\n            newPath.previous = nil\n            newPath.total = e.weight\n            \n            \n            //add the new path to the frontier\n            frontier.append(newPath)\n            \n        }\n        \n\n        //construct the best path\n        var bestPath: Path = Path()\n        \n        \n        while frontier.count != 0 {\n            \n            //support path changes using the greedy approach\n            bestPath = Path()\n            var pathIndex: Int = 0\n\n            \n            for x in 0..\u003cfrontier.count {\n               \n                let itemPath: Path = frontier[x]\n                \n                if  (bestPath.total == nil) || (itemPath.total \u003c bestPath.total) {\n                    bestPath = itemPath\n                    pathIndex = x\n                }\n                \n            }\n            \n            \n            \n            //enumerate the bestPath edges\n            for e in bestPath.destination.neighbors {\n                \n                let newPath: Path = Path()\n                \n                newPath.destination = e.neighbor\n                newPath.previous = bestPath\n                newPath.total = bestPath.total + e.weight\n                \n                \n                //add the new path to the frontier\n                frontier.append(newPath)\n                \n            }\n            \n            \n            //preserve the bestPath\n            finalPaths.append(bestPath)\n            \n            \n            //remove the bestPath from the frontier\n            //frontier.removeAtIndex(pathIndex) - Swift2\n            frontier.remove(at: pathIndex)\n            \n            \n            \n        } //end while\n        \n        \n    \n        //establish the shortest path as an optional\n        var shortestPath: Path! = Path()\n        \n        \n        for itemPath in finalPaths {\n            \n            if (itemPath.destination.key == destination.key) {\n                \n                if  (shortestPath.total == nil) || (itemPath.total \u003c shortestPath.total) {\n                    shortestPath = itemPath\n                }\n                \n            }\n            \n        }\n        \n        \n        return shortestPath\n        \n    }\n    \n    \n    \n    ///an optimized version of Dijkstra's shortest path algorthim\n    func processDijkstraWithHeap(_ source: Vertex, destination: Vertex) -\u003e Path! {\n        \n        \n        let frontier: PathHeap = PathHeap()\n        let finalPaths: PathHeap = PathHeap()\n        \n        \n        //use source edges to create the frontier\n        for e in source.neighbors {\n            \n            let newPath: Path = Path()\n            \n            \n            newPath.destination = e.neighbor\n            newPath.previous = nil\n            newPath.total = e.weight\n            \n            \n            //add the new path to the frontier\n            frontier.enQueue(newPath)\n            \n        }\n        \n        \n        //construct the best path\n        var bestPath: Path = Path()\n        \n        \n        while frontier.count != 0 {\n                        \n            //use the greedy approach to obtain the best path\n            bestPath = Path()\n            bestPath = frontier.peek()\n            \n            \n            //enumerate the bestPath edges\n            for e in bestPath.destination.neighbors {\n                \n                let newPath: Path = Path()\n                \n                newPath.destination = e.neighbor\n                newPath.previous = bestPath\n                newPath.total = bestPath.total + e.weight\n                \n                \n                //add the new path to the frontier\n                frontier.enQueue(newPath)\n                \n            }\n            \n            \n            //preserve the bestPaths that match destination\n            if (bestPath.destination.key == destination.key) {\n                finalPaths.enQueue(bestPath)\n            }\n            \n            \n            //remove the bestPath from the frontier\n            frontier.deQueue()\n            \n            \n        } //end while\n        \n        \n        \n        //obtain the shortest path from the heap\n        var shortestPath: Path! = Path()\n        shortestPath = finalPaths.peek()\n        \n        \n        return shortestPath\n        \n    }\n    \n    \n    //MARK: traversal algorithms\n    \n    \n    //bfs traversal with inout closure function\n    func traverse(_ startingv: Vertex, formula: (_ node: inout Vertex) -\u003e ()) {\n\n        \n        //establish a new queue\n        let graphQueue: Queue\u003cVertex\u003e = Queue\u003cVertex\u003e()\n        \n        \n        //queue a starting vertex\n        graphQueue.enQueue(startingv)\n        \n        \n        while !graphQueue.isEmpty() {\n            \n            //traverse the next queued vertex\n            var vitem: Vertex = graphQueue.deQueue() as Vertex!\n            \n            \n            //add unvisited vertices to the queue\n            for e in vitem.neighbors {\n                if e.neighbor.visited == false {\n                    print(\"adding vertex: \\(e.neighbor.key!) to queue..\")\n                    graphQueue.enQueue(e.neighbor)\n                }\n            }\n            \n\n            /*\n            notes: this demonstrates how to invoke a closure with an inout parameter.\n            By passing by reference no return value is required.\n            */\n            \n            //invoke formula\n            formula(\u0026vitem)\n            \n            \n        } //end while\n        \n        \n        print(\"graph traversal complete..\")\n        \n        \n    }\n\n    \n    \n    \n    //breadth first search\n    func traverse(_ startingv: Vertex) {\n        \n        \n        //establish a new queue\n        let graphQueue: Queue\u003cVertex\u003e = Queue\u003cVertex\u003e()\n        \n        \n        //queue a starting vertex\n        graphQueue.enQueue(startingv)\n        \n        \n        while !graphQueue.isEmpty() {\n            \n            //traverse the next queued vertex\n            let vitem = graphQueue.deQueue() as Vertex!\n            \n            guard vitem != nil else {\n                return\n            }\n            \n            //add unvisited vertices to the queue\n            for e in vitem!.neighbors {\n                if e.neighbor.visited == false {\n                    print(\"adding vertex: \\(e.neighbor.key!) to queue..\")\n                    graphQueue.enQueue(e.neighbor)\n                }\n            }\n            \n            \n            vitem!.visited = true\n            print(\"traversed vertex: \\(vitem!.key!)..\")\n            \n            \n        } //end while\n        \n        \n        print(\"graph traversal complete..\")\n        \n        \n    } //end function\n    \n    \n    \n    //use bfs with trailing closure to update all values\n    func update(startingv: Vertex, formula:((Vertex) -\u003e Bool)) {\n        \n        \n        //establish a new queue\n        let graphQueue: Queue\u003cVertex\u003e = Queue\u003cVertex\u003e()\n        \n        \n        //queue a starting vertex\n        graphQueue.enQueue(startingv)\n        \n        \n        while !graphQueue.isEmpty() {\n            \n            //traverse the next queued vertex\n            let vitem = graphQueue.deQueue() as Vertex!            \n            \n            guard vitem != nil else {\n                return\n            }\n            \n            //add unvisited vertices to the queue\n            for e in vitem!.neighbors {\n                if e.neighbor.visited == false {\n                    print(\"adding vertex: \\(e.neighbor.key!) to queue..\")\n                    graphQueue.enQueue(e.neighbor)\n                }\n            }\n            \n            \n            //apply formula..\n            if formula(vitem!) == false {\n                print(\"formula unable to update: \\(vitem!.key)\")\n            }\n            else {\n                print(\"traversed vertex: \\(vitem!.key!)..\")\n            }\n            \n            vitem!.visited = true\n            \n            \n        } //end while\n        \n        \n        print(\"graph traversal complete..\")\n        \n        \n    }\n\n    \n\n    \n    \n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1552105930057,
        "id": "43fad728-fad7-4ed3-a0b8-6649c5e4c397",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1552105930057,
        "parent_id": "a2ae7a48-40a7-4668-b1f2-86f1667a4b3e",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Trie",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Trie",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1552105930057,
        "id": "3f6d711f-057c-4de7-80d5-d37d6ab02d35",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1552105930057,
        "parent_id": "a2ae7a48-40a7-4668-b1f2-86f1667a4b3e",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "In computer science, a trie, also called digital tree and sometimes radix tree or prefix tree (as they can be searched by prefixes), is a kind of search tree—an ordered tree data structure that is used to store a dynamic set or associative array where the keys are usually strings. (Wikipedia, "
            ],
            [
              "source",
              [
                [
                  "a",
                  "https://en.wikipedia.org/wiki/Trie"
                ]
              ]
            ],
            [
              ")"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "In computer science, a trie, also called digital tree and sometimes radix tree or prefix tree (as they can be searched by prefixes), is a kind of search tree—an ordered tree data structure that is used to store a dynamic set or associative array where the keys are usually strings. (Wikipedia, "
          },
          {
            "Text": "source",
            "Link": "https://en.wikipedia.org/wiki/Trie"
          },
          {
            "Text": ")"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1552105930057,
        "id": "877d16b9-61fa-4b1e-bd8e-a46e4eb43a33",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1552105930057,
        "parent_id": "a2ae7a48-40a7-4668-b1f2-86f1667a4b3e",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "//\n//  Trie.swift\n//  SwiftStructures\n//\n//  Created by Wayne Bishop on 10/14/14.\n//  Copyright (c) 2014 Arbutus Software Inc. All rights reserved.\n//\nimport Foundation\n\n\npublic class Trie {\n    \n    private var root: TrieNode!\n    \n    \n    init(){\n        root = TrieNode()\n    }\n    \n    \n    \n    //builds a tree hierarchy of dictionary content\n    func append(word keyword: String) {\n        \n        \n        //trivial case\n        guard keyword.length \u003e 0 else {\n            return\n        }\n        \n        \n        var current: TrieNode = root\n        \n        \n        while keyword.length != current.level {\n            \n            var childToUse: TrieNode!\n            let searchKey = keyword.substring(to: current.level + 1)\n            \n            \n            //print(\"current has \\(current.children.count) children..\")\n            \n            \n            //iterate through child nodes\n            for child in current.children {\n                \n                if (child.key == searchKey) {\n                    childToUse = child\n                    break\n                }\n                \n            }\n            \n            \n            //new node\n            if childToUse == nil {\n                \n                childToUse = TrieNode()\n                childToUse.key = searchKey\n                childToUse.level = current.level + 1\n                current.children.append(childToUse)\n            }\n            \n            \n            current = childToUse\n            \n            \n        } //end while\n        \n        \n        //final end of word check\n        if (keyword.length == current.level) {\n            current.isFinal = true\n            print(\"end of word reached!\")\n            return\n        }\n        \n        \n        \n    } //end function\n    \n    \n\n    \n    //find words based on the prefix\n    func search(forWord keyword: String) -\u003e Array\u003cString\u003e! {\n        \n        \n        //trivial case\n        guard keyword.length \u003e 0 else {\n            return nil\n        }\n        \n        \n        var current: TrieNode = root\n        var wordList = Array\u003cString\u003e()\n        \n        \n        while keyword.length != current.level {\n            \n            var childToUse: TrieNode!\n            let searchKey = keyword.substring(to: current.level + 1)\n            \n\n            //print(\"looking for prefix: \\(searchKey)..\")\n            \n            \n            //iterate through any child nodes\n            for child in current.children {\n                \n                if (child.key == searchKey) {\n                    childToUse = child\n                    current = childToUse\n                    break\n                }\n                \n            }\n            \n \n            if childToUse == nil {\n               return nil\n            }\n            \n            \n        } //end while\n        \n        \n        \n        //retrieve the keyword and any descendants\n        if ((current.key == keyword) \u0026\u0026 (current.isFinal)) {\n            wordList.append(current.key)\n        }\n\n        \n        //include only children that are words\n        for child in current.children {\n            \n            if (child.isFinal == true) {\n                wordList.append(child.key)\n            }\n            \n        }\n        \n        \n        return wordList\n\n        \n    } //end function\n    \n\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "//\n//  Trie.swift\n//  SwiftStructures\n//\n//  Created by Wayne Bishop on 10/14/14.\n//  Copyright (c) 2014 Arbutus Software Inc. All rights reserved.\n//\nimport Foundation\n\n\npublic class Trie {\n    \n    private var root: TrieNode!\n    \n    \n    init(){\n        root = TrieNode()\n    }\n    \n    \n    \n    //builds a tree hierarchy of dictionary content\n    func append(word keyword: String) {\n        \n        \n        //trivial case\n        guard keyword.length \u003e 0 else {\n            return\n        }\n        \n        \n        var current: TrieNode = root\n        \n        \n        while keyword.length != current.level {\n            \n            var childToUse: TrieNode!\n            let searchKey = keyword.substring(to: current.level + 1)\n            \n            \n            //print(\"current has \\(current.children.count) children..\")\n            \n            \n            //iterate through child nodes\n            for child in current.children {\n                \n                if (child.key == searchKey) {\n                    childToUse = child\n                    break\n                }\n                \n            }\n            \n            \n            //new node\n            if childToUse == nil {\n                \n                childToUse = TrieNode()\n                childToUse.key = searchKey\n                childToUse.level = current.level + 1\n                current.children.append(childToUse)\n            }\n            \n            \n            current = childToUse\n            \n            \n        } //end while\n        \n        \n        //final end of word check\n        if (keyword.length == current.level) {\n            current.isFinal = true\n            print(\"end of word reached!\")\n            return\n        }\n        \n        \n        \n    } //end function\n    \n    \n\n    \n    //find words based on the prefix\n    func search(forWord keyword: String) -\u003e Array\u003cString\u003e! {\n        \n        \n        //trivial case\n        guard keyword.length \u003e 0 else {\n            return nil\n        }\n        \n        \n        var current: TrieNode = root\n        var wordList = Array\u003cString\u003e()\n        \n        \n        while keyword.length != current.level {\n            \n            var childToUse: TrieNode!\n            let searchKey = keyword.substring(to: current.level + 1)\n            \n\n            //print(\"looking for prefix: \\(searchKey)..\")\n            \n            \n            //iterate through any child nodes\n            for child in current.children {\n                \n                if (child.key == searchKey) {\n                    childToUse = child\n                    current = childToUse\n                    break\n                }\n                \n            }\n            \n \n            if childToUse == nil {\n               return nil\n            }\n            \n            \n        } //end while\n        \n        \n        \n        //retrieve the keyword and any descendants\n        if ((current.key == keyword) \u0026\u0026 (current.isFinal)) {\n            wordList.append(current.key)\n        }\n\n        \n        //include only children that are words\n        for child in current.children {\n            \n            if (child.isFinal == true) {\n                wordList.append(child.key)\n            }\n            \n        }\n        \n        \n        return wordList\n\n        \n    } //end function\n    \n\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1552105930058,
        "id": "0cd8dde0-0282-47cd-86a3-f31872ee9731",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1552105930058,
        "parent_id": "a2ae7a48-40a7-4668-b1f2-86f1667a4b3e",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "(GitHub, "
            ],
            [
              "source",
              [
                [
                  "a",
                  "https://github.com/waynewbishop/SwiftStructures/blob/master/Source/Factories/Trie.swift"
                ]
              ]
            ],
            [
              ")"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "(GitHub, "
          },
          {
            "Text": "source",
            "Link": "https://github.com/waynewbishop/SwiftStructures/blob/master/Source/Factories/Trie.swift"
          },
          {
            "Text": ")"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1552105930058,
        "id": "a4d945c4-c584-4792-8cab-2406a0d1ff8b",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1552105930058,
        "parent_id": "a2ae7a48-40a7-4668-b1f2-86f1667a4b3e",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Stack",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Stack",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1552105930058,
        "id": "11e53b17-80c5-4daf-9477-0536b360e53a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1552105930058,
        "parent_id": "a2ae7a48-40a7-4668-b1f2-86f1667a4b3e",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "In computer science, a stack is an abstract data type that serves as a collection of elements, with two principal operations: push, which adds an element to the collection, and pop, which removes the most recently added element that was not yet removed. The order in which elements come off a stack gives rise to its alternative name, LIFO (for last in, first out). Additionally, a peek operation may give access to the top without modifying the stack. (Wikipedia, "
            ],
            [
              "source",
              [
                [
                  "a",
                  "https://en.wikipedia.org/wiki/Stack_(abstract_data_type)"
                ]
              ]
            ],
            [
              ")"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "In computer science, a stack is an abstract data type that serves as a collection of elements, with two principal operations: push, which adds an element to the collection, and pop, which removes the most recently added element that was not yet removed. The order in which elements come off a stack gives rise to its alternative name, LIFO (for last in, first out). Additionally, a peek operation may give access to the top without modifying the stack. (Wikipedia, "
          },
          {
            "Text": "source",
            "Link": "https://en.wikipedia.org/wiki/Stack_(abstract_data_type)"
          },
          {
            "Text": ")"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1552105930059,
        "id": "46936932-570f-4824-8060-f56f4e5f72f5",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1552105930059,
        "parent_id": "a2ae7a48-40a7-4668-b1f2-86f1667a4b3e",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "See license info below and original code source at ("
            ],
            [
              "github",
              [
                [
                  "a",
                  "https://github.com/waynewbishop/SwiftStructures/blob/master/Source/Factories/Stack.swift"
                ]
              ]
            ],
            [
              ")"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "See license info below and original code source at ("
          },
          {
            "Text": "github",
            "Link": "https://github.com/waynewbishop/SwiftStructures/blob/master/Source/Factories/Stack.swift"
          },
          {
            "Text": ")"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1552105930059,
        "id": "f66d1937-54c5-4ef0-a9b3-fa2644c66f6b",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1552105930059,
        "parent_id": "a2ae7a48-40a7-4668-b1f2-86f1667a4b3e",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "//\n//  Stack.swift\n//  SwiftStructures\n//\n//  Created by Wayne Bishop on 8/1/14.\n//  Copyright (c) 2014 Arbutus Software Inc. All rights reserved.\n//\nimport Foundation\n\n\nclass Stack\u003cT\u003e {\n    \n    private var top: Node\u003cT\u003e\n    \n    init() {\n        top = Node\u003cT\u003e()\n    }\n    \n    \n    //the number of items - O(n)\n    var count: Int {\n        \n        \n        //return trivial case\n        guard top.key != nil else {\n          return 0\n        }\n                \n        \n        var current = top\n        var x: Int = 1\n        \n        \n        //cycle through list\n        while current.next != nil {\n            current = current.next!\n            x += 1\n        }\n            \n        return x        \n        \n    }\n    \n    \n    //add item to the stack\n    func push(withKey key: T) {\n        \n        \n        //return trivial case\n        guard top.key != nil else {\n            top.key = key\n            return\n        }\n        \n        \n        //create new item\n        let childToUse = Node\u003cT\u003e()\n        childToUse.key = key\n            \n            \n        //set new created item at top\n        childToUse.next = top\n        top = childToUse        \n\n    }\n    \n\n    //remove item from the stack\n    func pop() {\n        \n        if self.count \u003e 1 {\n            top = top.next\n        }\n        else {\n            top.key = nil\n        }\n        \n    }\n    \n    \n    //retrieve the top most item\n    func peek() -\u003e T! {\n\n        \n        //determine instance\n        if let topitem = top.key {\n            return topitem\n        }\n            \n        else {\n            return nil\n        }\n        \n    }\n    \n    \n    \n    //check for value\n    func isEmpty() -\u003e Bool {\n        \n        if self.count == 0 {\n            return true\n        }\n        \n        else {\n            return false\n        }\n        \n    }\n    \n\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "//\n//  Stack.swift\n//  SwiftStructures\n//\n//  Created by Wayne Bishop on 8/1/14.\n//  Copyright (c) 2014 Arbutus Software Inc. All rights reserved.\n//\nimport Foundation\n\n\nclass Stack\u003cT\u003e {\n    \n    private var top: Node\u003cT\u003e\n    \n    init() {\n        top = Node\u003cT\u003e()\n    }\n    \n    \n    //the number of items - O(n)\n    var count: Int {\n        \n        \n        //return trivial case\n        guard top.key != nil else {\n          return 0\n        }\n                \n        \n        var current = top\n        var x: Int = 1\n        \n        \n        //cycle through list\n        while current.next != nil {\n            current = current.next!\n            x += 1\n        }\n            \n        return x        \n        \n    }\n    \n    \n    //add item to the stack\n    func push(withKey key: T) {\n        \n        \n        //return trivial case\n        guard top.key != nil else {\n            top.key = key\n            return\n        }\n        \n        \n        //create new item\n        let childToUse = Node\u003cT\u003e()\n        childToUse.key = key\n            \n            \n        //set new created item at top\n        childToUse.next = top\n        top = childToUse        \n\n    }\n    \n\n    //remove item from the stack\n    func pop() {\n        \n        if self.count \u003e 1 {\n            top = top.next\n        }\n        else {\n            top.key = nil\n        }\n        \n    }\n    \n    \n    //retrieve the top most item\n    func peek() -\u003e T! {\n\n        \n        //determine instance\n        if let topitem = top.key {\n            return topitem\n        }\n            \n        else {\n            return nil\n        }\n        \n    }\n    \n    \n    \n    //check for value\n    func isEmpty() -\u003e Bool {\n        \n        if self.count == 0 {\n            return true\n        }\n        \n        else {\n            return false\n        }\n        \n    }\n    \n\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1552105930059,
        "id": "05aeac02-f7de-46b2-b2a9-308dcab97857",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1552105930059,
        "parent_id": "a2ae7a48-40a7-4668-b1f2-86f1667a4b3e",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The MIT License (MIT)"
            ]
          ]
        },
        "type": "quote",
        "version": 1,
        "inline_content": [
          {
            "Text": "The MIT License (MIT)"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1552105930059,
        "id": "277eb1e2-651d-44b4-a044-c29d9c02bf44",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1552105930059,
        "parent_id": "a2ae7a48-40a7-4668-b1f2-86f1667a4b3e",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Copyright (c) 2015, Wayne Bishop \u0026 Arbutus Software Inc."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Copyright (c) 2015, Wayne Bishop \u0026 Arbutus Software Inc."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1552105930060,
        "id": "0c0d7863-3b2d-4066-9601-58a0b4e86d10",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1552105930060,
        "parent_id": "a2ae7a48-40a7-4668-b1f2-86f1667a4b3e",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Permission is hereby granted, free of charge, to any person obtaining \u003e a copy of this software and associated documentation files (the \u003e “Software”), to deal in the Software without restriction, including \u003e without limitation the rights to use, copy, modify, merge, publish, \u003e distribute, sublicense, and/or sell copies of the Software, and to \u003e permit persons to whom the Software is furnished to do so, subject to \u003e the following conditions:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Permission is hereby granted, free of charge, to any person obtaining \u003e a copy of this software and associated documentation files (the \u003e “Software”), to deal in the Software without restriction, including \u003e without limitation the rights to use, copy, modify, merge, publish, \u003e distribute, sublicense, and/or sell copies of the Software, and to \u003e permit persons to whom the Software is furnished to do so, subject to \u003e the following conditions:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1552105930060,
        "id": "dffde78b-3044-4c5d-a798-ff341b73bb09",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1552105930060,
        "parent_id": "a2ae7a48-40a7-4668-b1f2-86f1667a4b3e",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The above copyright notice and this permission notice shall be \u003e included in all copies or substantial portions of the Software."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The above copyright notice and this permission notice shall be \u003e included in all copies or substantial portions of the Software."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1552105930060,
        "id": "ce37dcd4-d5f4-4209-af4a-30680f0c3e3b",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1552105930060,
        "parent_id": "a2ae7a48-40a7-4668-b1f2-86f1667a4b3e",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, \u003e EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \u003e MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \u003e IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY \u003e CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \u003e TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \u003e SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, \u003e EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \u003e MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \u003e IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY \u003e CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \u003e TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \u003e SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
          }
        ]
      }
    ],
    "title": "Graph Trie Stack",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 19
    }
  ],
  "Tables": null
}