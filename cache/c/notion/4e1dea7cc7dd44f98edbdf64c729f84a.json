{
  "ID": "4e1dea7c-c7dd-44f9-8edb-df64c729f84a",
  "Root": {
    "alive": true,
    "content": [
      "579fb665-0b96-4e54-8c46-b3b1588bff73",
      "c83c220f-c42d-4668-91ff-5ca9748c081b",
      "f2d41390-429a-4507-94bd-04759280df8a",
      "75818a5e-a8ce-47b2-84d4-71b94ed9d00d",
      "d4dcc466-b725-430c-aff5-aa4cd24daf3e",
      "8ff715e8-d696-4edd-8df8-7e0a02521950",
      "ef7c462d-58f9-49e1-b1d2-f509ac46fe14",
      "86d21cc1-ea8c-4096-9723-69ed9a2b6d04",
      "a1f6e47c-f912-4b8c-b877-ffd620338965",
      "2ad797df-f0ed-4687-8cbe-01922ab3d420",
      "f6afbcb8-22bd-47e1-b21e-5be272ce62de"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1551936247189,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "4e1dea7c-c7dd-44f9-8edb-df64c729f84a",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1551936247189,
    "parent_id": "690adfe7-1f94-4d22-83ad-47d3971f3325",
    "parent_table": "block",
    "properties": {
      "title": [
        [
          "Using GNU getopt tools"
        ]
      ]
    },
    "type": "page",
    "version": 3,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551936247182,
        "id": "579fb665-0b96-4e54-8c46-b3b1588bff73",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551936247182,
        "parent_id": "4e1dea7c-c7dd-44f9-8edb-df64c729f84a",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Command-line options for applications are not treated any differently from command-line arguments by the C language. They are just arguments which, in a Linux or Unix environment, traditionally begin with a dash ("
            ],
            [
              "\\-",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ")."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Command-line options for applications are not treated any differently from command-line arguments by the C language. They are just arguments which, in a Linux or Unix environment, traditionally begin with a dash ("
          },
          {
            "Text": "\\-",
            "AttrFlags": 2
          },
          {
            "Text": ")."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551936247186,
        "id": "c83c220f-c42d-4668-91ff-5ca9748c081b",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551936247186,
        "parent_id": "4e1dea7c-c7dd-44f9-8edb-df64c729f84a",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "With glibc in a Linux or Unix environment you can use the "
            ],
            [
              "getopt tools",
              [
                [
                  "a",
                  "https://www.gnu.org/software/libc/manual/html_node/Getopt.html"
                ]
              ]
            ],
            [
              " to easily define, validate, and parse command-line options from the rest of your arguments."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "With glibc in a Linux or Unix environment you can use the "
          },
          {
            "Text": "getopt tools",
            "Link": "https://www.gnu.org/software/libc/manual/html_node/Getopt.html"
          },
          {
            "Text": " to easily define, validate, and parse command-line options from the rest of your arguments."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551936247187,
        "id": "f2d41390-429a-4507-94bd-04759280df8a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551936247187,
        "parent_id": "4e1dea7c-c7dd-44f9-8edb-df64c729f84a",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "These tools expect your options to be formatted according to the "
            ],
            [
              "GNU Coding Standards",
              [
                [
                  "a",
                  "https://www.gnu.org/prep/standards/html_node/Command_002dLine-Interfaces.html"
                ]
              ]
            ],
            [
              ", which is an extension of what POSIX specifies for the format of command-line options."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "These tools expect your options to be formatted according to the "
          },
          {
            "Text": "GNU Coding Standards",
            "Link": "https://www.gnu.org/prep/standards/html_node/Command_002dLine-Interfaces.html"
          },
          {
            "Text": ", which is an extension of what POSIX specifies for the format of command-line options."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551936247187,
        "id": "75818a5e-a8ce-47b2-84d4-71b94ed9d00d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551936247187,
        "parent_id": "4e1dea7c-c7dd-44f9-8edb-df64c729f84a",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The example below demonstrates handling command-line options with the GNU getopt tools."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The example below demonstrates handling command-line options with the GNU getopt tools."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551936247187,
        "id": "d4dcc466-b725-430c-aff5-aa4cd24daf3e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551936247187,
        "parent_id": "4e1dea7c-c7dd-44f9-8edb-df64c729f84a",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "#include \u003cstdio.h\u003e\n#include \u003cgetopt.h\u003e\n#include \u003cstring.h\u003e\n\n/* print a description of all supported options */\nvoid usage (FILE *fp, const char *path)\n{\n    /* take only the last portion of the path */\n    const char *basename = strrchr(path, '/');\n    basename = basename ? basename + 1 : path;\n\n    fprintf (fp, \"usage: %s [OPTION]\\n\", basename);\n    fprintf (fp, \"  -h, --help\\t\\t\"\n                 \"Print this help and exit.\\n\");\n    fprintf (fp, \"  -f, --file[=FILENAME]\\t\"\n                 \"Write all output to a file (defaults to out.txt).\\n\");\n    fprintf (fp, \"  -m, --msg=STRING\\t\"\n                 \"Output a particular message rather than 'Hello world'.\\n\");\n}\n\n/* parse command-line options and print message */\nint main(int argc, char *argv[])\n{\n    /* for code brevity this example just uses fixed buffer sizes for strings */\n    char filename[256] = { 0 };\n    char message[256] = \"Hello world\";\n    FILE *fp;\n    int help_flag = 0;\n    int opt;\n\n    /* table of all supported options in their long form.\n     * fields: name, has_arg, flag, val\n     * `has_arg` specifies whether the associated long-form option can (or, in\n     * some cases, must) have an argument. the valid values for `has_arg` are\n     * `no_argument`, `optional_argument`, and `required_argument`.\n     * if `flag` points to a variable, then the variable will be given a value\n     * of `val` when the associated long-form option is present at the command\n     * line.\n     * if `flag` is NULL, then `val` is returned by `getopt_long` (see below)\n     * when the associated long-form option is found amongst the command-line\n     * arguments.\n     */\n    struct option longopts[] = {\n        { \"help\", no_argument, \u0026help_flag, 1 },\n        { \"file\", optional_argument, NULL, 'f' },\n        { \"msg\", required_argument, NULL, 'm' },\n        { 0 }\n    };\n\n    /* infinite loop, to be broken when we are done parsing options */\n    while (1) {\n        /* getopt_long supports GNU-style full-word \"long\" options in addition\n         * to the single-character \"short\" options which are supported by\n         * getopt.\n         * the third argument is a collection of supported short-form options.\n         * these do not necessarily have to correlate to the long-form options.\n         * one colon after an option indicates that it has an argument, two\n         * indicates that the argument is optional. order is unimportant.\n         */\n        opt = getopt_long (argc, argv, \"hf::m:\", longopts, 0);\n\n        if (opt == -1) {\n            /* a return value of -1 indicates that there are no more options */\n            break;\n        }\n\n        switch (opt) {\n        case 'h':\n            /* the help_flag and value are specified in the longopts table,\n             * which means that when the --help option is specified (in its long\n             * form), the help_flag variable will be automatically set.\n             * however, the parser for short-form options does not support the\n             * automatic setting of flags, so we still need this code to set the\n             * help_flag manually when the -h option is specified.\n             */\n            help_flag = 1;\n            break;\n        case 'f':\n            /* optarg is a global variable in getopt.h. it contains the argument\n             * for this option. it is null if there was no argument.\n             */\n            printf (\"outarg: '%s'\\n\", optarg);\n            strncpy (filename, optarg ? optarg : \"out.txt\", sizeof (filename));\n            /* strncpy does not fully guarantee null-termination */\n            filename[sizeof (filename) - 1] = '\\0';\n            break;\n        case 'm':\n            /* since the argument for this option is required, getopt guarantees\n             * that aptarg is non-null.\n             */\n            strncpy (message, optarg, sizeof (message));\n            message[sizeof (message) - 1] = '\\0';\n            break;\n        case '?':\n            /* a return value of '?' indicates that an option was malformed.\n             * this could mean that an unrecognized option was given, or that an\n             * option which requires an argument did not include an argument.\n             */\n            usage (stderr, argv[0]);\n            return 1;\n        default:\n            break;\n        }\n    }\n\n    if (help_flag) {\n        usage (stdout, argv[0]);\n        return 0;\n    }\n\n    if (filename[0]) {\n        fp = fopen (filename, \"w\");\n    } else {\n        fp = stdout;\n    }\n\n    if (!fp) {\n        fprintf(stderr, \"Failed to open file.\\n\");\n        return 1;\n    }\n\n    fprintf (fp, \"%s\\n\", message);\n\n    fclose (fp);\n    return 0;\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "#include \u003cstdio.h\u003e\n#include \u003cgetopt.h\u003e\n#include \u003cstring.h\u003e\n\n/* print a description of all supported options */\nvoid usage (FILE *fp, const char *path)\n{\n    /* take only the last portion of the path */\n    const char *basename = strrchr(path, '/');\n    basename = basename ? basename + 1 : path;\n\n    fprintf (fp, \"usage: %s [OPTION]\\n\", basename);\n    fprintf (fp, \"  -h, --help\\t\\t\"\n                 \"Print this help and exit.\\n\");\n    fprintf (fp, \"  -f, --file[=FILENAME]\\t\"\n                 \"Write all output to a file (defaults to out.txt).\\n\");\n    fprintf (fp, \"  -m, --msg=STRING\\t\"\n                 \"Output a particular message rather than 'Hello world'.\\n\");\n}\n\n/* parse command-line options and print message */\nint main(int argc, char *argv[])\n{\n    /* for code brevity this example just uses fixed buffer sizes for strings */\n    char filename[256] = { 0 };\n    char message[256] = \"Hello world\";\n    FILE *fp;\n    int help_flag = 0;\n    int opt;\n\n    /* table of all supported options in their long form.\n     * fields: name, has_arg, flag, val\n     * `has_arg` specifies whether the associated long-form option can (or, in\n     * some cases, must) have an argument. the valid values for `has_arg` are\n     * `no_argument`, `optional_argument`, and `required_argument`.\n     * if `flag` points to a variable, then the variable will be given a value\n     * of `val` when the associated long-form option is present at the command\n     * line.\n     * if `flag` is NULL, then `val` is returned by `getopt_long` (see below)\n     * when the associated long-form option is found amongst the command-line\n     * arguments.\n     */\n    struct option longopts[] = {\n        { \"help\", no_argument, \u0026help_flag, 1 },\n        { \"file\", optional_argument, NULL, 'f' },\n        { \"msg\", required_argument, NULL, 'm' },\n        { 0 }\n    };\n\n    /* infinite loop, to be broken when we are done parsing options */\n    while (1) {\n        /* getopt_long supports GNU-style full-word \"long\" options in addition\n         * to the single-character \"short\" options which are supported by\n         * getopt.\n         * the third argument is a collection of supported short-form options.\n         * these do not necessarily have to correlate to the long-form options.\n         * one colon after an option indicates that it has an argument, two\n         * indicates that the argument is optional. order is unimportant.\n         */\n        opt = getopt_long (argc, argv, \"hf::m:\", longopts, 0);\n\n        if (opt == -1) {\n            /* a return value of -1 indicates that there are no more options */\n            break;\n        }\n\n        switch (opt) {\n        case 'h':\n            /* the help_flag and value are specified in the longopts table,\n             * which means that when the --help option is specified (in its long\n             * form), the help_flag variable will be automatically set.\n             * however, the parser for short-form options does not support the\n             * automatic setting of flags, so we still need this code to set the\n             * help_flag manually when the -h option is specified.\n             */\n            help_flag = 1;\n            break;\n        case 'f':\n            /* optarg is a global variable in getopt.h. it contains the argument\n             * for this option. it is null if there was no argument.\n             */\n            printf (\"outarg: '%s'\\n\", optarg);\n            strncpy (filename, optarg ? optarg : \"out.txt\", sizeof (filename));\n            /* strncpy does not fully guarantee null-termination */\n            filename[sizeof (filename) - 1] = '\\0';\n            break;\n        case 'm':\n            /* since the argument for this option is required, getopt guarantees\n             * that aptarg is non-null.\n             */\n            strncpy (message, optarg, sizeof (message));\n            message[sizeof (message) - 1] = '\\0';\n            break;\n        case '?':\n            /* a return value of '?' indicates that an option was malformed.\n             * this could mean that an unrecognized option was given, or that an\n             * option which requires an argument did not include an argument.\n             */\n            usage (stderr, argv[0]);\n            return 1;\n        default:\n            break;\n        }\n    }\n\n    if (help_flag) {\n        usage (stdout, argv[0]);\n        return 0;\n    }\n\n    if (filename[0]) {\n        fp = fopen (filename, \"w\");\n    } else {\n        fp = stdout;\n    }\n\n    if (!fp) {\n        fprintf(stderr, \"Failed to open file.\\n\");\n        return 1;\n    }\n\n    fprintf (fp, \"%s\\n\", message);\n\n    fclose (fp);\n    return 0;\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551936247187,
        "id": "8ff715e8-d696-4edd-8df8-7e0a02521950",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551936247187,
        "parent_id": "4e1dea7c-c7dd-44f9-8edb-df64c729f84a",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "It can be compiled with "
            ],
            [
              "gcc",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ":"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "It can be compiled with "
          },
          {
            "Text": "gcc",
            "AttrFlags": 2
          },
          {
            "Text": ":"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551936247187,
        "id": "ef7c462d-58f9-49e1-b1d2-f509ac46fe14",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551936247187,
        "parent_id": "4e1dea7c-c7dd-44f9-8edb-df64c729f84a",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "gcc example.c -o example"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "gcc example.c -o example",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551936247188,
        "id": "86d21cc1-ea8c-4096-9723-69ed9a2b6d04",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551936247188,
        "parent_id": "4e1dea7c-c7dd-44f9-8edb-df64c729f84a",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "It supports three command-line options ("
            ],
            [
              "--help",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "--file",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ", and "
            ],
            [
              "--msg",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "). All have a “short form” as well ("
            ],
            [
              "-h",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "-f",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              ", and "
            ],
            [
              "-m",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              "). The “file” and “msg” options both accept arguments. If you specify the “msg” option, its argument is required."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "It supports three command-line options ("
          },
          {
            "Text": "--help",
            "AttrFlags": 2
          },
          {
            "Text": ", "
          },
          {
            "Text": "--file",
            "AttrFlags": 2
          },
          {
            "Text": ", and "
          },
          {
            "Text": "--msg",
            "AttrFlags": 2
          },
          {
            "Text": "). All have a “short form” as well ("
          },
          {
            "Text": "-h",
            "AttrFlags": 2
          },
          {
            "Text": ", "
          },
          {
            "Text": "-f",
            "AttrFlags": 2
          },
          {
            "Text": ", and "
          },
          {
            "Text": "-m",
            "AttrFlags": 2
          },
          {
            "Text": "). The “file” and “msg” options both accept arguments. If you specify the “msg” option, its argument is required."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551936247188,
        "id": "a1f6e47c-f912-4b8c-b877-ffd620338965",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551936247188,
        "parent_id": "4e1dea7c-c7dd-44f9-8edb-df64c729f84a",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Arguments for options are formatted as:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Arguments for options are formatted as:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551936247188,
        "id": "2ad797df-f0ed-4687-8cbe-01922ab3d420",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551936247188,
        "parent_id": "4e1dea7c-c7dd-44f9-8edb-df64c729f84a",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "--option=value",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " (for long-form options)"
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "--option=value",
            "AttrFlags": 2
          },
          {
            "Text": " (for long-form options)"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1551936247189,
        "id": "f6afbcb8-22bd-47e1-b21e-5be272ce62de",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1551936247189,
        "parent_id": "4e1dea7c-c7dd-44f9-8edb-df64c729f84a",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "-ovalue",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " or "
            ],
            [
              "-o\"value\"",
              [
                [
                  "c"
                ]
              ]
            ],
            [
              " (for short-form options)"
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "-ovalue",
            "AttrFlags": 2
          },
          {
            "Text": " or "
          },
          {
            "Text": "-o\"value\"",
            "AttrFlags": 2
          },
          {
            "Text": " (for short-form options)"
          }
        ]
      }
    ],
    "title": "Using GNU getopt tools",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 18
    }
  ],
  "Tables": null
}