---
Title: Defer gotchas
Id: rd6000ub
---

When using `defer` keep the following in mind.

## Deferred functions are called at function end

Deferred statements have a function scope, not a block scope.

In other words: deferred calls are execuated when exiting a function not when executing block crated with `if` or `for` statements.

@file defer_gotcha.go output

You might expect that deferred statement to be executed when we exit `if` branch but it's executed as the last thing in a function.

## Deferred function arguments

@file defer_gotcha2.go output

You might have expected that this code will print `0` and `1`, because those are the values of `i` when we evaluate `defer`.

It's clear what happens when we see what kind of code is generated by the compiler behind the scenes:

```go
var i int
for i = 0; i < 2; i++ {
}

fmt.Printf("%d\n", i)
fmt.Printf("%d\n", i)
```

It's clear that at this point `i` is `2`, which is why we print `2` twice.

We can fix by using a [closure](a-9226) to capture the variable:

@file defer_gotcha3.go output

Closures are more expensive because it requires allocating a behind-the-scenes object to callect all variables captured by the closure.
